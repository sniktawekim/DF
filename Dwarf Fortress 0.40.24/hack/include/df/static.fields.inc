/* THIS FILE WAS GENERATED. DO NOT EDIT. */
#include "abstract_building.h"
#include "abstract_building_dark_towerst.h"
#include "abstract_building_dungeonst.h"
#include "abstract_building_keepst.h"
#include "abstract_building_marketst.h"
#include "abstract_building_mead_hallst.h"
#include "abstract_building_templest.h"
#include "abstract_building_tombst.h"
#include "abstract_building_underworld_spirest.h"
#include "abstract_building_unk.h"
#include "active_script_var_longst.h"
#include "active_script_var_unitst.h"
#include "active_script_varst.h"
#include "activity_entry.h"
#include "activity_event.h"
#include "activity_event_combat_trainingst.h"
#include "activity_event_conflictst.h"
#include "activity_event_conversationst.h"
#include "activity_event_guardst.h"
#include "activity_event_harassmentst.h"
#include "activity_event_individual_skill_drillst.h"
#include "activity_event_participants.h"
#include "activity_event_ranged_practicest.h"
#include "activity_event_reunionst.h"
#include "activity_event_skill_demonstrationst.h"
#include "activity_event_sparringst.h"
#include "activity_event_training_sessionst.h"
#include "activity_info.h"
#include "adventure_log_item.h"
#include "adventure_movement_option.h"
#include "ammo_flags.h"
#include "announcement_type.h"
#include "announcements.h"
#include "armor_flags.h"
#include "armor_general_flags.h"
#include "armor_properties.h"
#include "army.h"
#include "army_controller.h"
#include "art_facet_type.h"
#include "art_image.h"
#include "art_image_chunk.h"
#include "art_image_element.h"
#include "art_image_element_creaturest.h"
#include "art_image_element_itemst.h"
#include "art_image_element_plantst.h"
#include "art_image_element_shapest.h"
#include "art_image_element_treest.h"
#include "art_image_element_type.h"
#include "art_image_property.h"
#include "art_image_property_intransitive_verbst.h"
#include "art_image_property_transitive_verbst.h"
#include "art_image_ref.h"
#include "artifact_record.h"
#include "assign_trade_status.h"
#include "barrack_preference_category.h"
#include "biome_type.h"
#include "block_burrow.h"
#include "block_burrow_link.h"
#include "block_square_event.h"
#include "block_square_event_designation_priorityst.h"
#include "block_square_event_frozen_liquidst.h"
#include "block_square_event_grassst.h"
#include "block_square_event_item_spatterst.h"
#include "block_square_event_material_spatterst.h"
#include "block_square_event_mineralst.h"
#include "block_square_event_spoorst.h"
#include "block_square_event_world_constructionst.h"
#include "body_appearance_modifier.h"
#include "body_component_info.h"
#include "body_detail_plan.h"
#include "body_part_layer_flags.h"
#include "body_part_layer_raw.h"
#include "body_part_raw.h"
#include "body_part_raw_flags.h"
#include "body_part_template.h"
#include "body_part_template_flags.h"
#include "body_size_info.h"
#include "body_template.h"
#include "bp_appearance_modifier.h"
#include "build_req_choice_genst.h"
#include "build_req_choice_specst.h"
#include "build_req_choicest.h"
#include "building.h"
#include "building_actual.h"
#include "building_animaltrapst.h"
#include "building_archerytargetst.h"
#include "building_armorstandst.h"
#include "building_axle_horizontalst.h"
#include "building_axle_verticalst.h"
#include "building_bars_floorst.h"
#include "building_bars_verticalst.h"
#include "building_bedst.h"
#include "building_boxst.h"
#include "building_bridgest.h"
#include "building_cabinetst.h"
#include "building_cagest.h"
#include "building_chainst.h"
#include "building_chairst.h"
#include "building_civzonest.h"
#include "building_coffinst.h"
#include "building_constructionst.h"
#include "building_def.h"
#include "building_def_furnacest.h"
#include "building_def_item.h"
#include "building_def_workshopst.h"
#include "building_design.h"
#include "building_doorst.h"
#include "building_drawbuffer.h"
#include "building_extents.h"
#include "building_farmplotst.h"
#include "building_floodgatest.h"
#include "building_furnacest.h"
#include "building_gear_assemblyst.h"
#include "building_grate_floorst.h"
#include "building_grate_wallst.h"
#include "building_hatchst.h"
#include "building_hivest.h"
#include "building_nest_boxst.h"
#include "building_nestst.h"
#include "building_road_dirtst.h"
#include "building_road_pavedst.h"
#include "building_roadst.h"
#include "building_rollersst.h"
#include "building_screw_pumpst.h"
#include "building_shopst.h"
#include "building_siegeenginest.h"
#include "building_slabst.h"
#include "building_squad_use.h"
#include "building_statuest.h"
#include "building_stockpilest.h"
#include "building_supportst.h"
#include "building_tablest.h"
#include "building_traction_benchst.h"
#include "building_tradedepotst.h"
#include "building_trapst.h"
#include "building_type.h"
#include "building_users.h"
#include "building_wagonst.h"
#include "building_water_wheelst.h"
#include "building_weaponrackst.h"
#include "building_weaponst.h"
#include "building_wellst.h"
#include "building_windmillst.h"
#include "building_window_gemst.h"
#include "building_window_glassst.h"
#include "building_windowst.h"
#include "building_workshopst.h"
#include "buildings_other_id.h"
#include "builtin_mats.h"
#include "burrow.h"
#include "campfire.h"
#include "caravan_state.h"
#include "caste_attack.h"
#include "caste_body_info.h"
#include "caste_clothing_item.h"
#include "caste_raw.h"
#include "caste_raw_flags.h"
#include "cave_column.h"
#include "cave_column_link.h"
#include "cave_column_rectangle.h"
#include "coin_batch.h"
#include "color_modifier_raw.h"
#include "combat_report_event_type.h"
#include "construction.h"
#include "conversation.h"
#include "coord.h"
#include "coord2d.h"
#include "coord2d_path.h"
#include "coord_path.h"
#include "corpse_material_type.h"
#include "craft_material_class.h"
#include "creature_graphics_appointment.h"
#include "creature_graphics_role.h"
#include "creature_interaction_effect.h"
#include "creature_interaction_effect_add_simple_flagst.h"
#include "creature_interaction_effect_bleedingst.h"
#include "creature_interaction_effect_blistersst.h"
#include "creature_interaction_effect_body_mat_interactionst.h"
#include "creature_interaction_effect_body_transformationst.h"
#include "creature_interaction_effect_bp_appearance_modifierst.h"
#include "creature_interaction_effect_bruisingst.h"
#include "creature_interaction_effect_can_do_interactionst.h"
#include "creature_interaction_effect_cough_bloodst.h"
#include "creature_interaction_effect_display_namest.h"
#include "creature_interaction_effect_display_symbolst.h"
#include "creature_interaction_effect_dizzinessst.h"
#include "creature_interaction_effect_drowsinessst.h"
#include "creature_interaction_effect_feverst.h"
#include "creature_interaction_effect_flash_symbolst.h"
#include "creature_interaction_effect_impair_functionst.h"
#include "creature_interaction_effect_material_force_adjustst.h"
#include "creature_interaction_effect_ment_att_changest.h"
#include "creature_interaction_effect_nauseast.h"
#include "creature_interaction_effect_necrosisst.h"
#include "creature_interaction_effect_numbnessst.h"
#include "creature_interaction_effect_oozingst.h"
#include "creature_interaction_effect_painst.h"
#include "creature_interaction_effect_paralysisst.h"
#include "creature_interaction_effect_phys_att_changest.h"
#include "creature_interaction_effect_remove_simple_flagst.h"
#include "creature_interaction_effect_sense_creature_classst.h"
#include "creature_interaction_effect_skill_roll_adjustst.h"
#include "creature_interaction_effect_speed_changest.h"
#include "creature_interaction_effect_swellingst.h"
#include "creature_interaction_effect_target.h"
#include "creature_interaction_effect_unconsciousnessst.h"
#include "creature_interaction_effect_vomit_bloodst.h"
#include "creature_raw.h"
#include "creature_raw_flags.h"
#include "creature_variation.h"
#include "creature_variation_convert_tag.h"
#include "crime.h"
#include "cultural_identity.h"
#include "curse_attr_change.h"
#include "d_init.h"
#include "d_init_flags1.h"
#include "d_init_flags2.h"
#include "d_init_flags3.h"
#include "d_init_flags4.h"
#include "deep_vein_hollow.h"
#include "descriptor_color.h"
#include "descriptor_pattern.h"
#include "descriptor_shape.h"
#include "dipscript_info.h"
#include "dipscript_popup.h"
#include "dye_info.h"
#include "effect_info.h"
#include "embark_finder_option.h"
#include "embark_item_choice.h"
#include "embark_location.h"
#include "emotion_type.h"
#include "enabler.h"
#include "engraving.h"
#include "entity_activity_statistics.h"
#include "entity_buy_prices.h"
#include "entity_buy_requests.h"
#include "entity_claim_mask.h"
#include "entity_entity_link.h"
#include "entity_event.h"
#include "entity_population.h"
#include "entity_population_unk4.h"
#include "entity_position.h"
#include "entity_position_assignment.h"
#include "entity_position_flags.h"
#include "entity_position_raw.h"
#include "entity_position_raw_flags.h"
#include "entity_position_responsibility.h"
#include "entity_raw.h"
#include "entity_raw_flags.h"
#include "entity_recipe.h"
#include "entity_sell_category.h"
#include "entity_sell_prices.h"
#include "entity_sell_requests.h"
#include "entity_site_link.h"
#include "entity_tissue_style.h"
#include "entity_uniform.h"
#include "entity_uniform_item.h"
#include "ethic_type.h"
#include "feature.h"
#include "feature_alteration.h"
#include "feature_alteration_new_lava_fill_zst.h"
#include "feature_alteration_new_pop_maxst.h"
#include "feature_cavest.h"
#include "feature_deep_special_tubest.h"
#include "feature_deep_surface_portalst.h"
#include "feature_init.h"
#include "feature_init_cavest.h"
#include "feature_init_deep_special_tubest.h"
#include "feature_init_deep_surface_portalst.h"
#include "feature_init_flags.h"
#include "feature_init_magma_core_from_layerst.h"
#include "feature_init_magma_poolst.h"
#include "feature_init_outdoor_riverst.h"
#include "feature_init_pitst.h"
#include "feature_init_subterranean_from_layerst.h"
#include "feature_init_underworld_from_layerst.h"
#include "feature_init_volcanost.h"
#include "feature_magma_core_from_layerst.h"
#include "feature_magma_poolst.h"
#include "feature_outdoor_riverst.h"
#include "feature_pitst.h"
#include "feature_subterranean_from_layerst.h"
#include "feature_underworld_from_layerst.h"
#include "feature_volcanost.h"
#include "file_compressorst.h"
#include "fire.h"
#include "flow_guide.h"
#include "flow_guide_item_cloudst.h"
#include "flow_guide_trailing_flowst.h"
#include "flow_info.h"
#include "flow_reuse_pool.h"
#include "furniture_type.h"
#include "gait_info.h"
#include "gait_type.h"
#include "game_type.h"
#include "general_ref.h"
#include "general_ref_abstract_buildingst.h"
#include "general_ref_artifact.h"
#include "general_ref_building.h"
#include "general_ref_building_cagedst.h"
#include "general_ref_building_chainst.h"
#include "general_ref_building_civzone_assignedst.h"
#include "general_ref_building_destinationst.h"
#include "general_ref_building_holderst.h"
#include "general_ref_building_nest_boxst.h"
#include "general_ref_building_triggerst.h"
#include "general_ref_building_triggertargetst.h"
#include "general_ref_building_use_target_1st.h"
#include "general_ref_building_use_target_2st.h"
#include "general_ref_building_well_tag.h"
#include "general_ref_coinbatch.h"
#include "general_ref_contained_in_itemst.h"
#include "general_ref_contains_itemst.h"
#include "general_ref_contains_unitst.h"
#include "general_ref_creaturest.h"
#include "general_ref_entity.h"
#include "general_ref_entity_art_image.h"
#include "general_ref_entity_itemownerst.h"
#include "general_ref_entity_offeredst.h"
#include "general_ref_entity_popst.h"
#include "general_ref_entity_stolenst.h"
#include "general_ref_feature_layerst.h"
#include "general_ref_historical_eventst.h"
#include "general_ref_historical_figurest.h"
#include "general_ref_interactionst.h"
#include "general_ref_is_artifactst.h"
#include "general_ref_is_nemesisst.h"
#include "general_ref_item.h"
#include "general_ref_item_type.h"
#include "general_ref_locationst.h"
#include "general_ref_mapsquare.h"
#include "general_ref_nemesis.h"
#include "general_ref_projectile.h"
#include "general_ref_sitest.h"
#include "general_ref_spherest.h"
#include "general_ref_subregionst.h"
#include "general_ref_unit.h"
#include "general_ref_unit_beateest.h"
#include "general_ref_unit_cageest.h"
#include "general_ref_unit_foodreceiverst.h"
#include "general_ref_unit_holderst.h"
#include "general_ref_unit_infantst.h"
#include "general_ref_unit_itemownerst.h"
#include "general_ref_unit_kidnapeest.h"
#include "general_ref_unit_milkeest.h"
#include "general_ref_unit_patientst.h"
#include "general_ref_unit_reporteest.h"
#include "general_ref_unit_riderst.h"
#include "general_ref_unit_sheareest.h"
#include "general_ref_unit_slaughtereest.h"
#include "general_ref_unit_suckeest.h"
#include "general_ref_unit_tradebringerst.h"
#include "general_ref_unit_traineest.h"
#include "general_ref_unit_workerst.h"
#include "geo_layer_type.h"
#include "global_objects.h"
#include "gloves_flags.h"
#include "glowing_barrier.h"
#include "graphic.h"
#include "guild_id.h"
#include "hauler_type.h"
#include "hauling_route.h"
#include "hauling_stop.h"
#include "helm_flags.h"
#include "histfig_entity_link.h"
#include "histfig_entity_link_criminalst.h"
#include "histfig_entity_link_enemyst.h"
#include "histfig_entity_link_former_memberst.h"
#include "histfig_entity_link_former_mercenaryst.h"
#include "histfig_entity_link_former_positionst.h"
#include "histfig_entity_link_former_prisonerst.h"
#include "histfig_entity_link_former_slavest.h"
#include "histfig_entity_link_former_squadst.h"
#include "histfig_entity_link_memberst.h"
#include "histfig_entity_link_mercenaryst.h"
#include "histfig_entity_link_position_claimst.h"
#include "histfig_entity_link_positionst.h"
#include "histfig_entity_link_prisonerst.h"
#include "histfig_entity_link_slavest.h"
#include "histfig_entity_link_squadst.h"
#include "histfig_flags.h"
#include "histfig_hf_link.h"
#include "histfig_hf_link_apprenticest.h"
#include "histfig_hf_link_childst.h"
#include "histfig_hf_link_companionst.h"
#include "histfig_hf_link_deityst.h"
#include "histfig_hf_link_fatherst.h"
#include "histfig_hf_link_imprisonerst.h"
#include "histfig_hf_link_loverst.h"
#include "histfig_hf_link_masterst.h"
#include "histfig_hf_link_motherst.h"
#include "histfig_hf_link_prisonerst.h"
#include "histfig_hf_link_spousest.h"
#include "histfig_site_link.h"
#include "histfig_site_link_hangoutst.h"
#include "histfig_site_link_home_site_abstract_buildingst.h"
#include "histfig_site_link_home_site_realization_buildingst.h"
#include "histfig_site_link_home_site_realization_sulst.h"
#include "histfig_site_link_lairst.h"
#include "histfig_site_link_seat_of_powerst.h"
#include "historical_entity.h"
#include "historical_figure.h"
#include "historical_figure_info.h"
#include "historical_kills.h"
#include "history_era.h"
#include "history_event.h"
#include "history_event_add_hf_entity_linkst.h"
#include "history_event_add_hf_hf_linkst.h"
#include "history_event_add_hf_site_linkst.h"
#include "history_event_agreement_concludedst.h"
#include "history_event_agreement_formedst.h"
#include "history_event_agreements_voidedst.h"
#include "history_event_artifact_createdst.h"
#include "history_event_artifact_droppedst.h"
#include "history_event_artifact_foundst.h"
#include "history_event_artifact_hiddenst.h"
#include "history_event_artifact_lostst.h"
#include "history_event_artifact_possessedst.h"
#include "history_event_artifact_recoveredst.h"
#include "history_event_artifact_storedst.h"
#include "history_event_assume_identityst.h"
#include "history_event_body_abusedst.h"
#include "history_event_change_creature_typest.h"
#include "history_event_change_hf_body_statest.h"
#include "history_event_change_hf_jobst.h"
#include "history_event_change_hf_statest.h"
#include "history_event_collection.h"
#include "history_event_collection_abductionst.h"
#include "history_event_collection_battlest.h"
#include "history_event_collection_beast_attackst.h"
#include "history_event_collection_duelst.h"
#include "history_event_collection_insurrectionst.h"
#include "history_event_collection_journeyst.h"
#include "history_event_collection_site_conqueredst.h"
#include "history_event_collection_theftst.h"
#include "history_event_collection_warst.h"
#include "history_event_context.h"
#include "history_event_create_entity_positionst.h"
#include "history_event_created_buildingst.h"
#include "history_event_created_sitest.h"
#include "history_event_created_world_constructionst.h"
#include "history_event_creature_devouredst.h"
#include "history_event_diplomat_lostst.h"
#include "history_event_entity_actionst.h"
#include "history_event_entity_createdst.h"
#include "history_event_entity_incorporatedst.h"
#include "history_event_entity_lawst.h"
#include "history_event_entity_razed_buildingst.h"
#include "history_event_first_contact_failedst.h"
#include "history_event_first_contactst.h"
#include "history_event_hf_act_on_buildingst.h"
#include "history_event_hf_attacked_sitest.h"
#include "history_event_hf_confrontedst.h"
#include "history_event_hf_destroyed_sitest.h"
#include "history_event_hf_does_interactionst.h"
#include "history_event_hf_gains_secret_goalst.h"
#include "history_event_hf_learns_secretst.h"
#include "history_event_hf_razed_buildingst.h"
#include "history_event_hist_figure_abductedst.h"
#include "history_event_hist_figure_diedst.h"
#include "history_event_hist_figure_new_petst.h"
#include "history_event_hist_figure_reach_summitst.h"
#include "history_event_hist_figure_reunionst.h"
#include "history_event_hist_figure_revivedst.h"
#include "history_event_hist_figure_simple_battle_eventst.h"
#include "history_event_hist_figure_travelst.h"
#include "history_event_hist_figure_woundedst.h"
#include "history_event_insurrection_endedst.h"
#include "history_event_insurrection_startedst.h"
#include "history_event_item_stolenst.h"
#include "history_event_masterpiece_created_arch_constructst.h"
#include "history_event_masterpiece_created_arch_designst.h"
#include "history_event_masterpiece_created_dye_itemst.h"
#include "history_event_masterpiece_created_engravingst.h"
#include "history_event_masterpiece_created_foodst.h"
#include "history_event_masterpiece_created_item_improvementst.h"
#include "history_event_masterpiece_created_itemst.h"
#include "history_event_masterpiece_createdst.h"
#include "history_event_masterpiece_lostst.h"
#include "history_event_merchantst.h"
#include "history_event_reclaim_sitest.h"
#include "history_event_remove_hf_entity_linkst.h"
#include "history_event_remove_hf_hf_linkst.h"
#include "history_event_remove_hf_site_linkst.h"
#include "history_event_replaced_buildingst.h"
#include "history_event_site_diedst.h"
#include "history_event_site_disputest.h"
#include "history_event_site_retiredst.h"
#include "history_event_topicagreement_concludedst.h"
#include "history_event_topicagreement_madest.h"
#include "history_event_topicagreement_rejectedst.h"
#include "history_event_war_attacked_sitest.h"
#include "history_event_war_destroyed_sitest.h"
#include "history_event_war_field_battlest.h"
#include "history_event_war_peace_acceptedst.h"
#include "history_event_war_peace_rejectedst.h"
#include "history_event_war_plundered_sitest.h"
#include "history_event_war_site_new_leaderst.h"
#include "history_event_war_site_taken_overst.h"
#include "history_event_war_site_tribute_forcedst.h"
#include "history_hit_item.h"
#include "hospital_supplies.h"
#include "identity.h"
#include "improvement_type.h"
#include "incident.h"
#include "init.h"
#include "init_display.h"
#include "init_display_flags.h"
#include "init_font.h"
#include "init_input.h"
#include "init_input_flags.h"
#include "init_media.h"
#include "init_media_flags.h"
#include "init_window.h"
#include "init_window_flags.h"
#include "inorganic_flags.h"
#include "inorganic_raw.h"
#include "instrument_flags.h"
#include "interaction.h"
#include "interaction_effect.h"
#include "interaction_effect_add_syndromest.h"
#include "interaction_effect_animatest.h"
#include "interaction_effect_cleanst.h"
#include "interaction_effect_contactst.h"
#include "interaction_effect_hidest.h"
#include "interaction_effect_material_emissionst.h"
#include "interaction_effect_resurrectst.h"
#include "interaction_instance.h"
#include "interaction_source.h"
#include "interaction_source_attackst.h"
#include "interaction_source_creature_actionst.h"
#include "interaction_source_deityst.h"
#include "interaction_source_disturbancest.h"
#include "interaction_source_ingestionst.h"
#include "interaction_source_regionst.h"
#include "interaction_source_secretst.h"
#include "interaction_source_underground_specialst.h"
#include "interaction_target.h"
#include "interaction_target_corpsest.h"
#include "interaction_target_creaturest.h"
#include "interaction_target_info.h"
#include "interaction_target_locationst.h"
#include "interaction_target_materialst.h"
#include "interface_button.h"
#include "interface_button_building_category_selectorst.h"
#include "interface_button_building_material_selectorst.h"
#include "interface_button_building_new_jobst.h"
#include "interface_button_buildingst.h"
#include "interface_button_construction_building_selectorst.h"
#include "interface_button_construction_category_selectorst.h"
#include "interface_button_construction_donest.h"
#include "interface_button_constructionst.h"
#include "interfacest.h"
#include "invasion_info.h"
#include "item.h"
#include "item_actual.h"
#include "item_ammost.h"
#include "item_amuletst.h"
#include "item_animaltrapst.h"
#include "item_anvilst.h"
#include "item_armorst.h"
#include "item_armorstandst.h"
#include "item_backpackst.h"
#include "item_ballistaarrowheadst.h"
#include "item_ballistapartsst.h"
#include "item_barrelst.h"
#include "item_barst.h"
#include "item_bedst.h"
#include "item_binst.h"
#include "item_blocksst.h"
#include "item_body_component.h"
#include "item_bookst.h"
#include "item_boulderst.h"
#include "item_boxst.h"
#include "item_braceletst.h"
#include "item_bucketst.h"
#include "item_cabinetst.h"
#include "item_cagest.h"
#include "item_catapultpartsst.h"
#include "item_chainst.h"
#include "item_chairst.h"
#include "item_cheesest.h"
#include "item_clothst.h"
#include "item_coffinst.h"
#include "item_coinst.h"
#include "item_constructed.h"
#include "item_corpsepiecest.h"
#include "item_corpsest.h"
#include "item_crafted.h"
#include "item_critter.h"
#include "item_crownst.h"
#include "item_crutchst.h"
#include "item_doorst.h"
#include "item_drinkst.h"
#include "item_earringst.h"
#include "item_eggst.h"
#include "item_figurinest.h"
#include "item_filter_spec.h"
#include "item_fish_rawst.h"
#include "item_fishst.h"
#include "item_flaskst.h"
#include "item_floodgatest.h"
#include "item_foodst.h"
#include "item_gemst.h"
#include "item_globst.h"
#include "item_glovesst.h"
#include "item_gobletst.h"
#include "item_gratest.h"
#include "item_hatch_coverst.h"
#include "item_helmst.h"
#include "item_history_info.h"
#include "item_instrumentst.h"
#include "item_kill_info.h"
#include "item_liquid.h"
#include "item_liquid_miscst.h"
#include "item_liquipowder.h"
#include "item_magicness.h"
#include "item_meatst.h"
#include "item_millstonest.h"
#include "item_orthopedic_castst.h"
#include "item_pantsst.h"
#include "item_petst.h"
#include "item_pipe_sectionst.h"
#include "item_plant_growthst.h"
#include "item_plantst.h"
#include "item_powder.h"
#include "item_powder_miscst.h"
#include "item_quality.h"
#include "item_quernst.h"
#include "item_quiverst.h"
#include "item_remainsst.h"
#include "item_ringst.h"
#include "item_rockst.h"
#include "item_roughst.h"
#include "item_scepterst.h"
#include "item_seedsst.h"
#include "item_shieldst.h"
#include "item_shoesst.h"
#include "item_siegeammost.h"
#include "item_skin_tannedst.h"
#include "item_slabst.h"
#include "item_smallgemst.h"
#include "item_splintst.h"
#include "item_statuest.h"
#include "item_stockpile_ref.h"
#include "item_tablest.h"
#include "item_threadst.h"
#include "item_toolst.h"
#include "item_totemst.h"
#include "item_toyst.h"
#include "item_traction_benchst.h"
#include "item_trapcompst.h"
#include "item_trappartsst.h"
#include "item_type.h"
#include "item_verminst.h"
#include "item_weaponrackst.h"
#include "item_weaponst.h"
#include "item_windowst.h"
#include "item_woodst.h"
#include "itemdef.h"
#include "itemdef_ammost.h"
#include "itemdef_armorst.h"
#include "itemdef_foodst.h"
#include "itemdef_glovesst.h"
#include "itemdef_helmst.h"
#include "itemdef_instrumentst.h"
#include "itemdef_pantsst.h"
#include "itemdef_shieldst.h"
#include "itemdef_shoesst.h"
#include "itemdef_siegeammost.h"
#include "itemdef_toolst.h"
#include "itemdef_toyst.h"
#include "itemdef_trapcompst.h"
#include "itemdef_weaponst.h"
#include "itemimprovement.h"
#include "itemimprovement_art_imagest.h"
#include "itemimprovement_bandsst.h"
#include "itemimprovement_clothst.h"
#include "itemimprovement_coveredst.h"
#include "itemimprovement_illustrationst.h"
#include "itemimprovement_itemspecificst.h"
#include "itemimprovement_pagesst.h"
#include "itemimprovement_rings_hangingst.h"
#include "itemimprovement_sewn_imagest.h"
#include "itemimprovement_spikesst.h"
#include "itemimprovement_threadst.h"
#include "items_other_id.h"
#include "job.h"
#include "job_item.h"
#include "job_item_filter.h"
#include "job_item_ref.h"
#include "job_item_vector_id.h"
#include "job_list_link.h"
#include "job_skill.h"
#include "job_type.h"
#include "language_name.h"
#include "language_symbol.h"
#include "language_translation.h"
#include "language_word.h"
#include "language_word_table.h"
#include "layer_object.h"
#include "layer_object_buttonst.h"
#include "layer_object_listst.h"
#include "loadgame_save_info.h"
#include "local_population.h"
#include "machine.h"
#include "machine_info.h"
#include "machine_standardst.h"
#include "machine_tile_set.h"
#include "manager_order.h"
#include "manager_order_template.h"
#include "mandate.h"
#include "map_block.h"
#include "map_block_column.h"
#include "map_renderer.h"
#include "map_viewport.h"
#include "material.h"
#include "material_common.h"
#include "material_flags.h"
#include "material_template.h"
#include "material_vec_ref.h"
#include "matgloss_list.h"
#include "matter_state.h"
#include "meeting_context.h"
#include "meeting_diplomat_info.h"
#include "meeting_event.h"
#include "meeting_variable.h"
#include "mental_attribute_type.h"
#include "misc_trait_type.h"
#include "moving_party.h"
#include "nemesis_flags.h"
#include "nemesis_record.h"
#include "ocean_wave.h"
#include "organic_mat_category.h"
#include "pants_flags.h"
#include "part_of_speech.h"
#include "party_info.h"
#include "personality_facet_type.h"
#include "physical_attribute_type.h"
#include "plant.h"
#include "plant_growth.h"
#include "plant_growth_print.h"
#include "plant_raw.h"
#include "plant_raw_flags.h"
#include "plant_tree_info.h"
#include "plant_tree_tile.h"
#include "popup_message.h"
#include "power_info.h"
#include "pressure_plate_info.h"
#include "profession.h"
#include "proj_itemst.h"
#include "proj_list_link.h"
#include "proj_magicst.h"
#include "proj_unitst.h"
#include "projectile.h"
#include "punishment.h"
#include "reaction.h"
#include "reaction_flags.h"
#include "reaction_product.h"
#include "reaction_product_improvement_flags.h"
#include "reaction_product_item_flags.h"
#include "reaction_product_item_improvementst.h"
#include "reaction_product_itemst.h"
#include "reaction_reagent.h"
#include "reaction_reagent_itemst.h"
#include "region_map_entry.h"
#include "region_map_entry_flags.h"
#include "renderer.h"
#include "report.h"
#include "resource_allotment_data.h"
#include "resource_allotment_specifier.h"
#include "resource_allotment_specifier_ammost.h"
#include "resource_allotment_specifier_anvilst.h"
#include "resource_allotment_specifier_armor_bodyst.h"
#include "resource_allotment_specifier_armor_bootsst.h"
#include "resource_allotment_specifier_armor_glovesst.h"
#include "resource_allotment_specifier_armor_helmst.h"
#include "resource_allotment_specifier_armor_pantsst.h"
#include "resource_allotment_specifier_backpackst.h"
#include "resource_allotment_specifier_bagst.h"
#include "resource_allotment_specifier_bedst.h"
#include "resource_allotment_specifier_bonest.h"
#include "resource_allotment_specifier_boxst.h"
#include "resource_allotment_specifier_cabinetst.h"
#include "resource_allotment_specifier_chairst.h"
#include "resource_allotment_specifier_cheesest.h"
#include "resource_allotment_specifier_clothing_bodyst.h"
#include "resource_allotment_specifier_clothing_bootsst.h"
#include "resource_allotment_specifier_clothing_glovesst.h"
#include "resource_allotment_specifier_clothing_helmst.h"
#include "resource_allotment_specifier_clothing_pantsst.h"
#include "resource_allotment_specifier_clothst.h"
#include "resource_allotment_specifier_craftsst.h"
#include "resource_allotment_specifier_cropst.h"
#include "resource_allotment_specifier_extractst.h"
#include "resource_allotment_specifier_flaskst.h"
#include "resource_allotment_specifier_gemsst.h"
#include "resource_allotment_specifier_hornst.h"
#include "resource_allotment_specifier_leatherst.h"
#include "resource_allotment_specifier_meatst.h"
#include "resource_allotment_specifier_metalst.h"
#include "resource_allotment_specifier_pearlst.h"
#include "resource_allotment_specifier_powderst.h"
#include "resource_allotment_specifier_quiverst.h"
#include "resource_allotment_specifier_shellst.h"
#include "resource_allotment_specifier_skinst.h"
#include "resource_allotment_specifier_soapst.h"
#include "resource_allotment_specifier_stonest.h"
#include "resource_allotment_specifier_tablest.h"
#include "resource_allotment_specifier_tallowst.h"
#include "resource_allotment_specifier_threadst.h"
#include "resource_allotment_specifier_toothst.h"
#include "resource_allotment_specifier_weapon_meleest.h"
#include "resource_allotment_specifier_weapon_rangedst.h"
#include "resource_allotment_specifier_woodst.h"
#include "room_rent_info.h"
#include "route_stockpile_link.h"
#include "schedule_info.h"
#include "schedule_slot.h"
#include "script_step_conditionalst.h"
#include "script_step_constructtopiclistst.h"
#include "script_step_dipeventst.h"
#include "script_step_diphistoryst.h"
#include "script_step_discussst.h"
#include "script_step_eventst.h"
#include "script_step_invasionst.h"
#include "script_step_setvarst.h"
#include "script_step_simpleactionst.h"
#include "script_step_textviewerst.h"
#include "script_step_topicdiscussionst.h"
#include "script_stepst.h"
#include "script_var_longst.h"
#include "script_var_unitst.h"
#include "script_varst.h"
#include "shoes_flags.h"
#include "site_building_item.h"
#include "site_realization_building.h"
#include "site_realization_building_info_castle_courtyardst.h"
#include "site_realization_building_info_castle_towerst.h"
#include "site_realization_building_info_castle_wallst.h"
#include "site_realization_building_info_hillock_housest.h"
#include "site_realization_building_info_market_squarest.h"
#include "site_realization_building_info_shop_housest.h"
#include "site_realization_building_info_tree_housest.h"
#include "site_realization_building_info_trenchesst.h"
#include "site_realization_building_infost.h"
#include "site_realization_crossroads.h"
#include "site_type.h"
#include "skill_rating.h"
#include "spatter.h"
#include "spatter_common.h"
#include "special_mat_table.h"
#include "specific_ref.h"
#include "sphere_type.h"
#include "squad.h"
#include "squad_ammo_spec.h"
#include "squad_event_type.h"
#include "squad_order.h"
#include "squad_order_cause_trouble_for_entityst.h"
#include "squad_order_defend_burrowsst.h"
#include "squad_order_drive_entity_off_sitest.h"
#include "squad_order_kill_listst.h"
#include "squad_order_movest.h"
#include "squad_order_patrol_routest.h"
#include "squad_order_trainst.h"
#include "squad_position.h"
#include "squad_schedule_entry.h"
#include "squad_schedule_order.h"
#include "squad_uniform_spec.h"
#include "stockpile_links.h"
#include "stockpile_list.h"
#include "stockpile_settings.h"
#include "stop_depart_condition.h"
#include "strain_type.h"
#include "syndrome.h"
#include "talk_choice.h"
#include "temperaturest.h"
#include "texture_handler.h"
#include "tile_bitmask.h"
#include "tile_page.h"
#include "tiletype.h"
#include "tiletype_material.h"
#include "tiletype_shape.h"
#include "tiletype_special.h"
#include "timed_event.h"
#include "tissue.h"
#include "tissue_flags.h"
#include "tissue_style_raw.h"
#include "tissue_template.h"
#include "tool_flags.h"
#include "tool_uses.h"
#include "toy_flags.h"
#include "training_assignment.h"
#include "trapcomp_flags.h"
#include "ui.h"
#include "ui_advmode.h"
#include "ui_build_item_req.h"
#include "ui_build_selector.h"
#include "ui_hotkey.h"
#include "ui_look_list.h"
#include "ui_sidebar_menus.h"
#include "ui_unit_view_mode.h"
#include "uniform_category.h"
#include "unit.h"
#include "unit_action.h"
#include "unit_attribute.h"
#include "unit_chunk.h"
#include "unit_coin_debt.h"
#include "unit_complaint.h"
#include "unit_demand.h"
#include "unit_genes.h"
#include "unit_ghost_info.h"
#include "unit_health_info.h"
#include "unit_inventory_item.h"
#include "unit_item_use.h"
#include "unit_item_wrestle.h"
#include "unit_labor.h"
#include "unit_misc_trait.h"
#include "unit_personality.h"
#include "unit_preference.h"
#include "unit_report_type.h"
#include "unit_request.h"
#include "unit_skill.h"
#include "unit_soul.h"
#include "unit_syndrome.h"
#include "unit_thought_type.h"
#include "unit_wound.h"
#include "units_other_id.h"
#include "value_type.h"
#include "vehicle.h"
#include "vermin.h"
#include "viewscreen.h"
#include "viewscreen_adventure_logst.h"
#include "viewscreen_announcelistst.h"
#include "viewscreen_barterst.h"
#include "viewscreen_buildinglistst.h"
#include "viewscreen_buildingst.h"
#include "viewscreen_choose_start_sitest.h"
#include "viewscreen_civlistst.h"
#include "viewscreen_conversationst.h"
#include "viewscreen_createquotast.h"
#include "viewscreen_customize_unitst.h"
#include "viewscreen_dungeon_monsterstatusst.h"
#include "viewscreen_dungeon_wrestlest.h"
#include "viewscreen_dungeonmodest.h"
#include "viewscreen_dwarfmodest.h"
#include "viewscreen_entityst.h"
#include "viewscreen_export_graphical_mapst.h"
#include "viewscreen_export_regionst.h"
#include "viewscreen_game_cleanerst.h"
#include "viewscreen_itemst.h"
#include "viewscreen_joblistst.h"
#include "viewscreen_jobmanagementst.h"
#include "viewscreen_jobst.h"
#include "viewscreen_justicest.h"
#include "viewscreen_kitchenprefst.h"
#include "viewscreen_layer.h"
#include "viewscreen_layer_arena_creaturest.h"
#include "viewscreen_layer_assigntradest.h"
#include "viewscreen_layer_choose_language_namest.h"
#include "viewscreen_layer_currencyst.h"
#include "viewscreen_layer_export_play_mapst.h"
#include "viewscreen_layer_militaryst.h"
#include "viewscreen_layer_musicsoundst.h"
#include "viewscreen_layer_noblelistst.h"
#include "viewscreen_layer_overall_healthst.h"
#include "viewscreen_layer_reactionst.h"
#include "viewscreen_layer_squad_schedulest.h"
#include "viewscreen_layer_stockpilest.h"
#include "viewscreen_layer_stone_restrictionst.h"
#include "viewscreen_layer_unit_actionst.h"
#include "viewscreen_layer_unit_healthst.h"
#include "viewscreen_layer_unit_relationshipst.h"
#include "viewscreen_layer_workshop_profilest.h"
#include "viewscreen_layer_world_gen_param_presetst.h"
#include "viewscreen_layer_world_gen_paramst.h"
#include "viewscreen_legendsst.h"
#include "viewscreen_loadgamest.h"
#include "viewscreen_meetingst.h"
#include "viewscreen_movieplayerst.h"
#include "viewscreen_new_regionst.h"
#include "viewscreen_noblest.h"
#include "viewscreen_optionst.h"
#include "viewscreen_overallstatusst.h"
#include "viewscreen_petst.h"
#include "viewscreen_pricest.h"
#include "viewscreen_reportlistst.h"
#include "viewscreen_requestagreementst.h"
#include "viewscreen_savegamest.h"
#include "viewscreen_selectitemst.h"
#include "viewscreen_setupadventurest.h"
#include "viewscreen_setupdwarfgamest.h"
#include "viewscreen_storesst.h"
#include "viewscreen_textviewerst.h"
#include "viewscreen_titlest.h"
#include "viewscreen_topicmeeting_fill_land_holder_positionst.h"
#include "viewscreen_topicmeeting_takerequestsst.h"
#include "viewscreen_topicmeetingst.h"
#include "viewscreen_tradeagreementst.h"
#include "viewscreen_tradegoodsst.h"
#include "viewscreen_tradelistst.h"
#include "viewscreen_treasurelistst.h"
#include "viewscreen_unitlist_page.h"
#include "viewscreen_unitlistst.h"
#include "viewscreen_unitst.h"
#include "viewscreen_update_regionst.h"
#include "viewscreen_wagesst.h"
#include "weapon_attack.h"
#include "weapon_flags.h"
#include "web_cluster.h"
#include "workshop_profile.h"
#include "world.h"
#include "world_construction.h"
#include "world_construction_bridgest.h"
#include "world_construction_roadst.h"
#include "world_construction_square.h"
#include "world_construction_square_bridgest.h"
#include "world_construction_square_roadst.h"
#include "world_construction_square_tunnelst.h"
#include "world_construction_square_wallst.h"
#include "world_construction_tunnelst.h"
#include "world_construction_type.h"
#include "world_construction_wallst.h"
#include "world_data.h"
#include "world_geo_biome.h"
#include "world_geo_layer.h"
#include "world_history.h"
#include "world_landmass.h"
#include "world_object_data.h"
#include "world_population.h"
#include "world_population_ref.h"
#include "world_raws.h"
#include "world_region.h"
#include "world_region_details.h"
#include "world_region_feature.h"
#include "world_river.h"
#include "world_site.h"
#include "world_site_flags.h"
#include "world_site_inhabitant.h"
#include "world_site_realization.h"
#include "world_site_unk130.h"
#include "world_underground_region.h"
#include "world_unk_20.h"
#include "world_unk_6c.h"
#include "world_unk_90.h"
#include "world_unk_9c.h"
#include "world_unk_a8.h"
#include "world_unk_b4.h"
#include "world_unk_c0.h"
#include "worldgen_region_type.h"
#include "wound_curse_info.h"
#include "written_content.h"
#include "z_level_flags.h"
namespace df {
  #define CUR_STRUCT abstract_building::T_inhabitants
  static const struct_field_info abstract_building_doT_Dot_T_inhabitants_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity abstract_building::T_inhabitants::_identity(sizeof(abstract_building::T_inhabitants), &allocator_fn<abstract_building::T_inhabitants>, &abstract_building::_identity, "T_inhabitants",NULL,abstract_building_doT_Dot_T_inhabitants_fields);
  #define CUR_STRUCT abstract_building::T_unk1
  static const struct_field_info abstract_building_doT_Dot_T_unk1_fields[] = {
    { FLD(CONTAINER, hfig), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity abstract_building::T_unk1::_identity(sizeof(abstract_building::T_unk1), &allocator_fn<abstract_building::T_unk1>, &abstract_building::_identity, "T_unk1",NULL,abstract_building_doT_Dot_T_unk1_fields);
  #define CUR_STRUCT abstract_building
  static const struct_field_info abstract_building_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, inhabitants), &abstract_building::T_inhabitants::_identity, 0, NULL },
    { FLD(CONTAINER, flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(POINTER, unk1), &abstract_building::T_unk1::_identity, 0, NULL },
    { FLD(CONTAINER, unk2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk3), TID(int32_t) },
    { FLD(CONTAINER, unk4), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, site_owner_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, getSubtype) },
    { METHOD(OBJ_METHOD, getDisplayTile) },
    { METHOD(OBJ_METHOD, getName) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity abstract_building::_identity(sizeof(abstract_building), &allocator_fn<abstract_building>, "abstract_building","abstract_buildingst",NULL,abstract_building_fields);
  #define CUR_STRUCT abstract_building_dark_towerst
  static const struct_field_info abstract_building_dark_towerst_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity abstract_building_dark_towerst::_identity(sizeof(abstract_building_dark_towerst), &allocator_fn<abstract_building_dark_towerst>, "abstract_building_dark_towerst",NULL,&abstract_building::_identity,abstract_building_dark_towerst_fields);
  #define CUR_STRUCT abstract_building_dungeonst
  static const struct_field_info abstract_building_dungeonst_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, dungeon_type), TID(abstract_building_dungeonst::T_dungeon_type) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(SUBSTRUCT, unk), &abstract_building_unk::_identity },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity abstract_building_dungeonst::_identity(sizeof(abstract_building_dungeonst), &allocator_fn<abstract_building_dungeonst>, "abstract_building_dungeonst",NULL,&abstract_building::_identity,abstract_building_dungeonst_fields);
  #define CUR_STRUCT abstract_building_keepst
  static const struct_field_info abstract_building_keepst_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity abstract_building_keepst::_identity(sizeof(abstract_building_keepst), &allocator_fn<abstract_building_keepst>, "abstract_building_keepst",NULL,&abstract_building::_identity,abstract_building_keepst_fields);
  #define CUR_STRUCT abstract_building_marketst
  static const struct_field_info abstract_building_marketst_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity abstract_building_marketst::_identity(sizeof(abstract_building_marketst), &allocator_fn<abstract_building_marketst>, "abstract_building_marketst",NULL,&abstract_building::_identity,abstract_building_marketst_fields);
  #define CUR_STRUCT abstract_building_mead_hallst
  static const struct_field_info abstract_building_mead_hallst_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(SUBSTRUCT, item1), &site_building_item::_identity },
    { FLD(SUBSTRUCT, item2), &site_building_item::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity abstract_building_mead_hallst::_identity(sizeof(abstract_building_mead_hallst), &allocator_fn<abstract_building_mead_hallst>, "abstract_building_mead_hallst",NULL,&abstract_building::_identity,abstract_building_mead_hallst_fields);
  #define CUR_STRUCT abstract_building_templest
  static const struct_field_info abstract_building_templest_fields[] = {
    { FLD(PRIMITIVE, deity), TID(int32_t) },
    { FLD(PRIMITIVE, religion), TID(int32_t) },
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity abstract_building_templest::_identity(sizeof(abstract_building_templest), &allocator_fn<abstract_building_templest>, "abstract_building_templest",NULL,&abstract_building::_identity,abstract_building_templest_fields);
  #define CUR_STRUCT abstract_building_tombst
  static const struct_field_info abstract_building_tombst_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(SUBSTRUCT, unk), &abstract_building_unk::_identity },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity abstract_building_tombst::_identity(sizeof(abstract_building_tombst), &allocator_fn<abstract_building_tombst>, "abstract_building_tombst",NULL,&abstract_building::_identity,abstract_building_tombst_fields);
  #define CUR_STRUCT abstract_building_underworld_spirest
  static const struct_field_info abstract_building_underworld_spirest_fields[] = {
    { FLD(PRIMITIVE, unk_50), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_6c), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_88), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_90), TID(int32_t) },
    { FLD(PRIMITIVE, unk_94), TID(int32_t) },
    { FLD(PRIMITIVE, unk_98), TID(int32_t) },
    { FLD(PRIMITIVE, unk_9c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_a0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_a4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_a8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_ac), TID(int32_t) },
    { FLD(PRIMITIVE, unk_b0), TID(int16_t) },
    { FLD(PRIMITIVE, unk_b4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_b8), TID(int16_t) },
    { FLD(PRIMITIVE, unk_ba), TID(int8_t) },
    { FLD(PRIMITIVE, unk_bc), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity abstract_building_underworld_spirest::_identity(sizeof(abstract_building_underworld_spirest), &allocator_fn<abstract_building_underworld_spirest>, "abstract_building_underworld_spirest",NULL,&abstract_building::_identity,abstract_building_underworld_spirest_fields);
  #define CUR_STRUCT abstract_building_unk::T_anon_1
  static const struct_field_info abstract_building_unk_doT_Dot_T_anon_1_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, race), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity abstract_building_unk::T_anon_1::_identity(sizeof(abstract_building_unk::T_anon_1), &allocator_fn<abstract_building_unk::T_anon_1>, &abstract_building_unk::_identity, "T_anon_1",NULL,abstract_building_unk_doT_Dot_T_anon_1_fields);
  #define CUR_STRUCT abstract_building_unk
  static const struct_field_info abstract_building_unk_fields[] = {
    { FLD(STL_VECTOR_PTR, anon_1), &abstract_building_unk::T_anon_1::_identity, 0, NULL },
    { FLD(CONTAINER, histfigs), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity abstract_building_unk::_identity(sizeof(abstract_building_unk), &allocator_fn<abstract_building_unk>, NULL, "abstract_building_unk",NULL,abstract_building_unk_fields);
  #define CUR_STRUCT active_script_var_longst
  static const struct_field_info active_script_var_longst_fields[] = {
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity active_script_var_longst::_identity(sizeof(active_script_var_longst), &allocator_fn<active_script_var_longst>, "active_script_var_longst",NULL,&active_script_varst::_identity,active_script_var_longst_fields);
  #define CUR_STRUCT active_script_var_unitst
  static const struct_field_info active_script_var_unitst_fields[] = {
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity active_script_var_unitst::_identity(sizeof(active_script_var_unitst), &allocator_fn<active_script_var_unitst>, "active_script_var_unitst",NULL,&active_script_varst::_identity,active_script_var_unitst_fields);
  #define CUR_STRUCT active_script_varst
  static const struct_field_info active_script_varst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { METHOD(OBJ_METHOD, setColor) },
    { METHOD(OBJ_METHOD, formatString) },
    { METHOD(OBJ_METHOD, getValue) },
    { METHOD(OBJ_METHOD, setValue) },
    { METHOD(OBJ_METHOD, removeUnit) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity active_script_varst::_identity(sizeof(active_script_varst), &allocator_fn<active_script_varst>, "active_script_varst",NULL,NULL,active_script_varst_fields);
  #define CUR_STRUCT activity_entry
  static const struct_field_info activity_entry_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, type), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, events), identity_traits<df::activity_event >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_event_id), TID(int32_t) },
    { FLD(PRIMITIVE, army_controller), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity activity_entry::_identity(sizeof(activity_entry), &allocator_fn<activity_entry>, NULL, "activity_entry",NULL,activity_entry_fields);
  #define CUR_STRUCT activity_event
  static const struct_field_info activity_event_fields[] = {
    { FLD(PRIMITIVE, event_id), TID(int32_t) },
    { FLD(PRIMITIVE, activity_id), TID(int32_t) },
    { FLD(PRIMITIVE, parent_event_id), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(activity_event::T_flags) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, isEmpty) },
    { METHOD(OBJ_METHOD, getParticipantInfo) },
    { METHOD(OBJ_METHOD, dismiss) },
    { METHOD(OBJ_METHOD, removeParticipant) },
    { METHOD(OBJ_METHOD, process) },
    { METHOD(OBJ_METHOD, checkDrillInvalid) },
    { METHOD(OBJ_METHOD, decUniformLock) },
    { METHOD(OBJ_METHOD, getSquadEventType) },
    { METHOD(OBJ_METHOD, setDemoSkill) },
    { METHOD(OBJ_METHOD, setSkillDemoTimers) },
    { METHOD(OBJ_METHOD, adjustOrganizeCounter) },
    { METHOD(OBJ_METHOD, getOrganizer) },
    { METHOD(OBJ_METHOD, getBuilding) },
    { METHOD(OBJ_METHOD, isSparring) },
    { METHOD(OBJ_METHOD, getUniformType) },
    { METHOD(OBJ_METHOD, getName) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity activity_event::_identity(sizeof(activity_event), &allocator_fn<activity_event>, "activity_event","activity_eventst",NULL,activity_event_fields);
  #define CUR_STRUCT activity_event_combat_trainingst
  static const struct_field_info activity_event_combat_trainingst_fields[] = {
    { FLD(SUBSTRUCT, participants), &activity_event_participants::_identity },
    { FLD(PRIMITIVE, building_id), TID(int32_t) },
    { FLD(PRIMITIVE, hist_figure_id), TID(int32_t) },
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, organize_counter), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity activity_event_combat_trainingst::_identity(sizeof(activity_event_combat_trainingst), &allocator_fn<activity_event_combat_trainingst>, "activity_event_combat_trainingst",NULL,&activity_event::_identity,activity_event_combat_trainingst_fields);
  #define CUR_STRUCT activity_event_conflictst::T_anon_1::T_anon_3
  static const struct_field_info activity_event_conflictst_doT_Dot_T_anon_1_doT_Dot_T_anon_3_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity activity_event_conflictst::T_anon_1::T_anon_3::_identity(sizeof(activity_event_conflictst::T_anon_1::T_anon_3), &allocator_fn<activity_event_conflictst::T_anon_1::T_anon_3>, &activity_event_conflictst::T_anon_1::_identity, "T_anon_3",NULL,activity_event_conflictst_doT_Dot_T_anon_1_doT_Dot_T_anon_3_fields);
  #define CUR_STRUCT activity_event_conflictst::T_anon_1
  static const struct_field_info activity_event_conflictst_doT_Dot_T_anon_1_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_3), &activity_event_conflictst::T_anon_1::T_anon_3::_identity, 0, NULL },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity activity_event_conflictst::T_anon_1::_identity(sizeof(activity_event_conflictst::T_anon_1), &allocator_fn<activity_event_conflictst::T_anon_1>, &activity_event_conflictst::_identity, "T_anon_1",NULL,activity_event_conflictst_doT_Dot_T_anon_1_fields);
  #define CUR_STRUCT activity_event_conflictst
  static const struct_field_info activity_event_conflictst_fields[] = {
    { FLD(STL_VECTOR_PTR, anon_1), &activity_event_conflictst::T_anon_1::_identity, 0, NULL },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity activity_event_conflictst::_identity(sizeof(activity_event_conflictst), &allocator_fn<activity_event_conflictst>, "activity_event_conflictst",NULL,&activity_event::_identity,activity_event_conflictst_fields);
  #define CUR_STRUCT activity_event_conversationst::T_anon_1
  static const struct_field_info activity_event_conversationst_doT_Dot_T_anon_1_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity activity_event_conversationst::T_anon_1::_identity(sizeof(activity_event_conversationst::T_anon_1), &allocator_fn<activity_event_conversationst::T_anon_1>, &activity_event_conversationst::_identity, "T_anon_1",NULL,activity_event_conversationst_doT_Dot_T_anon_1_fields);
  #define CUR_STRUCT activity_event_conversationst::T_anon_9
  static const struct_field_info activity_event_conversationst_doT_Dot_T_anon_9_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(SUBSTRUCT, anon_4), &entity_event::_identity },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int16_t) },
    { FLD(PRIMITIVE, anon_7), TID(int16_t) },
    { FLD(PRIMITIVE, anon_8), TID(int16_t) },
    { FLD(PRIMITIVE, anon_9), TID(int32_t) },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { FLD(PRIMITIVE, anon_11), TID(int32_t) },
    { FLD(PRIMITIVE, anon_12), TID(int32_t) },
    { FLD(PRIMITIVE, anon_13), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v4014_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity activity_event_conversationst::T_anon_9::_identity(sizeof(activity_event_conversationst::T_anon_9), &allocator_fn<activity_event_conversationst::T_anon_9>, &activity_event_conversationst::_identity, "T_anon_9",NULL,activity_event_conversationst_doT_Dot_T_anon_9_fields);
  #define CUR_STRUCT activity_event_conversationst::T_unk2
  static const struct_field_info activity_event_conversationst_doT_Dot_T_unk2_fields[] = {
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_6), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_8), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_9), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_10), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_11), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_12), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_13), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_14), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_15), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_16), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_17), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_18), TID(int32_t) },
    { FLD(PRIMITIVE, anon_19), TID(int32_t) },
    { FLD(PRIMITIVE, anon_20), TID(int32_t) },
    { FLD(PRIMITIVE, anon_21), TID(int32_t) },
    { FLD(PRIMITIVE, anon_22), TID(int32_t) },
    { FLD(PRIMITIVE, anon_23), TID(int32_t) },
    { FLD(PRIMITIVE, anon_24), TID(int32_t) },
    { FLD(PRIMITIVE, anon_25), TID(int32_t) },
    { FLD(PRIMITIVE, anon_26), TID(int32_t) },
    { FLD(PRIMITIVE, anon_27), TID(int32_t) },
    { FLD(PRIMITIVE, anon_28), TID(int32_t) },
    { FLD(PRIMITIVE, anon_29), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity activity_event_conversationst::T_unk2::_identity(sizeof(activity_event_conversationst::T_unk2), &allocator_fn<activity_event_conversationst::T_unk2>, &activity_event_conversationst::_identity, "T_unk2",NULL,activity_event_conversationst_doT_Dot_T_unk2_fields);
  #define CUR_STRUCT activity_event_conversationst
  static const struct_field_info activity_event_conversationst_fields[] = {
    { FLD(STL_VECTOR_PTR, anon_1), &activity_event_conversationst::T_anon_1::_identity, 0, NULL },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(SUBSTRUCT, unk1), &entity_event::_identity },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_8), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_9), &activity_event_conversationst::T_anon_9::_identity, 0, NULL },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { FLD(PRIMITIVE, anon_11), TID(int32_t) },
    { FLD(PRIMITIVE, anon_12), TID(int32_t) },
    { FLD(PRIMITIVE, anon_13), TID(int32_t) },
    { FLD(SUBSTRUCT, unk2), &activity_event_conversationst::T_unk2::_identity },
    { FLD(STL_VECTOR_PTR, anon_14), identity_traits<df::talk_choice >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_15), TID(int32_t) },
    { FLD(PRIMITIVE, anon_16), TID(int32_t) },
    { FLD(PRIMITIVE, anon_17), TID(int32_t) },
    { FLD(PRIMITIVE, anon_18), TID(int32_t) },
    { FLD(PRIMITIVE, anon_19), TID(int32_t) },
    { FLD(PRIMITIVE, anon_20), TID(int32_t) },
    { FLD(PRIMITIVE, anon_21), TID(int32_t) },
    { FLD(PRIMITIVE, anon_22), TID(int32_t) },
    { FLD(PRIMITIVE, anon_23), TID(int32_t) },
    { FLD(PRIMITIVE, anon_24), TID(int32_t) },
    { FLD(PRIMITIVE, anon_25), TID(int32_t) },
    { FLD(PRIMITIVE, anon_26), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity activity_event_conversationst::_identity(sizeof(activity_event_conversationst), &allocator_fn<activity_event_conversationst>, "activity_event_conversationst",NULL,&activity_event::_identity,activity_event_conversationst_fields);
  #define CUR_STRUCT activity_event_guardst
  static const struct_field_info activity_event_guardst_fields[] = {
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_2), TID(int16_t) },
    { FLD(PRIMITIVE, anon_3), TID(int16_t) },
    { FLD(PRIMITIVE, anon_4), TID(int16_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity activity_event_guardst::_identity(sizeof(activity_event_guardst), &allocator_fn<activity_event_guardst>, "activity_event_guardst",NULL,&activity_event::_identity,activity_event_guardst_fields);
  #define CUR_STRUCT activity_event_harassmentst::T_anon_2
  static const struct_field_info activity_event_harassmentst_doT_Dot_T_anon_2_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(STATIC_ARRAY, anon_2), identity_traits<int32_t >::get(), 3, NULL },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD(PRIMITIVE, anon_9), TID(int32_t) },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { FLD(CONTAINER, anon_11), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_12), TID(int32_t) },
    { FLD(PRIMITIVE, anon_13), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity activity_event_harassmentst::T_anon_2::_identity(sizeof(activity_event_harassmentst::T_anon_2), &allocator_fn<activity_event_harassmentst::T_anon_2>, &activity_event_harassmentst::_identity, "T_anon_2",NULL,activity_event_harassmentst_doT_Dot_T_anon_2_fields);
  #define CUR_STRUCT activity_event_harassmentst
  static const struct_field_info activity_event_harassmentst_fields[] = {
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_2), &activity_event_harassmentst::T_anon_2::_identity, 0, NULL },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity activity_event_harassmentst::_identity(sizeof(activity_event_harassmentst), &allocator_fn<activity_event_harassmentst>, "activity_event_harassmentst",NULL,&activity_event::_identity,activity_event_harassmentst_fields);
  #define CUR_STRUCT activity_event_individual_skill_drillst
  static const struct_field_info activity_event_individual_skill_drillst_fields[] = {
    { FLD(SUBSTRUCT, participants), &activity_event_participants::_identity },
    { FLD(PRIMITIVE, building_id), TID(int32_t) },
    { FLD(PRIMITIVE, countdown), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity activity_event_individual_skill_drillst::_identity(sizeof(activity_event_individual_skill_drillst), &allocator_fn<activity_event_individual_skill_drillst>, "activity_event_individual_skill_drillst",NULL,&activity_event::_identity,activity_event_individual_skill_drillst_fields);
  #define CUR_STRUCT activity_event_participants
  static const struct_field_info activity_event_participants_fields[] = {
    { FLD(CONTAINER, histfigs), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, units), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, free_histfigs), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, free_units), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, activity_id), TID(int32_t) },
    { FLD(PRIMITIVE, event_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity activity_event_participants::_identity(sizeof(activity_event_participants), &allocator_fn<activity_event_participants>, NULL, "activity_event_participants",NULL,activity_event_participants_fields);
  #define CUR_STRUCT activity_event_ranged_practicest
  static const struct_field_info activity_event_ranged_practicest_fields[] = {
    { FLD(SUBSTRUCT, participants), &activity_event_participants::_identity },
    { FLD(PRIMITIVE, building_id), TID(int32_t) },
    { FLD(PRIMITIVE, uniform_lock), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity activity_event_ranged_practicest::_identity(sizeof(activity_event_ranged_practicest), &allocator_fn<activity_event_ranged_practicest>, "activity_event_ranged_practicest",NULL,&activity_event::_identity,activity_event_ranged_practicest_fields);
  #define CUR_STRUCT activity_event_reunionst
  static const struct_field_info activity_event_reunionst_fields[] = {
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity activity_event_reunionst::_identity(sizeof(activity_event_reunionst), &allocator_fn<activity_event_reunionst>, "activity_event_reunionst",NULL,&activity_event::_identity,activity_event_reunionst_fields);
  #define CUR_STRUCT activity_event_skill_demonstrationst
  static const struct_field_info activity_event_skill_demonstrationst_fields[] = {
    { FLD(SUBSTRUCT, participants), &activity_event_participants::_identity },
    { FLD(PRIMITIVE, building_id), TID(int32_t) },
    { FLD(PRIMITIVE, hist_figure_id), TID(int32_t) },
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, skill), TID(job_skill) },
    { FLD(PRIMITIVE, organize_counter), TID(int32_t) },
    { FLD(PRIMITIVE, wait_countdown), TID(int32_t) },
    { FLD(PRIMITIVE, train_rounds), TID(int32_t) },
    { FLD(PRIMITIVE, train_countdown), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity activity_event_skill_demonstrationst::_identity(sizeof(activity_event_skill_demonstrationst), &allocator_fn<activity_event_skill_demonstrationst>, "activity_event_skill_demonstrationst",NULL,&activity_event::_identity,activity_event_skill_demonstrationst_fields);
  #define CUR_STRUCT activity_event_sparringst::T_groups
  static const struct_field_info activity_event_sparringst_doT_Dot_T_groups_fields[] = {
    { FLD(CONTAINER, units), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, countdown), TID(int32_t) },
    { FLD(PRIMITIVE, building_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity activity_event_sparringst::T_groups::_identity(sizeof(activity_event_sparringst::T_groups), &allocator_fn<activity_event_sparringst::T_groups>, &activity_event_sparringst::_identity, "T_groups",NULL,activity_event_sparringst_doT_Dot_T_groups_fields);
  #define CUR_STRUCT activity_event_sparringst
  static const struct_field_info activity_event_sparringst_fields[] = {
    { FLD(SUBSTRUCT, participants), &activity_event_participants::_identity },
    { FLD(PRIMITIVE, building_id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, groups), &activity_event_sparringst::T_groups::_identity, 0, NULL },
    { FLD(PRIMITIVE, countdown), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity activity_event_sparringst::_identity(sizeof(activity_event_sparringst), &allocator_fn<activity_event_sparringst>, "activity_event_sparringst",NULL,&activity_event::_identity,activity_event_sparringst_fields);
  #define CUR_STRUCT activity_event_training_sessionst
  static const struct_field_info activity_event_training_sessionst_fields[] = {
    { FLD(SUBSTRUCT, participants), &activity_event_participants::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity activity_event_training_sessionst::_identity(sizeof(activity_event_training_sessionst), &allocator_fn<activity_event_training_sessionst>, "activity_event_training_sessionst",NULL,&activity_event::_identity,activity_event_training_sessionst_fields);
  #define CUR_STRUCT activity_info
  static const struct_field_info activity_info_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(POINTER, unit_actor), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, unit_noble), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, place), identity_traits<df::building >::get(), 0, NULL },
    { FLD(SUBSTRUCT, flags), TID(activity_info::T_flags) },
    { FLD(PRIMITIVE, unk3), TID(int8_t) },
    { FLD(PRIMITIVE, delay), TID(int16_t) },
    { FLD(PRIMITIVE, tree_quota), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity activity_info::_identity(sizeof(activity_info), &allocator_fn<activity_info>, NULL, "activity_info",NULL,activity_info_fields);
  #define CUR_STRUCT adventure_log_item
  static const struct_field_info adventure_log_item_fields[] = {
    { FLD(POINTER, object), NULL, 0, NULL },
    { FLD(PRIMITIVE, str1), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, str2), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, str3), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, info), identity_traits<std::string >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity adventure_log_item::_identity(sizeof(adventure_log_item), &allocator_fn<adventure_log_item>, NULL, "adventure_log_item",NULL,adventure_log_item_fields);
  virtual_identity adventure_movement_option::_identity(sizeof(adventure_movement_option), &allocator_nodel_fn<adventure_movement_option>, "adventure_movement_option","adventure_movement_optionst",NULL,NULL);
  #define CUR_STRUCT announcements
  static const struct_field_info announcements_fields[] = {
    { FLD(STATIC_ARRAY, flags), identity_traits<df::announcement_flags >::get(), 299, TID(announcement_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity announcements::_identity(sizeof(announcements), &allocator_fn<announcements>, NULL, "announcements",NULL,announcements_fields);
  #define CUR_STRUCT armor_properties
  static const struct_field_info armor_properties_fields[] = {
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::armor_general_flags> >::get(), 0, TID(armor_general_flags) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(PRIMITIVE, layer_size), TID(int16_t) },
    { FLD(PRIMITIVE, layer_permit), TID(int16_t) },
    { FLD(PRIMITIVE, coverage), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity armor_properties::_identity(sizeof(armor_properties), &allocator_fn<armor_properties>, NULL, "armor_properties",NULL,armor_properties_fields);
  #define CUR_STRUCT army::T_unk_1c
  static const struct_field_info army_doT_Dot_T_unk_1c_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_20), TID(int32_t) },
    { FLD(PRIMITIVE, unk_24), TID(int32_t) },
    { FLD(PRIMITIVE, unk_28), TID(int32_t) },
    { FLD(PRIMITIVE, unk_2c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_30), TID(int32_t) },
    { FLD(PRIMITIVE, unk_34), TID(int32_t) },
    { FLD(CONTAINER, unk_38), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity army::T_unk_1c::_identity(sizeof(army::T_unk_1c), &allocator_fn<army::T_unk_1c>, &army::_identity, "T_unk_1c",NULL,army_doT_Dot_T_unk_1c_fields);
  #define CUR_STRUCT army::T_unk_2c
  static const struct_field_info army_doT_Dot_T_unk_2c_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_20), TID(int32_t) },
    { FLD(PRIMITIVE, unk_24), TID(int32_t) },
    { FLD(PRIMITIVE, unk_28), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity army::T_unk_2c::_identity(sizeof(army::T_unk_2c), &allocator_fn<army::T_unk_2c>, &army::_identity, "T_unk_2c",NULL,army_doT_Dot_T_unk_2c_fields);
  #define CUR_STRUCT army
  static const struct_field_info army_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(SUBSTRUCT, unk_pos1), &coord::_identity },
    { FLD(SUBSTRUCT, unk_pos2), &coord::_identity },
    { FLD(PRIMITIVE, unk_10), TID(int16_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_1c), &army::T_unk_1c::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_2c), &army::T_unk_2c::_identity, 0, NULL },
    { FLD(PRIMITIVE, unk_3c), TID(int32_t) },
    { FLD(PRIMITIVE, controller_id), TID(int32_t) },
    { FLD(POINTER, controller), identity_traits<df::army_controller >::get(), 0, NULL },
    { FLD(CONTAINER, unk_48), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(CONTAINER, unk_pos_x), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_pos_y), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_70), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_80), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_90), TID(int32_t) },
    { FLD(PRIMITIVE, unk_94), TID(int32_t) },
    { FLD(PRIMITIVE, unk_98), TID(int32_t) },
    { FLD(PRIMITIVE, unk_9c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_a0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_a4), TID(int32_t) },
    { FLD(CONTAINER, unk_a8), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, creature_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity army::_identity(sizeof(army), &allocator_fn<army>, NULL, "army",NULL,army_fields);
  #define CUR_STRUCT army_controller
  static const struct_field_info army_controller_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, pos_x), TID(int32_t) },
    { FLD(PRIMITIVE, pos_y), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(CONTAINER, unk_1c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, year_tick), TID(int32_t) },
    { FLD(PRIMITIVE, unk_34), TID(int32_t) },
    { FLD(PRIMITIVE, unk_38), TID(int32_t) },
    { FLD(PRIMITIVE, unk_3c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_40), TID(int32_t) },
    { FLD(CONTAINER, unk_44), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_54), TID(int32_t) },
    { FLD(POINTER, unk_58), NULL, 0, NULL },
    { FLD(PRIMITIVE, unk_5c), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity army_controller::_identity(sizeof(army_controller), &allocator_fn<army_controller>, NULL, "army_controller",NULL,army_controller_fields);
  #define CUR_STRUCT art_image
  static const struct_field_info art_image_fields[] = {
    { FLD(STL_VECTOR_PTR, elements), identity_traits<df::art_image_element >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, properties), identity_traits<df::art_image_property >::get(), 0, NULL },
    { FLD(PRIMITIVE, event), TID(int32_t) },
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, spec_ref_type), TID(specific_ref_type) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, quality), TID(item_quality) },
    { FLD(PRIMITIVE, artist), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(POINTER, anon_1), identity_traits<df::general_ref >::get(), 0, NULL },
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, subid), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity art_image::_identity(sizeof(art_image), &allocator_fn<art_image>, NULL, "art_image",NULL,art_image_fields);
  #define CUR_STRUCT art_image_chunk
  static const struct_field_info art_image_chunk_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(STATIC_ARRAY, images), identity_traits<df::art_image* >::get(), 500, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity art_image_chunk::_identity(sizeof(art_image_chunk), &allocator_fn<art_image_chunk>, NULL, "art_image_chunk",NULL,art_image_chunk_fields);
  #define CUR_STRUCT art_image_element
  static const struct_field_info art_image_element_fields[] = {
    { FLD(PRIMITIVE, count), TID(int32_t) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, setID) },
    { METHOD(OBJ_METHOD, clone) },
    { METHOD(OBJ_METHOD, getSymbol) },
    { METHOD(OBJ_METHOD, getName1) },
    { METHOD(OBJ_METHOD, getName2) },
    { METHOD(OBJ_METHOD, getColorAndShape) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity art_image_element::_identity(sizeof(art_image_element), &allocator_fn<art_image_element>, "art_image_element","art_image_elementst",NULL,art_image_element_fields);
  #define CUR_STRUCT art_image_element_creaturest
  static const struct_field_info art_image_element_creaturest_fields[] = {
    { FLD(PRIMITIVE, race), TID(int32_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity art_image_element_creaturest::_identity(sizeof(art_image_element_creaturest), &allocator_fn<art_image_element_creaturest>, "art_image_element_creaturest",NULL,&art_image_element::_identity,art_image_element_creaturest_fields);
  #define CUR_STRUCT art_image_element_itemst
  static const struct_field_info art_image_element_itemst_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int16_t) },
    { FLD(SUBSTRUCT, flags), TID(item_flags) },
    { FLD(PRIMITIVE, item_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity art_image_element_itemst::_identity(sizeof(art_image_element_itemst), &allocator_fn<art_image_element_itemst>, "art_image_element_itemst",NULL,&art_image_element::_identity,art_image_element_itemst_fields);
  #define CUR_STRUCT art_image_element_plantst
  static const struct_field_info art_image_element_plantst_fields[] = {
    { FLD(PRIMITIVE, plant_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity art_image_element_plantst::_identity(sizeof(art_image_element_plantst), &allocator_fn<art_image_element_plantst>, "art_image_element_plantst",NULL,&art_image_element::_identity,art_image_element_plantst_fields);
  #define CUR_STRUCT art_image_element_shapest
  static const struct_field_info art_image_element_shapest_fields[] = {
    { FLD(PRIMITIVE, shape_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity art_image_element_shapest::_identity(sizeof(art_image_element_shapest), &allocator_fn<art_image_element_shapest>, "art_image_element_shapest",NULL,&art_image_element::_identity,art_image_element_shapest_fields);
  #define CUR_STRUCT art_image_element_treest
  static const struct_field_info art_image_element_treest_fields[] = {
    { FLD(PRIMITIVE, plant_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity art_image_element_treest::_identity(sizeof(art_image_element_treest), &allocator_fn<art_image_element_treest>, "art_image_element_treest",NULL,&art_image_element::_identity,art_image_element_treest_fields);
  #define CUR_STRUCT art_image_property
  static const struct_field_info art_image_property_fields[] = {
    { FLD(CONTAINER, flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, clone) },
    { METHOD(OBJ_METHOD, getName) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity art_image_property::_identity(sizeof(art_image_property), &allocator_fn<art_image_property>, "art_image_property","art_image_propertyst",NULL,art_image_property_fields);
  #define CUR_STRUCT art_image_property_intransitive_verbst
  static const struct_field_info art_image_property_intransitive_verbst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, verb), TID(art_image_property_verb) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity art_image_property_intransitive_verbst::_identity(sizeof(art_image_property_intransitive_verbst), &allocator_fn<art_image_property_intransitive_verbst>, "art_image_property_intransitive_verbst",NULL,&art_image_property::_identity,art_image_property_intransitive_verbst_fields);
  #define CUR_STRUCT art_image_property_transitive_verbst
  static const struct_field_info art_image_property_transitive_verbst_fields[] = {
    { FLD(PRIMITIVE, subject), TID(int32_t) },
    { FLD(PRIMITIVE, object), TID(int32_t) },
    { FLD(PRIMITIVE, verb), TID(art_image_property_verb) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity art_image_property_transitive_verbst::_identity(sizeof(art_image_property_transitive_verbst), &allocator_fn<art_image_property_transitive_verbst>, "art_image_property_transitive_verbst",NULL,&art_image_property::_identity,art_image_property_transitive_verbst_fields);
  #define CUR_STRUCT art_image_ref
  static const struct_field_info art_image_ref_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, subid), TID(int16_t) },
    { FLD(PRIMITIVE, civ_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity art_image_ref::_identity(sizeof(art_image_ref), &allocator_fn<art_image_ref>, NULL, "art_image_ref",NULL,art_image_ref_fields);
  #define CUR_STRUCT artifact_record
  static const struct_field_info artifact_record_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(CONTAINER, flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(POINTER, item), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity artifact_record::_identity(sizeof(artifact_record), &allocator_fn<artifact_record>, NULL, "artifact_record",NULL,artifact_record_fields);
  #define CUR_STRUCT assign_trade_status
  static const struct_field_info assign_trade_status_fields[] = {
    { FLD(POINTER, item), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, distance), TID(int32_t) },
    { FLD(PRIMITIVE, status), TID(assign_trade_status::T_status) },
    { FLD(PRIMITIVE, unk), TID(bool) },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(PRIMITIVE, weight), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity assign_trade_status::_identity(sizeof(assign_trade_status), &allocator_fn<assign_trade_status>, NULL, "assign_trade_status",NULL,assign_trade_status_fields);
  #define CUR_STRUCT block_burrow
  static const struct_field_info block_burrow_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(SUBSTRUCT, tile_bitmask), &tile_bitmask::_identity },
    { FLD(POINTER, link), identity_traits<df::block_burrow_link >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity block_burrow::_identity(sizeof(block_burrow), &allocator_fn<block_burrow>, NULL, "block_burrow",NULL,block_burrow_fields);
  #define CUR_STRUCT block_burrow_link
  static const struct_field_info block_burrow_link_fields[] = {
    { FLD(POINTER, item), identity_traits<df::block_burrow >::get(), 0, NULL },
    { FLD(POINTER, prev), identity_traits<df::block_burrow_link >::get(), 0, NULL },
    { FLD(POINTER, next), identity_traits<df::block_burrow_link >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity block_burrow_link::_identity(sizeof(block_burrow_link), &allocator_fn<block_burrow_link>, NULL, "block_burrow_link",NULL,block_burrow_link_fields);
  #define CUR_STRUCT block_square_event
  static const struct_field_info block_square_event_fields[] = {
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, isEmpty) },
    { METHOD(OBJ_METHOD, checkTemperature) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity block_square_event::_identity(sizeof(block_square_event), &allocator_fn<block_square_event>, "block_square_event","block_square_eventst",NULL,block_square_event_fields);
  typedef int32_t T_block_square_event_designation_priorityst_fields[16];
  #define CUR_STRUCT block_square_event_designation_priorityst
  static const struct_field_info block_square_event_designation_priorityst_fields[] = {
    { FLD(STATIC_ARRAY, priority), identity_traits<T_block_square_event_designation_priorityst_fields >::get(), 16, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity block_square_event_designation_priorityst::_identity(sizeof(block_square_event_designation_priorityst), &allocator_fn<block_square_event_designation_priorityst>, "block_square_event_designation_priorityst",NULL,&block_square_event::_identity,block_square_event_designation_priorityst_fields);
  typedef df::tiletype T_block_square_event_frozen_liquidst_fields[16];
  typedef enum_field<df::tile_liquid,int8_t> T_block_square_event_frozen_liquidst_fields_1[16];
  #define CUR_STRUCT block_square_event_frozen_liquidst
  static const struct_field_info block_square_event_frozen_liquidst_fields[] = {
    { FLD(STATIC_ARRAY, tiles), identity_traits<T_block_square_event_frozen_liquidst_fields >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, liquid_type), identity_traits<T_block_square_event_frozen_liquidst_fields_1 >::get(), 16, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity block_square_event_frozen_liquidst::_identity(sizeof(block_square_event_frozen_liquidst), &allocator_fn<block_square_event_frozen_liquidst>, "block_square_event_frozen_liquidst",NULL,&block_square_event::_identity,block_square_event_frozen_liquidst_fields);
  typedef int8_t T_block_square_event_grassst_fields[16];
  #define CUR_STRUCT block_square_event_grassst
  static const struct_field_info block_square_event_grassst_fields[] = {
    { FLD(PRIMITIVE, plant_index), TID(int32_t) },
    { FLD(STATIC_ARRAY, amount), identity_traits<T_block_square_event_grassst_fields >::get(), 16, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity block_square_event_grassst::_identity(sizeof(block_square_event_grassst), &allocator_fn<block_square_event_grassst>, "block_square_event_grassst",NULL,&block_square_event::_identity,block_square_event_grassst_fields);
  typedef int32_t T_block_square_event_item_spatterst_fields[16];
  typedef int8_t T_block_square_event_item_spatterst_fields_1[16];
  #define CUR_STRUCT block_square_event_item_spatterst
  static const struct_field_info block_square_event_item_spatterst_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mattype), TID(int16_t) },
    { FLD(PRIMITIVE, matindex), TID(int32_t) },
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD(STATIC_ARRAY, amount), identity_traits<T_block_square_event_item_spatterst_fields >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, unk2), identity_traits<T_block_square_event_item_spatterst_fields_1 >::get(), 16, NULL },
    { FLD(PRIMITIVE, temp1), TID(uint16_t) },
    { FLD(PRIMITIVE, temp2), TID(uint16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity block_square_event_item_spatterst::_identity(sizeof(block_square_event_item_spatterst), &allocator_fn<block_square_event_item_spatterst>, "block_square_event_item_spatterst",NULL,&block_square_event::_identity,block_square_event_item_spatterst_fields);
  typedef uint8_t T_block_square_event_material_spatterst_fields[16];
  #define CUR_STRUCT block_square_event_material_spatterst
  static const struct_field_info block_square_event_material_spatterst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, mat_state), TID(int16_t) },
    { FLD(STATIC_ARRAY, amount), identity_traits<T_block_square_event_material_spatterst_fields >::get(), 16, NULL },
    { FLD(PRIMITIVE, min_temperature), TID(uint16_t) },
    { FLD(PRIMITIVE, max_temperature), TID(uint16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity block_square_event_material_spatterst::_identity(sizeof(block_square_event_material_spatterst), &allocator_fn<block_square_event_material_spatterst>, "block_square_event_material_spatterst",NULL,&block_square_event::_identity,block_square_event_material_spatterst_fields);
  #define CUR_STRUCT block_square_event_mineralst
  static const struct_field_info block_square_event_mineralst_fields[] = {
    { FLD(PRIMITIVE, inorganic_mat), TID(int32_t) },
    { FLD(SUBSTRUCT, tile_bitmask), &tile_bitmask::_identity },
    { FLD(SUBSTRUCT, flags), TID(block_square_event_mineralst::T_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity block_square_event_mineralst::_identity(sizeof(block_square_event_mineralst), &allocator_fn<block_square_event_mineralst>, "block_square_event_mineralst",NULL,&block_square_event::_identity,block_square_event_mineralst_fields);
  typedef int16_t T_block_square_event_spoorst_fields[16];
  typedef int8_t T_block_square_event_spoorst_fields_1[16];
  typedef int32_t T_block_square_event_spoorst_fields_2[16];
  typedef int32_t T_block_square_event_spoorst_fields_3[16];
  typedef int32_t T_block_square_event_spoorst_fields_4[16];
  typedef int32_t T_block_square_event_spoorst_fields_5[16];
  #define CUR_STRUCT block_square_event_spoorst
  static const struct_field_info block_square_event_spoorst_fields[] = {
    { FLD(STATIC_ARRAY, anon_1), identity_traits<T_block_square_event_spoorst_fields >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, anon_2), identity_traits<T_block_square_event_spoorst_fields_1 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, anon_3), identity_traits<T_block_square_event_spoorst_fields_2 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, anon_4), identity_traits<T_block_square_event_spoorst_fields_3 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, anon_5), identity_traits<T_block_square_event_spoorst_fields_4 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, anon_6), identity_traits<T_block_square_event_spoorst_fields_5 >::get(), 16, NULL },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity block_square_event_spoorst::_identity(sizeof(block_square_event_spoorst), &allocator_fn<block_square_event_spoorst>, "block_square_event_spoorst",NULL,&block_square_event::_identity,block_square_event_spoorst_fields);
  #define CUR_STRUCT block_square_event_world_constructionst
  static const struct_field_info block_square_event_world_constructionst_fields[] = {
    { FLD(PRIMITIVE, construction_id), TID(int32_t) },
    { FLD(SUBSTRUCT, tile_bitmask), &tile_bitmask::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity block_square_event_world_constructionst::_identity(sizeof(block_square_event_world_constructionst), &allocator_fn<block_square_event_world_constructionst>, "block_square_event_world_constructionst",NULL,&block_square_event::_identity,block_square_event_world_constructionst_fields);
  #define CUR_STRUCT body_appearance_modifier
  static const struct_field_info body_appearance_modifier_fields[] = {
    { FLD(PRIMITIVE, type), TID(appearance_modifier_type) },
    { FLD(STATIC_ARRAY, ranges), identity_traits<int32_t >::get(), 7, NULL },
    { FLD(STATIC_ARRAY, desc_range), identity_traits<int32_t >::get(), 6, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int16_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, importance), TID(int32_t) },
    { FLD(PRIMITIVE, noun), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_7), TID(int16_t) },
    { FLD(PRIMITIVE, anon_8), TID(int16_t) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, id2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity body_appearance_modifier::_identity(sizeof(body_appearance_modifier), &allocator_fn<body_appearance_modifier>, NULL, "body_appearance_modifier",NULL,body_appearance_modifier_fields);
  #define CUR_STRUCT body_component_info
  static const struct_field_info body_component_info_fields[] = {
    { FLD(CONTAINER, body_part_status), identity_traits<std::vector<df::body_part_status > >::get(), 0, NULL },
    { FLD(CONTAINER, numbered_masks), identity_traits<std::vector<uint32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, nonsolid_remaining), identity_traits<std::vector<uint32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, layer_status), identity_traits<std::vector<df::body_layer_status > >::get(), 0, NULL },
    { FLD(CONTAINER, layer_wound_area), identity_traits<std::vector<uint32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, layer_cut_fraction), identity_traits<std::vector<uint32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, layer_dent_fraction), identity_traits<std::vector<uint32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, layer_effect_fraction), identity_traits<std::vector<uint32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity body_component_info::_identity(sizeof(body_component_info), &allocator_fn<body_component_info>, NULL, "body_component_info",NULL,body_component_info_fields);
  #define CUR_STRUCT body_detail_plan
  static const struct_field_info body_detail_plan_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, add_material_name), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, add_material_template), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, add_tissue_name), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, add_tissue_template), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, unk5c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk6c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk7c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_layers_selection), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_layers_criteria), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_layers_tissue), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_layers_thickness), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_layers_position), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_layers_over_under), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_relsize_selection), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_relsize_criteria), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_relsize_value), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_position_selection), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_position_criteria), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_position_value), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_relation_selection_1), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_relation_criteria_1), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_relation_value_1), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_relation_selection_2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_relation_criteria_2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_relation_extent), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity body_detail_plan::_identity(sizeof(body_detail_plan), &allocator_fn<body_detail_plan>, NULL, "body_detail_plan",NULL,body_detail_plan_fields);
  #define CUR_STRUCT body_part_layer_raw
  static const struct_field_info body_part_layer_raw_fields[] = {
    { FLD(PRIMITIVE, layer_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, tissue_id), TID(int32_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::body_part_layer_flags> >::get(), 0, TID(body_part_layer_flags) },
    { FLD(PRIMITIVE, part_fraction), TID(int32_t) },
    { FLD(PRIMITIVE, healing_rate), TID(int32_t) },
    { FLD(PRIMITIVE, vascular), TID(int32_t) },
    { FLD(PRIMITIVE, pain_receptors), TID(int32_t) },
    { FLD(PRIMITIVE, unk6), TID(int32_t) },
    { FLD(PRIMITIVE, unk7), TID(int16_t) },
    { FLD(CONTAINER, bp_modifiers), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, layer_id), TID(int32_t) },
    { FLD(PRIMITIVE, parent_idx), TID(int32_t) },
    { FLD(PRIMITIVE, parent_layer_id), TID(int32_t) },
    { FLD(PRIMITIVE, layer_depth), TID(int32_t) },
    { FLD(PRIMITIVE, leak_barrier_id), TID(int32_t) },
    { FLD(PRIMITIVE, nonsolid_id), TID(int32_t) },
    { FLD(PRIMITIVE, styleable_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity body_part_layer_raw::_identity(sizeof(body_part_layer_raw), &allocator_fn<body_part_layer_raw>, NULL, "body_part_layer_raw",NULL,body_part_layer_raw_fields);
  #define CUR_STRUCT body_part_raw
  static const struct_field_info body_part_raw_fields[] = {
    { FLD(PRIMITIVE, token), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, category), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, con_part_id), TID(int16_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::body_part_raw_flags> >::get(), 0, TID(body_part_raw_flags) },
    { FLD(STL_VECTOR_PTR, layers), identity_traits<df::body_part_layer_raw >::get(), 0, NULL },
    { FLD(PRIMITIVE, fraction_total), TID(int32_t) },
    { FLD(PRIMITIVE, fraction_base), TID(int32_t) },
    { FLD(PRIMITIVE, fraction_fat), TID(int32_t) },
    { FLD(PRIMITIVE, fraction_muscle), TID(int32_t) },
    { FLD(PRIMITIVE, relsize), TID(int32_t) },
    { FLD(PRIMITIVE, number), TID(int32_t) },
    { FLD(PRIMITIVE, unk7b), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, name_singular), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, name_plural), identity_traits<std::string >::get(), 0, NULL },
    { FLD(POINTER, bp_relation_part_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(POINTER, bp_relation_code), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(POINTER, bp_relation_coverage), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, min_temp), TID(uint16_t) },
    { FLD(PRIMITIVE, max_temp), TID(uint16_t) },
    { FLD(PRIMITIVE, temp_factor), TID(uint16_t) },
    { FLD(PRIMITIVE, numbered_idx), TID(int32_t) },
    { FLD(PRIMITIVE, insulation_fat), TID(int16_t) },
    { FLD(PRIMITIVE, insulation_muscle), TID(int16_t) },
    { FLD(PRIMITIVE, insulation_base), TID(int16_t) },
    { FLD(PRIMITIVE, clothing_item_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity body_part_raw::_identity(sizeof(body_part_raw), &allocator_fn<body_part_raw>, NULL, "body_part_raw",NULL,body_part_raw_fields);
  #define CUR_STRUCT body_part_template
  static const struct_field_info body_part_template_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, con), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, category), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, con_cat), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, contype), TID(body_part_template_contype) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::body_part_template_flags> >::get(), 0, TID(body_part_template_flags) },
    { FLD(PRIMITIVE, default_relsize), TID(int32_t) },
    { FLD(PRIMITIVE, number), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, name_singular), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, name_plural), identity_traits<std::string >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity body_part_template::_identity(sizeof(body_part_template), &allocator_fn<body_part_template>, NULL, "body_part_template",NULL,body_part_template_fields);
  #define CUR_STRUCT body_size_info
  static const struct_field_info body_size_info_fields[] = {
    { FLD(PRIMITIVE, size_cur), TID(int32_t) },
    { FLD(PRIMITIVE, size_base), TID(int32_t) },
    { FLD(PRIMITIVE, area_cur), TID(int32_t) },
    { FLD(PRIMITIVE, area_base), TID(int32_t) },
    { FLD(PRIMITIVE, length_cur), TID(int32_t) },
    { FLD(PRIMITIVE, length_base), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity body_size_info::_identity(sizeof(body_size_info), &allocator_fn<body_size_info>, NULL, "body_size_info",NULL,body_size_info_fields);
  #define CUR_STRUCT body_template
  static const struct_field_info body_template_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, parts), identity_traits<df::body_part_template >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity body_template::_identity(sizeof(body_template), &allocator_fn<body_template>, NULL, "body_template",NULL,body_template_fields);
  #define CUR_STRUCT bp_appearance_modifier
  static const struct_field_info bp_appearance_modifier_fields[] = {
    { FLD(PRIMITIVE, type), TID(appearance_modifier_type) },
    { FLD(STATIC_ARRAY, ranges), identity_traits<int32_t >::get(), 7, NULL },
    { FLD(STATIC_ARRAY, desc_range), identity_traits<int32_t >::get(), 6, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int16_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, importance), TID(int32_t) },
    { FLD(PRIMITIVE, noun), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, single_plural), TID(int16_t) },
    { FLD(PRIMITIVE, unk1), TID(int16_t) },
    { FLD(PRIMITIVE, id1), TID(int32_t) },
    { FLD(CONTAINER, body_parts), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, tissue_layer), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity bp_appearance_modifier::_identity(sizeof(bp_appearance_modifier), &allocator_fn<bp_appearance_modifier>, NULL, "bp_appearance_modifier",NULL,bp_appearance_modifier_fields);
  #define CUR_STRUCT build_req_choice_genst
  static const struct_field_info build_req_choice_genst_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(CONTAINER, candidates), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, used_count), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity build_req_choice_genst::_identity(sizeof(build_req_choice_genst), &allocator_fn<build_req_choice_genst>, "build_req_choice_genst",NULL,&build_req_choicest::_identity,build_req_choice_genst_fields);
  #define CUR_STRUCT build_req_choice_specst
  static const struct_field_info build_req_choice_specst_fields[] = {
    { FLD(POINTER, candidate), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, candidate_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity build_req_choice_specst::_identity(sizeof(build_req_choice_specst), &allocator_fn<build_req_choice_specst>, "build_req_choice_specst",NULL,&build_req_choicest::_identity,build_req_choice_specst_fields);
  #define CUR_STRUCT build_req_choicest
  static const struct_field_info build_req_choicest_fields[] = {
    { FLD(PRIMITIVE, distance), TID(int32_t) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, getName) },
    { METHOD(OBJ_METHOD, isCandidate) },
    { METHOD(OBJ_METHOD, getUsedCount) },
    { METHOD(OBJ_METHOD, getNumCandidates) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity build_req_choicest::_identity(sizeof(build_req_choicest), &allocator_fn<build_req_choicest>, "build_req_choicest",NULL,NULL,build_req_choicest_fields);
  #define CUR_STRUCT building::T_job_claim_suppress
  static const struct_field_info building_doT_Dot_T_job_claim_suppress_fields[] = {
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity building::T_job_claim_suppress::_identity(sizeof(building::T_job_claim_suppress), &allocator_fn<building::T_job_claim_suppress>, &building::_identity, "T_job_claim_suppress",NULL,building_doT_Dot_T_job_claim_suppress_fields);
  #define CUR_STRUCT building::T_activities
  static const struct_field_info building_doT_Dot_T_activities_fields[] = {
    { FLD(PRIMITIVE, activity_id), TID(int32_t) },
    { FLD(PRIMITIVE, event_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity building::T_activities::_identity(sizeof(building::T_activities), &allocator_fn<building::T_activities>, &building::_identity, "T_activities",NULL,building_doT_Dot_T_activities_fields);
  #define CUR_STRUCT building
  static const struct_field_info building_fields[] = {
    { FLD(PRIMITIVE, x1), TID(int32_t) },
    { FLD(PRIMITIVE, y1), TID(int32_t) },
    { FLD(PRIMITIVE, centerx), TID(int32_t) },
    { FLD(PRIMITIVE, x2), TID(int32_t) },
    { FLD(PRIMITIVE, y2), TID(int32_t) },
    { FLD(PRIMITIVE, centery), TID(int32_t) },
    { FLD(PRIMITIVE, z), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(building_flags) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(SUBSTRUCT, room), &building_extents::_identity },
    { FLD(PRIMITIVE, age), TID(int32_t) },
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, jobs), identity_traits<df::job >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, specific_refs), identity_traits<df::specific_ref >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, general_refs), identity_traits<df::general_ref >::get(), 0, NULL },
    { FLD(PRIMITIVE, is_room), TID(bool) },
    { FLD(STL_VECTOR_PTR, children), identity_traits<df::building >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, parents), identity_traits<df::building >::get(), 0, NULL },
    { FLD(PRIMITIVE, owner_id), TID(int32_t) },
    { FLD(POINTER, owner), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, job_claim_suppress), &building::T_job_claim_suppress::_identity, 0, NULL },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, activities), &building::T_activities::_identity, 0, NULL },
    { FLD(PRIMITIVE, world_data_id), TID(int32_t) },
    { FLD(PRIMITIVE, world_data_subid), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_2), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_3), TID(int32_t) },
    { METHOD(OBJ_METHOD, getCustomType) },
    { METHOD(OBJ_METHOD, setCustomType) },
    { METHOD(OBJ_METHOD, countHospitalSupplies) },
    { METHOD(OBJ_METHOD, getStockpileLinks) },
    { METHOD(OBJ_METHOD, detachWorldData) },
    { METHOD(OBJ_METHOD, canLinkToStockpile) },
    { METHOD(OBJ_METHOD, getUsers) },
    { METHOD(OBJ_METHOD, moveBuilding) },
    { METHOD(OBJ_METHOD, initOccupancy) },
    { METHOD(OBJ_METHOD, setFillTimer) },
    { METHOD(OBJ_METHOD, isOnFire) },
    { METHOD(OBJ_METHOD, isUnpowered) },
    { METHOD(OBJ_METHOD, canCollapse) },
    { METHOD(OBJ_METHOD, getPassableOccupancy) },
    { METHOD(OBJ_METHOD, getImpassableOccupancy) },
    { METHOD(OBJ_METHOD, isPowerSource) },
    { METHOD(OBJ_METHOD, updateFromWeather) },
    { METHOD(OBJ_METHOD, updateTemperature) },
    { METHOD(OBJ_METHOD, updateItems) },
    { METHOD(OBJ_METHOD, updateTempFromTile) },
    { METHOD(OBJ_METHOD, isNormalFurniture) },
    { METHOD(OBJ_METHOD, isFarmPlot) },
    { METHOD(OBJ_METHOD, getWorkshopProfile) },
    { METHOD(OBJ_METHOD, getMachineInfo) },
    { METHOD(OBJ_METHOD, getPowerInfo) },
    { METHOD(OBJ_METHOD, canConnectToMachine) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, getSubtype) },
    { METHOD(OBJ_METHOD, setSubtype) },
    { METHOD(OBJ_METHOD, isActual) },
    { METHOD(OBJ_METHOD, isCoffin2) },
    { METHOD(OBJ_METHOD, updateAction) },
    { METHOD(OBJ_METHOD, isStatueOrRestraint) },
    { METHOD(OBJ_METHOD, setMaterialAmount) },
    { METHOD(OBJ_METHOD, setBuildStage) },
    { METHOD(OBJ_METHOD, getBuildStage) },
    { METHOD(OBJ_METHOD, getMaxBuildStage) },
    { METHOD(OBJ_METHOD, getArchitectureValue) },
    { METHOD(OBJ_METHOD, isSettingOccupancy) },
    { METHOD(OBJ_METHOD, isActual2) },
    { METHOD(OBJ_METHOD, isExtentShaped) },
    { METHOD(OBJ_METHOD, updateOccupancy) },
    { METHOD(OBJ_METHOD, getRoomValue) },
    { METHOD(OBJ_METHOD, getPersonalValue) },
    { METHOD(OBJ_METHOD, canBeRoom) },
    { METHOD(OBJ_METHOD, getConstructionValue) },
    { METHOD(OBJ_METHOD, queueDestroy) },
    { METHOD(OBJ_METHOD, isImpassableTile) },
    { METHOD(OBJ_METHOD, getFreeCapacity) },
    { METHOD(OBJ_METHOD, canStoreItem) },
    { METHOD(OBJ_METHOD, getName) },
    { METHOD(OBJ_METHOD, getNameColor) },
    { METHOD(OBJ_METHOD, initFarmSeasons) },
    { METHOD(OBJ_METHOD, initBurialFlags) },
    { METHOD(OBJ_METHOD, clearBurialFlags) },
    { METHOD(OBJ_METHOD, clearBurialFlags2) },
    { METHOD(OBJ_METHOD, getClutterLevel) },
    { METHOD(OBJ_METHOD, needsDesign) },
    { METHOD(OBJ_METHOD, canUseForMood) },
    { METHOD(OBJ_METHOD, canBeRoomSubset) },
    { METHOD(OBJ_METHOD, isCoffin) },
    { METHOD(OBJ_METHOD, canUseSpouseRoom) },
    { METHOD(OBJ_METHOD, canMakeRoom) },
    { METHOD(OBJ_METHOD, isJusticeRestraint) },
    { METHOD(OBJ_METHOD, detachRestrainedUnit) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, isImpassableAtCreation) },
    { METHOD(OBJ_METHOD, categorize) },
    { METHOD(OBJ_METHOD, uncategorize) },
    { METHOD(OBJ_METHOD, getBaseValue) },
    { METHOD(OBJ_METHOD, setTriggerState) },
    { METHOD(OBJ_METHOD, checkAdvmodeLocked) },
    { METHOD(OBJ_METHOD, drawAdvmodeUnlockUI) },
    { METHOD(OBJ_METHOD, advmodeUnlock) },
    { METHOD(OBJ_METHOD, needsMagma) },
    { METHOD(OBJ_METHOD, removeUses) },
    { METHOD(OBJ_METHOD, deconstructItems) },
    { METHOD(OBJ_METHOD, cleanupMap) },
    { METHOD(OBJ_METHOD, isFireSafe) },
    { METHOD(OBJ_METHOD, fillSidebarMenu) },
    { METHOD(OBJ_METHOD, isForbidden) },
    { METHOD(OBJ_METHOD, isHidden) },
    { METHOD(OBJ_METHOD, isVisibleInUI) },
    { METHOD(OBJ_METHOD, isVisibleInViewport) },
    { METHOD(OBJ_METHOD, getDrawExtents) },
    { METHOD(OBJ_METHOD, drawBuilding) },
    { METHOD(OBJ_METHOD, setSquadUse) },
    { METHOD(OBJ_METHOD, getSquads) },
    { METHOD(OBJ_METHOD, getSpecificSquad) },
    { METHOD(OBJ_METHOD, getSpecificPosition) },
    { METHOD(OBJ_METHOD, setSpecificSquadPos) },
    { METHOD(OBJ_METHOD, clearSpecificSquad) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building::_identity(sizeof(building), &allocator_fn<building>, "building","buildingst",NULL,building_fields);
  #define CUR_STRUCT building_actual::T_contained_items
  static const struct_field_info building_actual_doT_Dot_T_contained_items_fields[] = {
    { FLD(POINTER, item), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, use_mode), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity building_actual::T_contained_items::_identity(sizeof(building_actual::T_contained_items), &allocator_fn<building_actual::T_contained_items>, &building_actual::_identity, "T_contained_items",NULL,building_actual_doT_Dot_T_contained_items_fields);
  #define CUR_STRUCT building_actual
  static const struct_field_info building_actual_fields[] = {
    { FLD(PRIMITIVE, construction_stage), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, contained_items), &building_actual::T_contained_items::_identity, 0, NULL },
    { FLD(POINTER, design), identity_traits<df::building_design >::get(), 0, NULL },
    { METHOD(OBJ_METHOD, isDestroyedByItemRemoval) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_actual::_identity(sizeof(building_actual), &allocator_fn<building_actual>, "building_actual","building_actualst",&building::_identity,building_actual_fields);
  #define CUR_STRUCT building_animaltrapst
  static const struct_field_info building_animaltrapst_fields[] = {
    { FLD(PRIMITIVE, bait_type), TID(int16_t) },
    { FLD(PRIMITIVE, fill_timer), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_animaltrapst::_identity(sizeof(building_animaltrapst), &allocator_fn<building_animaltrapst>, "building_animaltrapst",NULL,&building_actual::_identity,building_animaltrapst_fields);
  #define CUR_STRUCT building_archerytargetst
  static const struct_field_info building_archerytargetst_fields[] = {
    { FLD(PRIMITIVE, archery_direction), TID(building_archerytargetst::T_archery_direction) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_archerytargetst::_identity(sizeof(building_archerytargetst), &allocator_fn<building_archerytargetst>, "building_archerytargetst",NULL,&building_actual::_identity,building_archerytargetst_fields);
  #define CUR_STRUCT building_armorstandst
  static const struct_field_info building_armorstandst_fields[] = {
    { FLD(PRIMITIVE, unk_c0), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, squads), identity_traits<df::building_squad_use >::get(), 0, NULL },
    { FLD(PRIMITIVE, specific_squad), TID(int32_t) },
    { FLD(PRIMITIVE, specific_position), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_armorstandst::_identity(sizeof(building_armorstandst), &allocator_fn<building_armorstandst>, "building_armorstandst",NULL,&building_actual::_identity,building_armorstandst_fields);
  #define CUR_STRUCT building_axle_horizontalst
  static const struct_field_info building_axle_horizontalst_fields[] = {
    { FLD(SUBSTRUCT, machine), &machine_info::_identity },
    { FLD(PRIMITIVE, is_vertical), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_axle_horizontalst::_identity(sizeof(building_axle_horizontalst), &allocator_fn<building_axle_horizontalst>, "building_axle_horizontalst",NULL,&building_actual::_identity,building_axle_horizontalst_fields);
  #define CUR_STRUCT building_axle_verticalst
  static const struct_field_info building_axle_verticalst_fields[] = {
    { FLD(SUBSTRUCT, machine), &machine_info::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_axle_verticalst::_identity(sizeof(building_axle_verticalst), &allocator_fn<building_axle_verticalst>, "building_axle_verticalst",NULL,&building_actual::_identity,building_axle_verticalst_fields);
  #define CUR_STRUCT building_bars_floorst
  static const struct_field_info building_bars_floorst_fields[] = {
    { FLD(SUBSTRUCT, gate_flags), TID(gate_flags) },
    { FLD(PRIMITIVE, timer), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_bars_floorst::_identity(sizeof(building_bars_floorst), &allocator_fn<building_bars_floorst>, "building_bars_floorst",NULL,&building_actual::_identity,building_bars_floorst_fields);
  #define CUR_STRUCT building_bars_verticalst
  static const struct_field_info building_bars_verticalst_fields[] = {
    { FLD(SUBSTRUCT, gate_flags), TID(gate_flags) },
    { FLD(PRIMITIVE, timer), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_bars_verticalst::_identity(sizeof(building_bars_verticalst), &allocator_fn<building_bars_verticalst>, "building_bars_verticalst",NULL,&building_actual::_identity,building_bars_verticalst_fields);
  #define CUR_STRUCT building_bedst
  static const struct_field_info building_bedst_fields[] = {
    { FLD(SUBSTRUCT, anon_1), TID(building_bedst::T_anon_1) },
    { FLD(STL_VECTOR_PTR, squads), identity_traits<df::building_squad_use >::get(), 0, NULL },
    { FLD(PRIMITIVE, specific_squad), TID(int32_t) },
    { FLD(PRIMITIVE, specific_position), TID(int32_t) },
    { FLD(SUBSTRUCT, users), &building_users::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_bedst::_identity(sizeof(building_bedst), &allocator_fn<building_bedst>, "building_bedst",NULL,&building_actual::_identity,building_bedst_fields);
  #define CUR_STRUCT building_boxst
  static const struct_field_info building_boxst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, squads), identity_traits<df::building_squad_use >::get(), 0, NULL },
    { FLD(PRIMITIVE, specific_squad), TID(int32_t) },
    { FLD(PRIMITIVE, specific_position), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_boxst::_identity(sizeof(building_boxst), &allocator_fn<building_boxst>, "building_boxst",NULL,&building_actual::_identity,building_boxst_fields);
  #define CUR_STRUCT building_bridgest
  static const struct_field_info building_bridgest_fields[] = {
    { FLD(SUBSTRUCT, gate_flags), TID(gate_flags) },
    { FLD(PRIMITIVE, timer), TID(int8_t) },
    { FLD(PRIMITIVE, direction), TID(building_bridgest::T_direction) },
    { FLD(PRIMITIVE, material_amount), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_bridgest::_identity(sizeof(building_bridgest), &allocator_fn<building_bridgest>, "building_bridgest",NULL,&building_actual::_identity,building_bridgest_fields);
  #define CUR_STRUCT building_cabinetst
  static const struct_field_info building_cabinetst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, squads), identity_traits<df::building_squad_use >::get(), 0, NULL },
    { FLD(PRIMITIVE, specific_squad), TID(int32_t) },
    { FLD(PRIMITIVE, specific_position), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_cabinetst::_identity(sizeof(building_cabinetst), &allocator_fn<building_cabinetst>, "building_cabinetst",NULL,&building_actual::_identity,building_cabinetst_fields);
  #define CUR_STRUCT building_cagest
  static const struct_field_info building_cagest_fields[] = {
    { FLD(CONTAINER, assigned_units), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, assigned_items), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, cage_flags), TID(building_cagest::T_cage_flags) },
    { FLD(PRIMITIVE, fill_timer), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_cagest::_identity(sizeof(building_cagest), &allocator_fn<building_cagest>, "building_cagest",NULL,&building_actual::_identity,building_cagest_fields);
  #define CUR_STRUCT building_chainst
  static const struct_field_info building_chainst_fields[] = {
    { FLD(POINTER, assigned), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, chained), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(SUBSTRUCT, chain_flags), TID(building_chainst::T_chain_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_chainst::_identity(sizeof(building_chainst), &allocator_fn<building_chainst>, "building_chainst",NULL,&building_actual::_identity,building_chainst_fields);
  #define CUR_STRUCT building_chairst
  static const struct_field_info building_chairst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(SUBSTRUCT, users), &building_users::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_chairst::_identity(sizeof(building_chairst), &allocator_fn<building_chairst>, "building_chairst",NULL,&building_actual::_identity,building_chairst_fields);
  #define CUR_STRUCT building_civzonest
  static const struct_field_info building_civzonest_fields[] = {
    { FLD(CONTAINER, assigned_units), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, assigned_items), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, type), identity_traits<enum_field<df::civzone_type,int32_t> >::get() },
    { FLD(SUBSTRUCT, zone_flags), TID(building_civzonest::T_zone_flags) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, abstract_building_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, zone_num), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(SUBSTRUCT, pit_flags), TID(building_civzonest::T_pit_flags) },
    { FLD(PRIMITIVE, fill_timer), TID(int16_t) },
    { FLD(SUBSTRUCT, hospital), &hospital_supplies::_identity },
    { FLD(SUBSTRUCT, gather_flags), TID(building_civzonest::T_gather_flags) },
    { FLD(PRIMITIVE, unk_v4014_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_civzonest::_identity(sizeof(building_civzonest), &allocator_fn<building_civzonest>, "building_civzonest",NULL,&building::_identity,building_civzonest_fields);
  #define CUR_STRUCT building_coffinst
  static const struct_field_info building_coffinst_fields[] = {
    { FLD(SUBSTRUCT, burial_mode), TID(building_coffinst::T_burial_mode) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_coffinst::_identity(sizeof(building_coffinst), &allocator_fn<building_coffinst>, "building_coffinst",NULL,&building_actual::_identity,building_coffinst_fields);
  #define CUR_STRUCT building_constructionst
  static const struct_field_info building_constructionst_fields[] = {
    { FLD(PRIMITIVE, type), TID(construction_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_constructionst::_identity(sizeof(building_constructionst), &allocator_fn<building_constructionst>, "building_constructionst",NULL,&building_actual::_identity,building_constructionst_fields);
  typedef uint8_t T_building_def_fields[31][31];
  typedef uint8_t T_building_def_fields_1[4][31][31];
  typedef uint8_t T_building_def_fields_2[31];
  #define CUR_STRUCT building_def
  static const struct_field_info building_def_fields[] = {
    { FLD(PRIMITIVE, code), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, building_type), TID(building_type) },
    { FLD(PRIMITIVE, building_subtype), TID(int32_t) },
    { FLD(STATIC_ARRAY, name_color), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, tile), identity_traits<T_building_def_fields >::get(), 4, NULL },
    { FLD(STATIC_ARRAY, tile_color), identity_traits<T_building_def_fields_1 >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, tile_block), identity_traits<T_building_def_fields_2 >::get(), 31, NULL },
    { FLD(PRIMITIVE, build_key), TID(int32_t) },
    { FLD(PRIMITIVE, needs_magma), TID(bool) },
    { FLD(STL_VECTOR_PTR, build_items), identity_traits<df::building_def_item >::get(), 0, NULL },
    { FLD(PRIMITIVE, dim_x), TID(int32_t) },
    { FLD(PRIMITIVE, dim_y), TID(int32_t) },
    { FLD(PRIMITIVE, workloc_x), TID(int32_t) },
    { FLD(PRIMITIVE, workloc_y), TID(int32_t) },
    { FLD(CONTAINER, build_labors), identity_traits<std::vector<df::unit_labor > >::get(), 0, NULL },
    { FLD(PRIMITIVE, labor_description), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, build_stages), TID(int32_t) },
    { METHOD(OBJ_METHOD, parseRaws) },
    { METHOD(OBJ_METHOD, categorize) },
    { METHOD(OBJ_METHOD, finalize) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_def::_identity(sizeof(building_def), &allocator_fn<building_def>, "building_def","building_defst",NULL,building_def_fields);
  virtual_identity building_def_furnacest::_identity(sizeof(building_def_furnacest), &allocator_fn<building_def_furnacest>, "building_def_furnacest",NULL,&building_def::_identity,NULL);
  #define CUR_STRUCT building_def_item
  static const struct_field_info building_def_item_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int16_t) },
    { FLD(PRIMITIVE, reaction_class), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, has_material_reaction_product), identity_traits<std::string >::get() },
    { FLD(SUBSTRUCT, flags1), TID(job_item_flags1) },
    { FLD(SUBSTRUCT, flags2), TID(job_item_flags2) },
    { FLD(SUBSTRUCT, flags3), TID(job_item_flags3) },
    { FLD(PRIMITIVE, flags4), TID(uint32_t) },
    { FLD(PRIMITIVE, flags5), TID(uint32_t) },
    { FLD(PRIMITIVE, metal_ore), TID(int32_t) },
    { FLD(PRIMITIVE, min_dimension), TID(int32_t) },
    { FLD(PRIMITIVE, quantity), TID(int32_t) },
    { FLD(PRIMITIVE, has_tool_use), TID(tool_uses) },
    { FLD(STATIC_ARRAY, item_str), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, material_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD(PRIMITIVE, metal_ore_str), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity building_def_item::_identity(sizeof(building_def_item), &allocator_fn<building_def_item>, NULL, "building_def_item",NULL,building_def_item_fields);
  virtual_identity building_def_workshopst::_identity(sizeof(building_def_workshopst), &allocator_fn<building_def_workshopst>, "building_def_workshopst",NULL,&building_def::_identity,NULL);
  #define CUR_STRUCT building_design
  static const struct_field_info building_design_fields[] = {
    { FLD(PRIMITIVE, architect), TID(int32_t) },
    { FLD(PRIMITIVE, unk2), TID(int32_t) },
    { FLD(PRIMITIVE, design_skill), TID(int16_t) },
    { FLD(PRIMITIVE, builder1), TID(int32_t) },
    { FLD(PRIMITIVE, unk5), TID(int32_t) },
    { FLD(PRIMITIVE, build_skill), TID(int16_t) },
    { FLD(PRIMITIVE, build_timer1), TID(int16_t) },
    { FLD(PRIMITIVE, builder2), TID(int32_t) },
    { FLD(PRIMITIVE, build_timer2), TID(int16_t) },
    { FLD(PRIMITIVE, quality1), TID(item_quality) },
    { FLD(PRIMITIVE, quality2), TID(item_quality) },
    { FLD(SUBSTRUCT, flags), TID(building_design::T_flags) },
    { FLD(PRIMITIVE, hitpoints), TID(int32_t) },
    { FLD(PRIMITIVE, max_hitpoints), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity building_design::_identity(sizeof(building_design), &allocator_fn<building_design>, NULL, "building_design",NULL,building_design_fields);
  #define CUR_STRUCT building_doorst
  static const struct_field_info building_doorst_fields[] = {
    { FLD(SUBSTRUCT, door_flags), TID(door_flags) },
    { FLD(PRIMITIVE, close_timer), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_doorst::_identity(sizeof(building_doorst), &allocator_fn<building_doorst>, "building_doorst",NULL,&building_actual::_identity,building_doorst_fields);
  typedef uint8_t T_building_drawbuffer_fields[31];
  typedef int8_t T_building_drawbuffer_fields_1[31];
  typedef int8_t T_building_drawbuffer_fields_2[31];
  typedef int8_t T_building_drawbuffer_fields_3[31];
  #define CUR_STRUCT building_drawbuffer
  static const struct_field_info building_drawbuffer_fields[] = {
    { FLD(STATIC_ARRAY, tile), identity_traits<T_building_drawbuffer_fields >::get(), 31, NULL },
    { FLD(STATIC_ARRAY, fore), identity_traits<T_building_drawbuffer_fields_1 >::get(), 31, NULL },
    { FLD(STATIC_ARRAY, back), identity_traits<T_building_drawbuffer_fields_2 >::get(), 31, NULL },
    { FLD(STATIC_ARRAY, bright), identity_traits<T_building_drawbuffer_fields_3 >::get(), 31, NULL },
    { FLD(PRIMITIVE, x1), TID(int16_t) },
    { FLD(PRIMITIVE, x2), TID(int16_t) },
    { FLD(PRIMITIVE, y1), TID(int16_t) },
    { FLD(PRIMITIVE, y2), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity building_drawbuffer::_identity(sizeof(building_drawbuffer), &allocator_fn<building_drawbuffer>, NULL, "building_drawbuffer",NULL,building_drawbuffer_fields);
  #define CUR_STRUCT building_extents
  static const struct_field_info building_extents_fields[] = {
    { FLD(POINTER, extents), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(PRIMITIVE, x), TID(int32_t) },
    { FLD(PRIMITIVE, y), TID(int32_t) },
    { FLD(PRIMITIVE, width), TID(int32_t) },
    { FLD(PRIMITIVE, height), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity building_extents::_identity(sizeof(building_extents), &allocator_fn<building_extents>, NULL, "building_extents",NULL,building_extents_fields);
  #define CUR_STRUCT building_farmplotst
  static const struct_field_info building_farmplotst_fields[] = {
    { FLD(STATIC_ARRAY, plant_id), identity_traits<int16_t >::get(), 4, NULL },
    { FLD(PRIMITIVE, material_amount), TID(int32_t) },
    { FLD(PRIMITIVE, seasonal_fertilize), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(PRIMITIVE, current_fertilization), TID(int32_t) },
    { FLD(PRIMITIVE, max_fertilization), TID(int32_t) },
    { FLD(PRIMITIVE, terrain_purge_timer), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_farmplotst::_identity(sizeof(building_farmplotst), &allocator_fn<building_farmplotst>, "building_farmplotst",NULL,&building_actual::_identity,building_farmplotst_fields);
  #define CUR_STRUCT building_floodgatest
  static const struct_field_info building_floodgatest_fields[] = {
    { FLD(SUBSTRUCT, gate_flags), TID(gate_flags) },
    { FLD(PRIMITIVE, timer), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_floodgatest::_identity(sizeof(building_floodgatest), &allocator_fn<building_floodgatest>, "building_floodgatest",NULL,&building_actual::_identity,building_floodgatest_fields);
  #define CUR_STRUCT building_furnacest
  static const struct_field_info building_furnacest_fields[] = {
    { FLD(CONTAINER, melt_remainder), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_108), TID(int16_t) },
    { FLD(PRIMITIVE, type), TID(furnace_type) },
    { FLD(SUBSTRUCT, profile), &workshop_profile::_identity },
    { FLD(SUBSTRUCT, links), &stockpile_links::_identity },
    { FLD(PRIMITIVE, custom_type), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_furnacest::_identity(sizeof(building_furnacest), &allocator_fn<building_furnacest>, "building_furnacest",NULL,&building_actual::_identity,building_furnacest_fields);
  #define CUR_STRUCT building_gear_assemblyst
  static const struct_field_info building_gear_assemblyst_fields[] = {
    { FLD(SUBSTRUCT, machine), &machine_info::_identity },
    { FLD(SUBSTRUCT, gear_flags), TID(building_gear_assemblyst::T_gear_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_gear_assemblyst::_identity(sizeof(building_gear_assemblyst), &allocator_fn<building_gear_assemblyst>, "building_gear_assemblyst",NULL,&building_actual::_identity,building_gear_assemblyst_fields);
  #define CUR_STRUCT building_grate_floorst
  static const struct_field_info building_grate_floorst_fields[] = {
    { FLD(SUBSTRUCT, gate_flags), TID(gate_flags) },
    { FLD(PRIMITIVE, timer), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_grate_floorst::_identity(sizeof(building_grate_floorst), &allocator_fn<building_grate_floorst>, "building_grate_floorst",NULL,&building_actual::_identity,building_grate_floorst_fields);
  #define CUR_STRUCT building_grate_wallst
  static const struct_field_info building_grate_wallst_fields[] = {
    { FLD(SUBSTRUCT, gate_flags), TID(gate_flags) },
    { FLD(PRIMITIVE, timer), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_grate_wallst::_identity(sizeof(building_grate_wallst), &allocator_fn<building_grate_wallst>, "building_grate_wallst",NULL,&building_actual::_identity,building_grate_wallst_fields);
  #define CUR_STRUCT building_hatchst
  static const struct_field_info building_hatchst_fields[] = {
    { FLD(SUBSTRUCT, door_flags), TID(door_flags) },
    { FLD(PRIMITIVE, close_timer), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_hatchst::_identity(sizeof(building_hatchst), &allocator_fn<building_hatchst>, "building_hatchst",NULL,&building_actual::_identity,building_hatchst_fields);
  #define CUR_STRUCT building_hivest
  static const struct_field_info building_hivest_fields[] = {
    { FLD(SUBSTRUCT, hive_flags), TID(hive_flags) },
    { FLD(PRIMITIVE, split_timer), TID(int32_t) },
    { FLD(PRIMITIVE, activity_timer), TID(int32_t) },
    { FLD(PRIMITIVE, install_timer), TID(int32_t) },
    { FLD(PRIMITIVE, gather_timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_hivest::_identity(sizeof(building_hivest), &allocator_fn<building_hivest>, "building_hivest",NULL,&building_actual::_identity,building_hivest_fields);
  #define CUR_STRUCT building_nest_boxst
  static const struct_field_info building_nest_boxst_fields[] = {
    { FLD(PRIMITIVE, claimed_by), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_nest_boxst::_identity(sizeof(building_nest_boxst), &allocator_fn<building_nest_boxst>, "building_nest_boxst",NULL,&building_actual::_identity,building_nest_boxst_fields);
  virtual_identity building_nestst::_identity(sizeof(building_nestst), &allocator_fn<building_nestst>, "building_nestst",NULL,&building_actual::_identity,NULL);
  #define CUR_STRUCT building_road_dirtst
  static const struct_field_info building_road_dirtst_fields[] = {
    { FLD(PRIMITIVE, material_amount), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_road_dirtst::_identity(sizeof(building_road_dirtst), &allocator_fn<building_road_dirtst>, "building_road_dirtst",NULL,&building_roadst::_identity,building_road_dirtst_fields);
  #define CUR_STRUCT building_road_pavedst
  static const struct_field_info building_road_pavedst_fields[] = {
    { FLD(PRIMITIVE, material_amount), TID(int32_t) },
    { FLD(PRIMITIVE, terrain_purge_timer), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_road_pavedst::_identity(sizeof(building_road_pavedst), &allocator_fn<building_road_pavedst>, "building_road_pavedst",NULL,&building_roadst::_identity,building_road_pavedst_fields);
  virtual_identity building_roadst::_identity(sizeof(building_roadst), &allocator_fn<building_roadst>, "building_roadst",NULL,&building_actual::_identity,NULL);
  #define CUR_STRUCT building_rollersst
  static const struct_field_info building_rollersst_fields[] = {
    { FLD(SUBSTRUCT, machine), &machine_info::_identity },
    { FLD(PRIMITIVE, direction), identity_traits<enum_field<df::screw_pump_direction,int32_t> >::get() },
    { FLD(PRIMITIVE, speed), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_rollersst::_identity(sizeof(building_rollersst), &allocator_fn<building_rollersst>, "building_rollersst",NULL,&building_actual::_identity,building_rollersst_fields);
  #define CUR_STRUCT building_screw_pumpst
  static const struct_field_info building_screw_pumpst_fields[] = {
    { FLD(SUBSTRUCT, machine), &machine_info::_identity },
    { FLD(PRIMITIVE, pump_energy), TID(uint8_t) },
    { FLD(PRIMITIVE, direction), TID(screw_pump_direction) },
    { FLD(PRIMITIVE, pump_manually), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_screw_pumpst::_identity(sizeof(building_screw_pumpst), &allocator_fn<building_screw_pumpst>, "building_screw_pumpst",NULL,&building_actual::_identity,building_screw_pumpst_fields);
  #define CUR_STRUCT building_shopst
  static const struct_field_info building_shopst_fields[] = {
    { FLD(POINTER, owner), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD(SUBSTRUCT, shop_flags), TID(building_shopst::T_shop_flags) },
    { FLD(PRIMITIVE, type), TID(shop_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_shopst::_identity(sizeof(building_shopst), &allocator_fn<building_shopst>, "building_shopst",NULL,&building_actual::_identity,building_shopst_fields);
  #define CUR_STRUCT building_siegeenginest
  static const struct_field_info building_siegeenginest_fields[] = {
    { FLD(PRIMITIVE, type), TID(siegeengine_type) },
    { FLD(PRIMITIVE, facing), TID(building_siegeenginest::T_facing) },
    { FLD(PRIMITIVE, action), TID(building_siegeenginest::T_action) },
    { FLD(PRIMITIVE, fire_timer), TID(int8_t) },
    { FLD(PRIMITIVE, fill_timer), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_siegeenginest::_identity(sizeof(building_siegeenginest), &allocator_fn<building_siegeenginest>, "building_siegeenginest",NULL,&building_actual::_identity,building_siegeenginest_fields);
  #define CUR_STRUCT building_slabst
  static const struct_field_info building_slabst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_slabst::_identity(sizeof(building_slabst), &allocator_fn<building_slabst>, "building_slabst",NULL,&building_actual::_identity,building_slabst_fields);
  #define CUR_STRUCT building_squad_use
  static const struct_field_info building_squad_use_fields[] = {
    { FLD(PRIMITIVE, squad_id), TID(int32_t) },
    { FLD(SUBSTRUCT, mode), TID(squad_use_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity building_squad_use::_identity(sizeof(building_squad_use), &allocator_fn<building_squad_use>, NULL, "building_squad_use",NULL,building_squad_use_fields);
  #define CUR_STRUCT building_statuest
  static const struct_field_info building_statuest_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_statuest::_identity(sizeof(building_statuest), &allocator_fn<building_statuest>, "building_statuest",NULL,&building_actual::_identity,building_statuest_fields);
  #define CUR_STRUCT building_stockpilest
  static const struct_field_info building_stockpilest_fields[] = {
    { FLD(SUBSTRUCT, settings), &stockpile_settings::_identity },
    { FLD(PRIMITIVE, max_barrels), TID(int16_t) },
    { FLD(PRIMITIVE, max_bins), TID(int16_t) },
    { FLD(PRIMITIVE, max_wheelbarrows), TID(int16_t) },
    { FLD(CONTAINER, container_type), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, container_item_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, container_x), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, container_y), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, links), &stockpile_links::_identity },
    { FLD(PRIMITIVE, use_links_only), TID(int32_t) },
    { FLD(PRIMITIVE, stockpile_number), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, linked_stops), identity_traits<df::hauling_stop >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_stockpilest::_identity(sizeof(building_stockpilest), &allocator_fn<building_stockpilest>, "building_stockpilest",NULL,&building::_identity,building_stockpilest_fields);
  #define CUR_STRUCT building_supportst
  static const struct_field_info building_supportst_fields[] = {
    { FLD(SUBSTRUCT, support_flags), TID(building_supportst::T_support_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_supportst::_identity(sizeof(building_supportst), &allocator_fn<building_supportst>, "building_supportst",NULL,&building_actual::_identity,building_supportst_fields);
  #define CUR_STRUCT building_tablest
  static const struct_field_info building_tablest_fields[] = {
    { FLD(SUBSTRUCT, table_flags), TID(building_tablest::T_table_flags) },
    { FLD(SUBSTRUCT, users), &building_users::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_tablest::_identity(sizeof(building_tablest), &allocator_fn<building_tablest>, "building_tablest",NULL,&building_actual::_identity,building_tablest_fields);
  #define CUR_STRUCT building_traction_benchst
  static const struct_field_info building_traction_benchst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(SUBSTRUCT, users), &building_users::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_traction_benchst::_identity(sizeof(building_traction_benchst), &allocator_fn<building_traction_benchst>, "building_traction_benchst",NULL,&building_actual::_identity,building_traction_benchst_fields);
  #define CUR_STRUCT building_tradedepotst
  static const struct_field_info building_tradedepotst_fields[] = {
    { FLD(SUBSTRUCT, trade_flags), TID(building_tradedepotst::T_trade_flags) },
    { FLD(PRIMITIVE, accessible), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_tradedepotst::_identity(sizeof(building_tradedepotst), &allocator_fn<building_tradedepotst>, "building_tradedepotst",NULL,&building_actual::_identity,building_tradedepotst_fields);
  #define CUR_STRUCT building_trapst
  static const struct_field_info building_trapst_fields[] = {
    { FLD(PRIMITIVE, trap_type), TID(trap_type) },
    { FLD(PRIMITIVE, state), TID(uint8_t) },
    { FLD(PRIMITIVE, ready_timeout), TID(int16_t) },
    { FLD(PRIMITIVE, fill_timer), TID(int16_t) },
    { FLD(SUBSTRUCT, stop_flags), TID(building_trapst::T_stop_flags) },
    { FLD(STL_VECTOR_PTR, linked_mechanisms), identity_traits<df::item >::get(), 0, NULL },
    { FLD(CONTAINER, observed_by_civs), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, profile), &workshop_profile::_identity },
    { FLD(SUBSTRUCT, links), &stockpile_links::_identity },
    { FLD(SUBSTRUCT, plate_info), &pressure_plate_info::_identity },
    { FLD(PRIMITIVE, friction), TID(int32_t) },
    { FLD(PRIMITIVE, use_dump), TID(int32_t) },
    { FLD(PRIMITIVE, dump_x_shift), TID(int32_t) },
    { FLD(PRIMITIVE, dump_y_shift), TID(int32_t) },
    { FLD(PRIMITIVE, stop_trigger_timer), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_trapst::_identity(sizeof(building_trapst), &allocator_fn<building_trapst>, "building_trapst",NULL,&building_actual::_identity,building_trapst_fields);
  #define CUR_STRUCT enum_traits<building_type>::attr_entry_type
  static const struct_field_info enum_traits_lT_building_type_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, classname), identity_traits<const char*>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<building_type>::attr_entry_type::_identity(sizeof(enum_traits<building_type>::attr_entry_type), NULL, TID(building_type), "_attr_entry_type", NULL, enum_traits_lT_building_type_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT building_users
  static const struct_field_info building_users_fields[] = {
    { FLD(CONTAINER, unit), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mode), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity building_users::_identity(sizeof(building_users), &allocator_fn<building_users>, NULL, "building_users",NULL,building_users_fields);
  virtual_identity building_wagonst::_identity(sizeof(building_wagonst), &allocator_fn<building_wagonst>, "building_wagonst",NULL,&building_actual::_identity,NULL);
  #define CUR_STRUCT building_water_wheelst
  static const struct_field_info building_water_wheelst_fields[] = {
    { FLD(SUBSTRUCT, machine), &machine_info::_identity },
    { FLD(PRIMITIVE, is_vertical), TID(bool) },
    { FLD(PRIMITIVE, gives_power), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_water_wheelst::_identity(sizeof(building_water_wheelst), &allocator_fn<building_water_wheelst>, "building_water_wheelst",NULL,&building_actual::_identity,building_water_wheelst_fields);
  #define CUR_STRUCT building_weaponrackst
  static const struct_field_info building_weaponrackst_fields[] = {
    { FLD(PRIMITIVE, unk_c0), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, squads), identity_traits<df::building_squad_use >::get(), 0, NULL },
    { FLD(PRIMITIVE, specific_squad), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_weaponrackst::_identity(sizeof(building_weaponrackst), &allocator_fn<building_weaponrackst>, "building_weaponrackst",NULL,&building_actual::_identity,building_weaponrackst_fields);
  #define CUR_STRUCT building_weaponst
  static const struct_field_info building_weaponst_fields[] = {
    { FLD(SUBSTRUCT, gate_flags), TID(gate_flags) },
    { FLD(PRIMITIVE, timer), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_weaponst::_identity(sizeof(building_weaponst), &allocator_fn<building_weaponst>, "building_weaponst",NULL,&building_actual::_identity,building_weaponst_fields);
  #define CUR_STRUCT building_wellst
  static const struct_field_info building_wellst_fields[] = {
    { FLD(SUBSTRUCT, well_flags), TID(building_wellst::T_well_flags) },
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(PRIMITIVE, bucket_z), TID(int16_t) },
    { FLD(PRIMITIVE, bucket_timer), TID(int8_t) },
    { FLD(PRIMITIVE, check_water_timer), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_wellst::_identity(sizeof(building_wellst), &allocator_fn<building_wellst>, "building_wellst",NULL,&building_actual::_identity,building_wellst_fields);
  #define CUR_STRUCT building_windmillst
  static const struct_field_info building_windmillst_fields[] = {
    { FLD(SUBSTRUCT, machine), &machine_info::_identity },
    { FLD(PRIMITIVE, orient_angle), TID(int16_t) },
    { FLD(PRIMITIVE, orient_mode), TID(int16_t) },
    { FLD(PRIMITIVE, is_working), TID(int16_t) },
    { FLD(PRIMITIVE, visual_rotated), TID(bool) },
    { FLD(PRIMITIVE, rotate_timer), TID(int16_t) },
    { FLD(PRIMITIVE, orient_timer), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_windmillst::_identity(sizeof(building_windmillst), &allocator_fn<building_windmillst>, "building_windmillst",NULL,&building_actual::_identity,building_windmillst_fields);
  virtual_identity building_window_gemst::_identity(sizeof(building_window_gemst), &allocator_fn<building_window_gemst>, "building_window_gemst",NULL,&building_windowst::_identity,NULL);
  virtual_identity building_window_glassst::_identity(sizeof(building_window_glassst), &allocator_fn<building_window_glassst>, "building_window_glassst",NULL,&building_windowst::_identity,NULL);
  #define CUR_STRUCT building_windowst
  static const struct_field_info building_windowst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_windowst::_identity(sizeof(building_windowst), &allocator_fn<building_windowst>, "building_windowst",NULL,&building_actual::_identity,building_windowst_fields);
  #define CUR_STRUCT building_workshopst
  static const struct_field_info building_workshopst_fields[] = {
    { FLD(PRIMITIVE, type), TID(workshop_type) },
    { FLD(SUBSTRUCT, profile), &workshop_profile::_identity },
    { FLD(SUBSTRUCT, links), &stockpile_links::_identity },
    { FLD(SUBSTRUCT, machine), &machine_info::_identity },
    { FLD(PRIMITIVE, custom_type), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity building_workshopst::_identity(sizeof(building_workshopst), &allocator_fn<building_workshopst>, "building_workshopst",NULL,&building_actual::_identity,building_workshopst_fields);
  #define CUR_STRUCT enum_traits<buildings_other_id>::attr_entry_type
  static const struct_field_info enum_traits_lT_buildings_other_id_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, building), identity_traits<df::building_type>::get() },
    { FLD(CONTAINER, generic_building), identity_traits<enum_list_attr<df::building_type>>::get() },
    { FLD(CONTAINER, workshop), identity_traits<enum_list_attr<df::workshop_type>>::get() },
    { FLD(CONTAINER, furnace), identity_traits<enum_list_attr<df::furnace_type>>::get() },
    { FLD(CONTAINER, civzone), identity_traits<enum_list_attr<df::civzone_type>>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<buildings_other_id>::attr_entry_type::_identity(sizeof(enum_traits<buildings_other_id>::attr_entry_type), NULL, TID(buildings_other_id), "_attr_entry_type", NULL, enum_traits_lT_buildings_other_id_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT burrow
  static const struct_field_info burrow_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, tile), TID(uint8_t) },
    { FLD(PRIMITIVE, fg_color), TID(int16_t) },
    { FLD(PRIMITIVE, bg_color), TID(int16_t) },
    { FLD(CONTAINER, block_x), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, block_y), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, block_z), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, units), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity burrow::_identity(sizeof(burrow), &allocator_fn<burrow>, NULL, "burrow",NULL,burrow_fields);
  #define CUR_STRUCT campfire
  static const struct_field_info campfire_fields[] = {
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity campfire::_identity(sizeof(campfire), &allocator_fn<campfire>, NULL, "campfire",NULL,campfire_fields);
  #define CUR_STRUCT caravan_state
  static const struct_field_info caravan_state_fields[] = {
    { FLD(PRIMITIVE, total_capacity), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, trade_state), TID(int8_t) },
    { FLD(PRIMITIVE, depot_notified), TID(int8_t) },
    { FLD(PRIMITIVE, time_remaining), TID(int16_t) },
    { FLD(PRIMITIVE, entity), TID(int32_t) },
    { FLD(SUBSTRUCT, activity_stats), &entity_activity_statistics::_identity },
    { FLD(SUBSTRUCT, flags), TID(caravan_state::T_flags) },
    { FLD(PRIMITIVE, import_value), TID(int32_t) },
    { FLD(PRIMITIVE, export_value_total), TID(int32_t) },
    { FLD(PRIMITIVE, export_value_personal), TID(int32_t) },
    { FLD(PRIMITIVE, offer_value), TID(int32_t) },
    { FLD(CONTAINER, animals), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(POINTER, sell_prices), identity_traits<df::entity_sell_prices >::get(), 0, NULL },
    { FLD(POINTER, buy_prices), identity_traits<df::entity_buy_prices >::get(), 0, NULL },
    { FLD(CONTAINER, goods), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(POINTER, anon_3), NULL, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caravan_state::_identity(sizeof(caravan_state), &allocator_fn<caravan_state>, NULL, "caravan_state",NULL,caravan_state_fields);
  #define CUR_STRUCT caste_attack
  static const struct_field_info caste_attack_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, verb_3rd), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, verb_2nd), identity_traits<std::string >::get() },
    { FLD(SUBSTRUCT, flags), TID(caste_attack::T_flags) },
    { FLD(CONTAINER, specialattack_type), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, specialattack_mat_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, specialattack_mat_index), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, specialattack_mat_state), identity_traits<std::vector<df::matter_state > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, specialattack_temp_mat), identity_traits<std::vector<std::string* > >::get(), 3, NULL },
    { FLD(CONTAINER, specialattack_min), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, specialattack_max), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, contact_perc), TID(int32_t) },
    { FLD(PRIMITIVE, penetration_perc), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1), TID(int16_t) },
    { FLD(PRIMITIVE, unk_v40_2), TID(int16_t) },
    { FLD(CONTAINER, body_part_idx), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, tissue_layer_idx), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, skill), TID(job_skill) },
    { FLD(PRIMITIVE, velocity_modifier), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, specialattack_interaction_tmp_name), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, specialattack_interaction_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_v40_3), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_4), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_attack::_identity(sizeof(caste_attack), &allocator_fn<caste_attack>, NULL, "caste_attack",NULL,caste_attack_fields);
  #define CUR_STRUCT caste_body_info::T_interactions::T_unk
  static const struct_field_info caste_body_info_doT_Dot_T_interactions_doT_Dot_T_unk_fields[] = {
    { FLD(STL_VECTOR_PTR, bp_required_type), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bp_required_name), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_2), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, material_str0), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, material_str1), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, material_str2), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, material_breath), TID(breath_attack_type) },
    { FLD(PRIMITIVE, verb_2nd), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, verb_3rd), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, verb_ext), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_3), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_4), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_5), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_6), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, interaction_type), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(CONTAINER, usage_hint), identity_traits<std::vector<df::interaction_source_usage_hint > >::get(), 0, NULL },
    { FLD(CONTAINER, location_hint), identity_traits<std::vector<df::interaction_effect_location_hint > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, anon_9), NULL, 0, NULL },
    { FLD(CONTAINER, anon_10), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_11), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_12), NULL, 0, NULL },
    { FLD(CONTAINER, anon_13), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_14), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_15), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, adv_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, wait_period), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_body_info::T_interactions::T_unk::_identity(sizeof(caste_body_info::T_interactions::T_unk), &allocator_fn<caste_body_info::T_interactions::T_unk>, &caste_body_info::T_interactions::_identity, "T_unk",NULL,caste_body_info_doT_Dot_T_interactions_doT_Dot_T_unk_fields);
  #define CUR_STRUCT caste_body_info::T_interactions
  static const struct_field_info caste_body_info_doT_Dot_T_interactions_fields[] = {
    { FLD(PRIMITIVE, type), TID(int32_t) },
    { FLD(SUBSTRUCT, unk), &caste_body_info::T_interactions::T_unk::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_body_info::T_interactions::_identity(sizeof(caste_body_info::T_interactions), &allocator_fn<caste_body_info::T_interactions>, &caste_body_info::_identity, "T_interactions",NULL,caste_body_info_doT_Dot_T_interactions_fields);
  #define CUR_STRUCT caste_body_info::T_extra_butcher_objects
  static const struct_field_info caste_body_info_doT_Dot_T_extra_butcher_objects_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_5), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_6), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_7), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_8), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_9), TID(int16_t) },
    { FLD(PRIMITIVE, anon_10), TID(int16_t) },
    { FLD(PRIMITIVE, anon_11), TID(int16_t) },
    { FLD(PRIMITIVE, anon_12), TID(int32_t) },
    { FLD(PRIMITIVE, anon_13), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_body_info::T_extra_butcher_objects::_identity(sizeof(caste_body_info::T_extra_butcher_objects), &allocator_fn<caste_body_info::T_extra_butcher_objects>, &caste_body_info::_identity, "T_extra_butcher_objects",NULL,caste_body_info_doT_Dot_T_extra_butcher_objects_fields);
  #define CUR_STRUCT caste_body_info
  static const struct_field_info caste_body_info_fields[] = {
    { FLD(STL_VECTOR_PTR, body_parts), identity_traits<df::body_part_raw >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, attacks), identity_traits<df::caste_attack >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, interactions), &caste_body_info::T_interactions::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, extra_butcher_objects), &caste_body_info::T_extra_butcher_objects::_identity, 0, NULL },
    { FLD(PRIMITIVE, total_relsize), TID(int32_t) },
    { FLD(CONTAINER, layer_part), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, layer_idx), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, numbered_masks), identity_traits<std::vector<uint32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, layer_nonsolid), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, nonsolid_layers), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, flags), TID(caste_body_info::T_flags) },
    { FLD(STATIC_ARRAY, gait_info), identity_traits<std::vector<df::gait_info* > >::get(), 5, TID(gait_type) },
    { FLD(SUBSTRUCT, materials), &material_vec_ref::_identity },
    { FLD(PRIMITIVE, fraction_total), TID(int32_t) },
    { FLD(PRIMITIVE, fraction_base), TID(int32_t) },
    { FLD(PRIMITIVE, fraction_fat), TID(int32_t) },
    { FLD(PRIMITIVE, fraction_muscle), TID(int32_t) },
    { FLD(STATIC_ARRAY, unk_v40_2), identity_traits<int32_t >::get(), 11, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_body_info::_identity(sizeof(caste_body_info), &allocator_fn<caste_body_info>, NULL, "caste_body_info",NULL,caste_body_info_fields);
  #define CUR_STRUCT caste_clothing_item
  static const struct_field_info caste_clothing_item_fields[] = {
    { FLD(PRIMITIVE, body_part_id), TID(int16_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(STATIC_ARRAY, item), identity_traits<df::item* >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, unk_14), identity_traits<int32_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, size), identity_traits<int32_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, permit), identity_traits<int32_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, unk_38), identity_traits<int32_t >::get(), 3, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_clothing_item::_identity(sizeof(caste_clothing_item), &allocator_fn<caste_clothing_item>, NULL, "caste_clothing_item",NULL,caste_clothing_item_fields);
  #define CUR_STRUCT caste_raw::T_misc
  static const struct_field_info caste_raw_doT_Dot_T_misc_fields[] = {
    { FLD(PRIMITIVE, litter_size_min), TID(int16_t) },
    { FLD(PRIMITIVE, litter_size_max), TID(int16_t) },
    { FLD(PRIMITIVE, penetratepower), TID(int16_t) },
    { FLD(PRIMITIVE, vermin_bite_chance), TID(int16_t) },
    { FLD(PRIMITIVE, grasstrample), TID(int16_t) },
    { FLD(PRIMITIVE, buildingdestroyer), TID(int16_t) },
    { FLD(PRIMITIVE, itemcorpse_itemtype), TID(item_type) },
    { FLD(PRIMITIVE, itemcorpse_itemsubtype), TID(int16_t) },
    { FLD(PRIMITIVE, itemcorpse_materialtype), TID(int16_t) },
    { FLD(PRIMITIVE, itemcorpse_materialindex), TID(int16_t) },
    { FLD(PRIMITIVE, itemcorpse_quality), TID(int16_t) },
    { FLD(STATIC_ARRAY, remains_color), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(PRIMITIVE, difficulty), TID(int16_t) },
    { FLD(STATIC_ARRAY, caste_glowcolor), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(PRIMITIVE, beach_frequency), TID(int16_t) },
    { FLD(PRIMITIVE, clutch_size_min), TID(int16_t) },
    { FLD(PRIMITIVE, clutch_size_max), TID(int16_t) },
    { FLD(PRIMITIVE, vision_arc_min), TID(int16_t) },
    { FLD(PRIMITIVE, vision_arc_max), TID(int16_t) },
    { FLD(PRIMITIVE, speed), TID(int32_t) },
    { FLD(PRIMITIVE, modvalue), TID(int32_t) },
    { FLD(PRIMITIVE, petvalue), TID(int32_t) },
    { FLD(PRIMITIVE, milkable), TID(int32_t) },
    { FLD(PRIMITIVE, viewrange), TID(int32_t) },
    { FLD(PRIMITIVE, maxage_min), TID(int32_t) },
    { FLD(PRIMITIVE, maxage_max), TID(int32_t) },
    { FLD(PRIMITIVE, baby_age), TID(int32_t) },
    { FLD(PRIMITIVE, child_age), TID(int32_t) },
    { FLD(PRIMITIVE, swim_speed), TID(int32_t) },
    { FLD(PRIMITIVE, trade_capacity), TID(int32_t) },
    { FLD(PRIMITIVE, unk4), TID(int32_t) },
    { FLD(PRIMITIVE, pop_ratio), TID(int32_t) },
    { FLD(PRIMITIVE, adult_size), TID(int32_t) },
    { FLD(PRIMITIVE, bone_mat), TID(int32_t) },
    { FLD(PRIMITIVE, bone_matidx), TID(int32_t) },
    { FLD(PRIMITIVE, fish_mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, egg_mat_index), TID(int32_t) },
    { FLD(STATIC_ARRAY, attack_trigger), identity_traits<int32_t >::get(), 3, NULL },
    { FLD(PRIMITIVE, egg_size), TID(int32_t) },
    { FLD(PRIMITIVE, grazer), TID(int32_t) },
    { FLD(PRIMITIVE, petvalue_divisor), TID(int32_t) },
    { FLD(PRIMITIVE, prone_to_rage), TID(int32_t) },
    { FLD(STATIC_ARRAY, unk6), identity_traits<int32_t >::get(), 29, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_raw::T_misc::_identity(sizeof(caste_raw::T_misc), &allocator_fn<caste_raw::T_misc>, &caste_raw::_identity, "T_misc",NULL,caste_raw_doT_Dot_T_misc_fields);
  #define CUR_STRUCT caste_raw::T_personality
  static const struct_field_info caste_raw_doT_Dot_T_personality_fields[] = {
    { FLD(STATIC_ARRAY, a), identity_traits<int16_t >::get(), 50, TID(personality_facet_type) },
    { FLD(STATIC_ARRAY, b), identity_traits<int16_t >::get(), 50, TID(personality_facet_type) },
    { FLD(STATIC_ARRAY, c), identity_traits<int16_t >::get(), 50, TID(personality_facet_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_raw::T_personality::_identity(sizeof(caste_raw::T_personality), &allocator_fn<caste_raw::T_personality>, &caste_raw::_identity, "T_personality",NULL,caste_raw_doT_Dot_T_personality_fields);
  typedef int32_t T_caste_raw_doT_Dot_T_attributes_fields[7];
  typedef int32_t T_caste_raw_doT_Dot_T_attributes_fields_1[7];
  typedef int32_t T_caste_raw_doT_Dot_T_attributes_fields_2[4];
  typedef int32_t T_caste_raw_doT_Dot_T_attributes_fields_3[4];
  #define CUR_STRUCT caste_raw::T_attributes
  static const struct_field_info caste_raw_doT_Dot_T_attributes_fields[] = {
    { FLD(STATIC_ARRAY, phys_att_range), identity_traits<T_caste_raw_doT_Dot_T_attributes_fields >::get(), 6, TID(physical_attribute_type) },
    { FLD(STATIC_ARRAY, ment_att_range), identity_traits<T_caste_raw_doT_Dot_T_attributes_fields_1 >::get(), 13, TID(mental_attribute_type) },
    { FLD(STATIC_ARRAY, phys_att_rates), identity_traits<T_caste_raw_doT_Dot_T_attributes_fields_2 >::get(), 6, TID(physical_attribute_type) },
    { FLD(STATIC_ARRAY, ment_att_rates), identity_traits<T_caste_raw_doT_Dot_T_attributes_fields_3 >::get(), 13, TID(mental_attribute_type) },
    { FLD(STATIC_ARRAY, phys_att_cap_perc), identity_traits<int32_t >::get(), 6, TID(physical_attribute_type) },
    { FLD(STATIC_ARRAY, ment_att_cap_perc), identity_traits<int32_t >::get(), 13, TID(mental_attribute_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_raw::T_attributes::_identity(sizeof(caste_raw::T_attributes), &allocator_fn<caste_raw::T_attributes>, &caste_raw::_identity, "T_attributes",NULL,caste_raw_doT_Dot_T_attributes_fields);
  #define CUR_STRUCT caste_raw::T_bp_appearance
  static const struct_field_info caste_raw_doT_Dot_T_bp_appearance_fields[] = {
    { FLD(STL_VECTOR_PTR, modifiers), identity_traits<df::bp_appearance_modifier >::get(), 0, NULL },
    { FLD(CONTAINER, modifier_idx), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, part_idx), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, layer_idx), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, style_part_idx), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, style_layer_idx), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, style_list_idx), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_raw::T_bp_appearance::_identity(sizeof(caste_raw::T_bp_appearance), &allocator_fn<caste_raw::T_bp_appearance>, &caste_raw::_identity, "T_bp_appearance",NULL,caste_raw_doT_Dot_T_bp_appearance_fields);
  #define CUR_STRUCT caste_raw::T_shearable_tissue_layer
  static const struct_field_info caste_raw_doT_Dot_T_shearable_tissue_layer_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int8_t) },
    { FLD(PRIMITIVE, unk_1), TID(int8_t) },
    { FLD(PRIMITIVE, length), TID(int32_t) },
    { FLD(CONTAINER, part_idx), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, layer_idx), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_modifiers_idx), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_raw::T_shearable_tissue_layer::_identity(sizeof(caste_raw::T_shearable_tissue_layer), &allocator_fn<caste_raw::T_shearable_tissue_layer>, &caste_raw::_identity, "T_shearable_tissue_layer",NULL,caste_raw_doT_Dot_T_shearable_tissue_layer_fields);
  #define CUR_STRUCT caste_raw::T_caste_profession_name
  static const struct_field_info caste_raw_doT_Dot_T_caste_profession_name_fields[] = {
    { FLD(STATIC_ARRAY, singular), identity_traits<std::string >::get(), 112, TID(profession) },
    { FLD(STATIC_ARRAY, plural), identity_traits<std::string >::get(), 112, TID(profession) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_raw::T_caste_profession_name::_identity(sizeof(caste_raw::T_caste_profession_name), &allocator_fn<caste_raw::T_caste_profession_name>, &caste_raw::_identity, "T_caste_profession_name",NULL,caste_raw_doT_Dot_T_caste_profession_name_fields);
  #define CUR_STRUCT caste_raw::T_extracts
  static const struct_field_info caste_raw_doT_Dot_T_extracts_fields[] = {
    { FLD(CONTAINER, extract_mat), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, extract_matidx), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, extract_str), identity_traits<std::vector<std::string* > >::get(), 3, NULL },
    { FLD(PRIMITIVE, milkable_mat), TID(int16_t) },
    { FLD(PRIMITIVE, milkable_matidx), TID(int32_t) },
    { FLD(STATIC_ARRAY, milkable_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD(PRIMITIVE, webber_mat), TID(int16_t) },
    { FLD(PRIMITIVE, webber_matidx), TID(int32_t) },
    { FLD(STATIC_ARRAY, webber_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD(PRIMITIVE, vermin_bite_mat), TID(int16_t) },
    { FLD(PRIMITIVE, vermin_bite_matidx), TID(int32_t) },
    { FLD(PRIMITIVE, vermin_bite_chance), TID(int16_t) },
    { FLD(STATIC_ARRAY, vermin_bite_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD(PRIMITIVE, tendons_mat), TID(int16_t) },
    { FLD(PRIMITIVE, tendons_matidx), TID(int32_t) },
    { FLD(STATIC_ARRAY, tendons_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD(PRIMITIVE, tendons_heal), TID(int32_t) },
    { FLD(PRIMITIVE, ligaments_mat), TID(int16_t) },
    { FLD(PRIMITIVE, ligaments_matidx), TID(int32_t) },
    { FLD(STATIC_ARRAY, ligaments_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD(PRIMITIVE, ligaments_heal), TID(int32_t) },
    { FLD(PRIMITIVE, blood_state), TID(int16_t) },
    { FLD(PRIMITIVE, blood_mat), TID(int16_t) },
    { FLD(PRIMITIVE, blood_matidx), TID(int32_t) },
    { FLD(STATIC_ARRAY, blood_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD(PRIMITIVE, pus_state), TID(int16_t) },
    { FLD(PRIMITIVE, pus_mat), TID(int16_t) },
    { FLD(PRIMITIVE, pus_matidx), TID(int32_t) },
    { FLD(STATIC_ARRAY, pus_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD(CONTAINER, egg_material_mattype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, egg_material_matindex), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, egg_material_str), identity_traits<std::vector<std::string* > >::get(), 3, NULL },
    { FLD(CONTAINER, lays_unusual_eggs_itemtype), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, lays_unusual_eggs_itemsubtype), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, lays_unusual_eggs_mattype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, lays_unusual_eggs_matindex), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, lays_unusual_eggs_str), identity_traits<std::vector<std::string* > >::get(), 5, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_raw::T_extracts::_identity(sizeof(caste_raw::T_extracts), &allocator_fn<caste_raw::T_extracts>, &caste_raw::_identity, "T_extracts",NULL,caste_raw_doT_Dot_T_extracts_fields);
  #define CUR_STRUCT caste_raw::T_secretion
  static const struct_field_info caste_raw_doT_Dot_T_secretion_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, mat_state), TID(matter_state) },
    { FLD(PRIMITIVE, mat_type_str), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, mat_index_str), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_44), identity_traits<std::string >::get() },
    { FLD(CONTAINER, body_part_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, layer_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, cause), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_raw::T_secretion::_identity(sizeof(caste_raw::T_secretion), &allocator_fn<caste_raw::T_secretion>, &caste_raw::_identity, "T_secretion",NULL,caste_raw_doT_Dot_T_secretion_fields);
  typedef int32_t T_caste_raw_doT_Dot_T_unknown2_fields[4];
  #define CUR_STRUCT caste_raw::T_unknown2
  static const struct_field_info caste_raw_doT_Dot_T_unknown2_fields[] = {
    { FLD(STL_VECTOR_PTR, gobble_vermin_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, gobble_vermin_creature_1), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, gobble_vermin_creature_2), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, infect_all), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, infect_local), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk23f), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk23g), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk24_flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(CONTAINER, unk25_flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, armor_sizes), identity_traits<T_caste_raw_doT_Dot_T_unknown2_fields >::get(), 4, NULL },
    { FLD(STATIC_ARRAY, pants_sizes), identity_traits<int32_t >::get(), 4, NULL },
    { FLD(PRIMITIVE, helm_size), TID(int32_t) },
    { FLD(STATIC_ARRAY, shield_sizes), identity_traits<int32_t >::get(), 4, NULL },
    { FLD(STATIC_ARRAY, shoes_sizes), identity_traits<int32_t >::get(), 4, NULL },
    { FLD(STATIC_ARRAY, gloves_sizes), identity_traits<int32_t >::get(), 4, NULL },
    { FLD(SUBSTRUCT, materials), &material_vec_ref::_identity },
    { FLD(CONTAINER, unk_2f20), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_2f30), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_2f40), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_2f50), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_raw::T_unknown2::_identity(sizeof(caste_raw::T_unknown2), &allocator_fn<caste_raw::T_unknown2>, &caste_raw::_identity, "T_unknown2",NULL,caste_raw_doT_Dot_T_unknown2_fields);
  typedef int32_t T_caste_raw_fields[118];
  #define CUR_STRUCT caste_raw
  static const struct_field_info caste_raw_fields[] = {
    { FLD(PRIMITIVE, caste_id), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, caste_name), identity_traits<std::string >::get(), 3, NULL },
    { FLD(PRIMITIVE, vermin_bite_txt), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, gnawer_txt), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, baby_name), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, child_name), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, itemcorpse_str), identity_traits<std::string >::get(), 5, NULL },
    { FLD(STATIC_ARRAY, remains), identity_traits<std::string >::get(), 2, NULL },
    { FLD(PRIMITIVE, description), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, mannerisms), identity_traits<std::string >::get(), 17, NULL },
    { FLD(PRIMITIVE, caste_tile), TID(uint8_t) },
    { FLD(PRIMITIVE, caste_soldier_tile), TID(uint8_t) },
    { FLD(PRIMITIVE, caste_alttile), TID(uint8_t) },
    { FLD(PRIMITIVE, caste_soldier_alttile), TID(uint8_t) },
    { FLD(PRIMITIVE, caste_glowtile), TID(uint8_t) },
    { FLD(PRIMITIVE, homeotherm), TID(uint16_t) },
    { FLD(PRIMITIVE, min_temp), TID(uint16_t) },
    { FLD(PRIMITIVE, max_temp), TID(uint16_t) },
    { FLD(PRIMITIVE, fixed_temp), TID(uint16_t) },
    { FLD(STATIC_ARRAY, caste_color), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(SUBSTRUCT, misc), &caste_raw::T_misc::_identity },
    { FLD(SUBSTRUCT, personality), &caste_raw::T_personality::_identity },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::caste_raw_flags> >::get(), 0, TID(caste_raw_flags) },
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(SUBSTRUCT, body_info), &caste_body_info::_identity },
    { FLD(CONTAINER, caste_speech_1), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, caste_speech_2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, skill_rates), identity_traits<T_caste_raw_fields >::get(), 4, NULL },
    { FLD(SUBSTRUCT, attributes), &caste_raw::T_attributes::_identity },
    { FLD(PRIMITIVE, gender), TID(int8_t) },
    { FLD(STATIC_ARRAY, orientation_male), identity_traits<int32_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, orientation_female), identity_traits<int32_t >::get(), 3, NULL },
    { FLD(CONTAINER, body_size_1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, body_size_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, body_appearance_modifiers), identity_traits<df::body_appearance_modifier >::get(), 0, NULL },
    { FLD(SUBSTRUCT, bp_appearance), &caste_raw::T_bp_appearance::_identity },
    { FLD(STL_VECTOR_PTR, color_modifiers), identity_traits<df::color_modifier_raw >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, tissue_styles), identity_traits<df::tissue_style_raw >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, shearable_tissue_layer), &caste_raw::T_shearable_tissue_layer::_identity, 0, NULL },
    { FLD(STATIC_ARRAY, unk16a), identity_traits<std::vector<void* > >::get(), 4, NULL },
    { FLD(STATIC_ARRAY, unk16b), identity_traits<std::vector<void* > >::get(), 4, NULL },
    { FLD(STATIC_ARRAY, unk18), identity_traits<int32_t >::get(), 2, NULL },
    { FLD(CONTAINER, natural_skill_id), identity_traits<std::vector<df::job_skill > >::get(), 0, NULL },
    { FLD(CONTAINER, natural_skill_exp), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, natural_skill_lvl), identity_traits<std::vector<df::skill_rating > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, caste_profession_name), &caste_raw::T_caste_profession_name::_identity },
    { FLD(SUBSTRUCT, extracts), &caste_raw::T_extracts::_identity },
    { FLD(STL_VECTOR_PTR, secretion), &caste_raw::T_secretion::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, creature_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(SUBSTRUCT, unknown2), &caste_raw::T_unknown2::_identity },
    { FLD(STATIC_ARRAY, habit_num), identity_traits<int32_t >::get(), 2, NULL },
    { FLD(CONTAINER, habit_1), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, habit_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, lair_1), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, lair_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, lair_characteristic_1), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, lair_characteristic_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, lair_hunter_speech), identity_traits<std::vector<void* > >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, unk29), identity_traits<std::vector<void* > >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, specific_food), identity_traits<std::vector<void* > >::get(), 2, NULL },
    { FLD(STL_VECTOR_PTR, sound), NULL, 0, NULL },
    { FLD(CONTAINER, sound_alert), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, sound_peaceful_intermittent), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_1), NULL, 0, NULL },
    { FLD(PRIMITIVE, smell_trigger), TID(int32_t) },
    { FLD(PRIMITIVE, odor_level), TID(int32_t) },
    { FLD(PRIMITIVE, odor_string), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, low_light_vision), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, sense_creature_class_1), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, sense_creature_class_2), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, sense_creature_class_3), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, sense_creature_class_4), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, sense_creature_class_5), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity caste_raw::_identity(sizeof(caste_raw), &allocator_fn<caste_raw>, NULL, "caste_raw",NULL,caste_raw_fields);
  #define CUR_STRUCT cave_column
  static const struct_field_info cave_column_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), TID(int16_t) },
    { FLD(PRIMITIVE, anon_3), TID(int16_t) },
    { FLD(PRIMITIVE, anon_4), TID(int8_t) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity cave_column::_identity(sizeof(cave_column), &allocator_fn<cave_column>, "cave_column","cave_columnst",NULL,cave_column_fields);
  #define CUR_STRUCT cave_column_link
  static const struct_field_info cave_column_link_fields[] = {
    { FLD(POINTER, item), identity_traits<df::cave_column >::get(), 0, NULL },
    { FLD(POINTER, prev), identity_traits<df::cave_column_link >::get(), 0, NULL },
    { FLD(POINTER, next), identity_traits<df::cave_column_link >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity cave_column_link::_identity(sizeof(cave_column_link), &allocator_fn<cave_column_link>, NULL, "cave_column_link",NULL,cave_column_link_fields);
  #define CUR_STRUCT cave_column_rectangle
  static const struct_field_info cave_column_rectangle_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int16_t) },
    { FLD(PRIMITIVE, anon_3), TID(int16_t) },
    { FLD(PRIMITIVE, anon_4), TID(int16_t) },
    { FLD(PRIMITIVE, anon_5), TID(int16_t) },
    { FLD(PRIMITIVE, anon_6), TID(int16_t) },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_8), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_9), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity cave_column_rectangle::_identity(sizeof(cave_column_rectangle), &allocator_fn<cave_column_rectangle>, "cave_column_rectangle","cave_column_rectanglest",NULL,cave_column_rectangle_fields);
  #define CUR_STRUCT coin_batch::T_image_front
  static const struct_field_info coin_batch_doT_Dot_T_image_front_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, subid), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity coin_batch::T_image_front::_identity(sizeof(coin_batch::T_image_front), &allocator_fn<coin_batch::T_image_front>, &coin_batch::_identity, "T_image_front",NULL,coin_batch_doT_Dot_T_image_front_fields);
  #define CUR_STRUCT coin_batch::T_image_back
  static const struct_field_info coin_batch_doT_Dot_T_image_back_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, subid), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity coin_batch::T_image_back::_identity(sizeof(coin_batch::T_image_back), &allocator_fn<coin_batch::T_image_back>, &coin_batch::_identity, "T_image_back",NULL,coin_batch_doT_Dot_T_image_back_fields);
  #define CUR_STRUCT coin_batch
  static const struct_field_info coin_batch_fields[] = {
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, entity), TID(int32_t) },
    { FLD(PRIMITIVE, ruler), TID(int32_t) },
    { FLD(SUBSTRUCT, image_front), &coin_batch::T_image_front::_identity },
    { FLD(SUBSTRUCT, image_back), &coin_batch::T_image_back::_identity },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity coin_batch::_identity(sizeof(coin_batch), &allocator_fn<coin_batch>, NULL, "coin_batch",NULL,coin_batch_fields);
  #define CUR_STRUCT color_modifier_raw
  static const struct_field_info color_modifier_raw_fields[] = {
    { FLD(CONTAINER, pattern_index), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pattern_frequency), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, body_part_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, tissue_layer_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk5), TID(int16_t) },
    { FLD(PRIMITIVE, start_date), TID(int32_t) },
    { FLD(PRIMITIVE, end_date), TID(int32_t) },
    { FLD(PRIMITIVE, unk6), TID(int32_t) },
    { FLD(PRIMITIVE, part), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_6c), TID(int16_t) },
    { FLD(PRIMITIVE, unk_6e), TID(int16_t) },
    { FLD(PRIMITIVE, unk_70), TID(int32_t) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_78), NULL, 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_88), NULL, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity color_modifier_raw::_identity(sizeof(color_modifier_raw), &allocator_fn<color_modifier_raw>, NULL, "color_modifier_raw",NULL,color_modifier_raw_fields);
  #define CUR_STRUCT construction
  static const struct_field_info construction_fields[] = {
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(construction_flags) },
    { FLD(PRIMITIVE, original_tile), TID(tiletype) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity construction::_identity(sizeof(construction), &allocator_fn<construction>, NULL, "construction",NULL,construction_fields);
  #define CUR_STRUCT conversation::T_speech
  static const struct_field_info conversation_doT_Dot_T_speech_fields[] = {
    { FLD(STL_VECTOR_PTR, text), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, speaker), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, fg), TID(int16_t) },
    { FLD(PRIMITIVE, bg), TID(int16_t) },
    { FLD(PRIMITIVE, bright), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity conversation::T_speech::_identity(sizeof(conversation::T_speech), &allocator_fn<conversation::T_speech>, &conversation::_identity, "T_speech",NULL,conversation_doT_Dot_T_speech_fields);
  #define CUR_STRUCT conversation
  static const struct_field_info conversation_fields[] = {
    { FLD(PRIMITIVE, conv_title), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, state), TID(conversation::T_state) },
    { FLD(CONTAINER, talk_choices), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_30), TID(int32_t) },
    { FLD(PRIMITIVE, unk_34), TID(int32_t) },
    { FLD(PRIMITIVE, unk_38), TID(int32_t) },
    { FLD(PRIMITIVE, unk_3c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_40), TID(int32_t) },
    { FLD(PRIMITIVE, unk_44), TID(int32_t) },
    { FLD(PRIMITIVE, unk_48), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_50), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_54), identity_traits<df::nemesis_record >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_64), identity_traits<df::historical_entity >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_74), TID(int8_t) },
    { FLD(PRIMITIVE, unk_78), TID(int32_t) },
    { FLD(PRIMITIVE, unk_7c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_80), TID(int16_t) },
    { FLD(CONTAINER, unk_84), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_94), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_a4), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(POINTER, location), identity_traits<df::building >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_b8), TID(int8_t) },
    { FLD(PRIMITIVE, unk_bc), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, speech), &conversation::T_speech::_identity, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity conversation::_identity(sizeof(conversation), &allocator_fn<conversation>, NULL, "conversation",NULL,conversation_fields);
  #define CUR_STRUCT coord
  static const struct_field_info coord_fields[] = {
    { FLD(PRIMITIVE, x), TID(int16_t) },
    { FLD(PRIMITIVE, y), TID(int16_t) },
    { FLD(PRIMITIVE, z), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity coord::_identity(sizeof(coord), &allocator_fn<coord>, NULL, "coord",NULL,coord_fields);
  #define CUR_STRUCT coord2d
  static const struct_field_info coord2d_fields[] = {
    { FLD(PRIMITIVE, x), TID(int16_t) },
    { FLD(PRIMITIVE, y), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity coord2d::_identity(sizeof(coord2d), &allocator_fn<coord2d>, NULL, "coord2d",NULL,coord2d_fields);
  #define CUR_STRUCT coord2d_path
  static const struct_field_info coord2d_path_fields[] = {
    { FLD(CONTAINER, x), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, y), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity coord2d_path::_identity(sizeof(coord2d_path), &allocator_fn<coord2d_path>, NULL, "coord2d_path",NULL,coord2d_path_fields);
  #define CUR_STRUCT coord_path
  static const struct_field_info coord_path_fields[] = {
    { FLD(CONTAINER, x), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, y), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, z), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity coord_path::_identity(sizeof(coord_path), &allocator_fn<coord_path>, NULL, "coord_path",NULL,coord_path_fields);
  #define CUR_STRUCT enum_traits<craft_material_class>::attr_entry_type
  static const struct_field_info enum_traits_lT_craft_material_class_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, make_skill), identity_traits<df::job_skill>::get() },
    { FLD(PRIMITIVE, improve_skill), identity_traits<df::job_skill>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<craft_material_class>::attr_entry_type::_identity(sizeof(enum_traits<craft_material_class>::attr_entry_type), NULL, TID(craft_material_class), "_attr_entry_type", NULL, enum_traits_lT_craft_material_class_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT creature_graphics_appointment
  static const struct_field_info creature_graphics_appointment_fields[] = {
    { FLD(PRIMITIVE, token), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, texpos), identity_traits<int32_t >::get(), 6, TID(creature_graphics_role) },
    { FLD(STATIC_ARRAY, texpos_gs), identity_traits<int32_t >::get(), 6, TID(creature_graphics_role) },
    { FLD(STATIC_ARRAY, add_color), identity_traits<bool >::get(), 6, TID(creature_graphics_role) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity creature_graphics_appointment::_identity(sizeof(creature_graphics_appointment), &allocator_fn<creature_graphics_appointment>, NULL, "creature_graphics_appointment",NULL,creature_graphics_appointment_fields);
  #define CUR_STRUCT creature_interaction_effect::T_counter_trigger
  static const struct_field_info creature_interaction_effect_doT_Dot_T_counter_trigger_fields[] = {
    { FLD(CONTAINER, counter), identity_traits<std::vector<enum_field<df::misc_trait_type,int32_t> > >::get(), 0, NULL },
    { FLD(CONTAINER, minval), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, maxval), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, required), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity creature_interaction_effect::T_counter_trigger::_identity(sizeof(creature_interaction_effect::T_counter_trigger), &allocator_fn<creature_interaction_effect::T_counter_trigger>, &creature_interaction_effect::_identity, "T_counter_trigger",NULL,creature_interaction_effect_doT_Dot_T_counter_trigger_fields);
  #define CUR_STRUCT creature_interaction_effect
  static const struct_field_info creature_interaction_effect_fields[] = {
    { FLD(SUBSTRUCT, flags), TID(creature_interaction_effect_flags) },
    { FLD(PRIMITIVE, prob), TID(int32_t) },
    { FLD(PRIMITIVE, start), TID(int32_t) },
    { FLD(PRIMITIVE, peak), TID(int32_t) },
    { FLD(PRIMITIVE, end), TID(int32_t) },
    { FLD(PRIMITIVE, syn_id), TID(int32_t) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, syn_index), TID(int32_t) },
    { FLD(PRIMITIVE, moon_phase_min), TID(int32_t) },
    { FLD(PRIMITIVE, moon_phase_max), TID(int32_t) },
    { FLD(SUBSTRUCT, counter_trigger), &creature_interaction_effect::T_counter_trigger::_identity },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, clone) },
    { METHOD(OBJ_METHOD, doAction) },
    { METHOD(OBJ_METHOD, isUntargeted) },
    { METHOD(OBJ_METHOD, getTargetModes) },
    { METHOD(OBJ_METHOD, getTargetKeys) },
    { METHOD(OBJ_METHOD, getTargetTissues) },
    { METHOD(OBJ_METHOD, checkAddFlag1) },
    { METHOD(OBJ_METHOD, setBodyMatInteractionName) },
    { METHOD(OBJ_METHOD, parseSynAcquireType) },
    { METHOD(OBJ_METHOD, setBodyTransform) },
    { METHOD(OBJ_METHOD, addPeriodic) },
    { METHOD(OBJ_METHOD, addCounterTrigger) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect::_identity(sizeof(creature_interaction_effect), &allocator_fn<creature_interaction_effect>, "creature_interaction_effect","creature_interaction_effectst",NULL,creature_interaction_effect_fields);
  #define CUR_STRUCT creature_interaction_effect_add_simple_flagst
  static const struct_field_info creature_interaction_effect_add_simple_flagst_fields[] = {
    { FLD(SUBSTRUCT, tags1), TID(cie_add_tag_mask1) },
    { FLD(SUBSTRUCT, tags2), TID(cie_add_tag_mask2) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_add_simple_flagst::_identity(sizeof(creature_interaction_effect_add_simple_flagst), &allocator_fn<creature_interaction_effect_add_simple_flagst>, "creature_interaction_effect_add_simple_flagst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_add_simple_flagst_fields);
  #define CUR_STRUCT creature_interaction_effect_bleedingst
  static const struct_field_info creature_interaction_effect_bleedingst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD(SUBSTRUCT, target), &creature_interaction_effect_target::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_bleedingst::_identity(sizeof(creature_interaction_effect_bleedingst), &allocator_fn<creature_interaction_effect_bleedingst>, "creature_interaction_effect_bleedingst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_bleedingst_fields);
  #define CUR_STRUCT creature_interaction_effect_blistersst
  static const struct_field_info creature_interaction_effect_blistersst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD(SUBSTRUCT, target), &creature_interaction_effect_target::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_blistersst::_identity(sizeof(creature_interaction_effect_blistersst), &allocator_fn<creature_interaction_effect_blistersst>, "creature_interaction_effect_blistersst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_blistersst_fields);
  #define CUR_STRUCT creature_interaction_effect_body_mat_interactionst
  static const struct_field_info creature_interaction_effect_body_mat_interactionst_fields[] = {
    { FLD(PRIMITIVE, unk_6c), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_88), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_90), TID(int32_t) },
    { FLD(PRIMITIVE, unk_94), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_body_mat_interactionst::_identity(sizeof(creature_interaction_effect_body_mat_interactionst), &allocator_fn<creature_interaction_effect_body_mat_interactionst>, "creature_interaction_effect_body_mat_interactionst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_body_mat_interactionst_fields);
  #define CUR_STRUCT creature_interaction_effect_body_transformationst
  static const struct_field_info creature_interaction_effect_body_transformationst_fields[] = {
    { FLD(PRIMITIVE, chance), TID(int32_t) },
    { FLD(PRIMITIVE, race_str), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, caste_str), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, race), TID(int32_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_body_transformationst::_identity(sizeof(creature_interaction_effect_body_transformationst), &allocator_fn<creature_interaction_effect_body_transformationst>, "creature_interaction_effect_body_transformationst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_body_transformationst_fields);
  #define CUR_STRUCT creature_interaction_effect_bp_appearance_modifierst
  static const struct_field_info creature_interaction_effect_bp_appearance_modifierst_fields[] = {
    { FLD(PRIMITIVE, unk_6c), TID(int16_t) },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(SUBSTRUCT, target), &creature_interaction_effect_target::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_bp_appearance_modifierst::_identity(sizeof(creature_interaction_effect_bp_appearance_modifierst), &allocator_fn<creature_interaction_effect_bp_appearance_modifierst>, "creature_interaction_effect_bp_appearance_modifierst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_bp_appearance_modifierst_fields);
  #define CUR_STRUCT creature_interaction_effect_bruisingst
  static const struct_field_info creature_interaction_effect_bruisingst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD(SUBSTRUCT, target), &creature_interaction_effect_target::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_bruisingst::_identity(sizeof(creature_interaction_effect_bruisingst), &allocator_fn<creature_interaction_effect_bruisingst>, "creature_interaction_effect_bruisingst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_bruisingst_fields);
  #define CUR_STRUCT creature_interaction_effect_can_do_interactionst
  static const struct_field_info creature_interaction_effect_can_do_interactionst_fields[] = {
    { FLD(CONTAINER, unk_6c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_7c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_8c), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_a8), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_c4), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_v40_1), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_v40_2), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_e0), TID(int16_t) },
    { FLD(STATIC_ARRAY, verb), identity_traits<std::string >::get(), 3, NULL },
    { FLD(PRIMITIVE, unk_138), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_154), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_170), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_18c), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, interaction_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, type_id), TID(int32_t) },
    { FLD(CONTAINER, unk_1c8), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_1d8), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_1e8), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_1ec), NULL, 0, NULL },
    { FLD(CONTAINER, unk_1fc), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_20c), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_21c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_22c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_23c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_24c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, usage_delay), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_can_do_interactionst::_identity(sizeof(creature_interaction_effect_can_do_interactionst), &allocator_fn<creature_interaction_effect_can_do_interactionst>, "creature_interaction_effect_can_do_interactionst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_can_do_interactionst_fields);
  #define CUR_STRUCT creature_interaction_effect_cough_bloodst
  static const struct_field_info creature_interaction_effect_cough_bloodst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_cough_bloodst::_identity(sizeof(creature_interaction_effect_cough_bloodst), &allocator_fn<creature_interaction_effect_cough_bloodst>, "creature_interaction_effect_cough_bloodst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_cough_bloodst_fields);
  #define CUR_STRUCT creature_interaction_effect_display_namest
  static const struct_field_info creature_interaction_effect_display_namest_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_adj), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_display_namest::_identity(sizeof(creature_interaction_effect_display_namest), &allocator_fn<creature_interaction_effect_display_namest>, "creature_interaction_effect_display_namest",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_display_namest_fields);
  #define CUR_STRUCT creature_interaction_effect_display_symbolst
  static const struct_field_info creature_interaction_effect_display_symbolst_fields[] = {
    { FLD(PRIMITIVE, tile), TID(int32_t) },
    { FLD(PRIMITIVE, color), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_display_symbolst::_identity(sizeof(creature_interaction_effect_display_symbolst), &allocator_fn<creature_interaction_effect_display_symbolst>, "creature_interaction_effect_display_symbolst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_display_symbolst_fields);
  #define CUR_STRUCT creature_interaction_effect_dizzinessst
  static const struct_field_info creature_interaction_effect_dizzinessst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_dizzinessst::_identity(sizeof(creature_interaction_effect_dizzinessst), &allocator_fn<creature_interaction_effect_dizzinessst>, "creature_interaction_effect_dizzinessst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_dizzinessst_fields);
  #define CUR_STRUCT creature_interaction_effect_drowsinessst
  static const struct_field_info creature_interaction_effect_drowsinessst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_drowsinessst::_identity(sizeof(creature_interaction_effect_drowsinessst), &allocator_fn<creature_interaction_effect_drowsinessst>, "creature_interaction_effect_drowsinessst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_drowsinessst_fields);
  #define CUR_STRUCT creature_interaction_effect_feverst
  static const struct_field_info creature_interaction_effect_feverst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_feverst::_identity(sizeof(creature_interaction_effect_feverst), &allocator_fn<creature_interaction_effect_feverst>, "creature_interaction_effect_feverst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_feverst_fields);
  #define CUR_STRUCT creature_interaction_effect_flash_symbolst
  static const struct_field_info creature_interaction_effect_flash_symbolst_fields[] = {
    { FLD(STATIC_ARRAY, sym_color), identity_traits<uint8_t >::get(), 4, NULL },
    { FLD(PRIMITIVE, period), TID(int32_t) },
    { FLD(PRIMITIVE, time), TID(int32_t) },
    { FLD(PRIMITIVE, unk_78), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_flash_symbolst::_identity(sizeof(creature_interaction_effect_flash_symbolst), &allocator_fn<creature_interaction_effect_flash_symbolst>, "creature_interaction_effect_flash_symbolst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_flash_symbolst_fields);
  #define CUR_STRUCT creature_interaction_effect_impair_functionst
  static const struct_field_info creature_interaction_effect_impair_functionst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD(SUBSTRUCT, target), &creature_interaction_effect_target::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_impair_functionst::_identity(sizeof(creature_interaction_effect_impair_functionst), &allocator_fn<creature_interaction_effect_impair_functionst>, "creature_interaction_effect_impair_functionst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_impair_functionst_fields);
  #define CUR_STRUCT creature_interaction_effect_material_force_adjustst
  static const struct_field_info creature_interaction_effect_material_force_adjustst_fields[] = {
    { FLD(PRIMITIVE, unk_6c), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_88), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_a4), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, fraction_mul), TID(int32_t) },
    { FLD(PRIMITIVE, fraction_div), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_material_force_adjustst::_identity(sizeof(creature_interaction_effect_material_force_adjustst), &allocator_fn<creature_interaction_effect_material_force_adjustst>, "creature_interaction_effect_material_force_adjustst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_material_force_adjustst_fields);
  #define CUR_STRUCT creature_interaction_effect_ment_att_changest
  static const struct_field_info creature_interaction_effect_ment_att_changest_fields[] = {
    { FLD(STATIC_ARRAY, ment_att_perc), identity_traits<int32_t >::get(), 13, TID(mental_attribute_type) },
    { FLD(STATIC_ARRAY, ment_att_add), identity_traits<int32_t >::get(), 13, TID(mental_attribute_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_ment_att_changest::_identity(sizeof(creature_interaction_effect_ment_att_changest), &allocator_fn<creature_interaction_effect_ment_att_changest>, "creature_interaction_effect_ment_att_changest",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_ment_att_changest_fields);
  #define CUR_STRUCT creature_interaction_effect_nauseast
  static const struct_field_info creature_interaction_effect_nauseast_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_nauseast::_identity(sizeof(creature_interaction_effect_nauseast), &allocator_fn<creature_interaction_effect_nauseast>, "creature_interaction_effect_nauseast",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_nauseast_fields);
  #define CUR_STRUCT creature_interaction_effect_necrosisst
  static const struct_field_info creature_interaction_effect_necrosisst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD(SUBSTRUCT, target), &creature_interaction_effect_target::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_necrosisst::_identity(sizeof(creature_interaction_effect_necrosisst), &allocator_fn<creature_interaction_effect_necrosisst>, "creature_interaction_effect_necrosisst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_necrosisst_fields);
  #define CUR_STRUCT creature_interaction_effect_numbnessst
  static const struct_field_info creature_interaction_effect_numbnessst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD(SUBSTRUCT, target), &creature_interaction_effect_target::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_numbnessst::_identity(sizeof(creature_interaction_effect_numbnessst), &allocator_fn<creature_interaction_effect_numbnessst>, "creature_interaction_effect_numbnessst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_numbnessst_fields);
  #define CUR_STRUCT creature_interaction_effect_oozingst
  static const struct_field_info creature_interaction_effect_oozingst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD(SUBSTRUCT, target), &creature_interaction_effect_target::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_oozingst::_identity(sizeof(creature_interaction_effect_oozingst), &allocator_fn<creature_interaction_effect_oozingst>, "creature_interaction_effect_oozingst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_oozingst_fields);
  #define CUR_STRUCT creature_interaction_effect_painst
  static const struct_field_info creature_interaction_effect_painst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD(SUBSTRUCT, target), &creature_interaction_effect_target::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_painst::_identity(sizeof(creature_interaction_effect_painst), &allocator_fn<creature_interaction_effect_painst>, "creature_interaction_effect_painst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_painst_fields);
  #define CUR_STRUCT creature_interaction_effect_paralysisst
  static const struct_field_info creature_interaction_effect_paralysisst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD(SUBSTRUCT, target), &creature_interaction_effect_target::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_paralysisst::_identity(sizeof(creature_interaction_effect_paralysisst), &allocator_fn<creature_interaction_effect_paralysisst>, "creature_interaction_effect_paralysisst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_paralysisst_fields);
  #define CUR_STRUCT creature_interaction_effect_phys_att_changest
  static const struct_field_info creature_interaction_effect_phys_att_changest_fields[] = {
    { FLD(STATIC_ARRAY, phys_att_perc), identity_traits<int32_t >::get(), 6, TID(physical_attribute_type) },
    { FLD(STATIC_ARRAY, phys_att_add), identity_traits<int32_t >::get(), 6, TID(physical_attribute_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_phys_att_changest::_identity(sizeof(creature_interaction_effect_phys_att_changest), &allocator_fn<creature_interaction_effect_phys_att_changest>, "creature_interaction_effect_phys_att_changest",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_phys_att_changest_fields);
  #define CUR_STRUCT creature_interaction_effect_remove_simple_flagst
  static const struct_field_info creature_interaction_effect_remove_simple_flagst_fields[] = {
    { FLD(SUBSTRUCT, tags1), TID(cie_add_tag_mask1) },
    { FLD(SUBSTRUCT, tags2), TID(cie_add_tag_mask2) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_remove_simple_flagst::_identity(sizeof(creature_interaction_effect_remove_simple_flagst), &allocator_fn<creature_interaction_effect_remove_simple_flagst>, "creature_interaction_effect_remove_simple_flagst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_remove_simple_flagst_fields);
  #define CUR_STRUCT creature_interaction_effect_sense_creature_classst
  static const struct_field_info creature_interaction_effect_sense_creature_classst_fields[] = {
    { FLD(PRIMITIVE, class_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_88), TID(int8_t) },
    { FLD(PRIMITIVE, unk_8a), TID(int16_t) },
    { FLD(PRIMITIVE, unk_8c), TID(int16_t) },
    { FLD(PRIMITIVE, unk_8e), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_sense_creature_classst::_identity(sizeof(creature_interaction_effect_sense_creature_classst), &allocator_fn<creature_interaction_effect_sense_creature_classst>, "creature_interaction_effect_sense_creature_classst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_sense_creature_classst_fields);
  #define CUR_STRUCT creature_interaction_effect_skill_roll_adjustst
  static const struct_field_info creature_interaction_effect_skill_roll_adjustst_fields[] = {
    { FLD(PRIMITIVE, multiplier), TID(int32_t) },
    { FLD(PRIMITIVE, chance), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_skill_roll_adjustst::_identity(sizeof(creature_interaction_effect_skill_roll_adjustst), &allocator_fn<creature_interaction_effect_skill_roll_adjustst>, "creature_interaction_effect_skill_roll_adjustst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_skill_roll_adjustst_fields);
  #define CUR_STRUCT creature_interaction_effect_speed_changest
  static const struct_field_info creature_interaction_effect_speed_changest_fields[] = {
    { FLD(PRIMITIVE, bonus_add), TID(int32_t) },
    { FLD(PRIMITIVE, bonus_perc), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_speed_changest::_identity(sizeof(creature_interaction_effect_speed_changest), &allocator_fn<creature_interaction_effect_speed_changest>, "creature_interaction_effect_speed_changest",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_speed_changest_fields);
  #define CUR_STRUCT creature_interaction_effect_swellingst
  static const struct_field_info creature_interaction_effect_swellingst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD(SUBSTRUCT, target), &creature_interaction_effect_target::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_swellingst::_identity(sizeof(creature_interaction_effect_swellingst), &allocator_fn<creature_interaction_effect_swellingst>, "creature_interaction_effect_swellingst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_swellingst_fields);
  #define CUR_STRUCT creature_interaction_effect_target
  static const struct_field_info creature_interaction_effect_target_fields[] = {
    { FLD(CONTAINER, mode), identity_traits<std::vector<df::creature_interaction_effect_target_mode > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, key), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, tissue), identity_traits<std::string >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity creature_interaction_effect_target::_identity(sizeof(creature_interaction_effect_target), &allocator_fn<creature_interaction_effect_target>, NULL, "creature_interaction_effect_target",NULL,creature_interaction_effect_target_fields);
  #define CUR_STRUCT creature_interaction_effect_unconsciousnessst
  static const struct_field_info creature_interaction_effect_unconsciousnessst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_unconsciousnessst::_identity(sizeof(creature_interaction_effect_unconsciousnessst), &allocator_fn<creature_interaction_effect_unconsciousnessst>, "creature_interaction_effect_unconsciousnessst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_unconsciousnessst_fields);
  #define CUR_STRUCT creature_interaction_effect_vomit_bloodst
  static const struct_field_info creature_interaction_effect_vomit_bloodst_fields[] = {
    { FLD(PRIMITIVE, sev), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity creature_interaction_effect_vomit_bloodst::_identity(sizeof(creature_interaction_effect_vomit_bloodst), &allocator_fn<creature_interaction_effect_vomit_bloodst>, "creature_interaction_effect_vomit_bloodst",NULL,&creature_interaction_effect::_identity,creature_interaction_effect_vomit_bloodst_fields);
  typedef int32_t T_creature_raw_doT_Dot_T_graphics_fields[15];
  typedef int32_t T_creature_raw_doT_Dot_T_graphics_fields_1[15];
  typedef int32_t T_creature_raw_doT_Dot_T_graphics_fields_2[7];
  typedef int32_t T_creature_raw_doT_Dot_T_graphics_fields_3[7];
  typedef int32_t T_creature_raw_doT_Dot_T_graphics_fields_4[112];
  typedef int32_t T_creature_raw_doT_Dot_T_graphics_fields_5[112];
  typedef bool T_creature_raw_doT_Dot_T_graphics_fields_6[15];
  typedef bool T_creature_raw_doT_Dot_T_graphics_fields_7[7];
  typedef bool T_creature_raw_doT_Dot_T_graphics_fields_8[112];
  #define CUR_STRUCT creature_raw::T_graphics
  static const struct_field_info creature_raw_doT_Dot_T_graphics_fields[] = {
    { FLD(STATIC_ARRAY, texpos), identity_traits<int32_t >::get(), 6, TID(creature_graphics_role) },
    { FLD(STATIC_ARRAY, texpos_gs), identity_traits<int32_t >::get(), 6, TID(creature_graphics_role) },
    { FLD(STATIC_ARRAY, entity_link_texpos), identity_traits<T_creature_raw_doT_Dot_T_graphics_fields >::get(), 6, TID(creature_graphics_role) },
    { FLD(STATIC_ARRAY, entity_link_texpos_gs), identity_traits<T_creature_raw_doT_Dot_T_graphics_fields_1 >::get(), 6, TID(creature_graphics_role) },
    { FLD(STATIC_ARRAY, site_link_texpos), identity_traits<T_creature_raw_doT_Dot_T_graphics_fields_2 >::get(), 6, TID(creature_graphics_role) },
    { FLD(STATIC_ARRAY, site_link_texpos_gs), identity_traits<T_creature_raw_doT_Dot_T_graphics_fields_3 >::get(), 6, TID(creature_graphics_role) },
    { FLD(STATIC_ARRAY, profession_texpos), identity_traits<T_creature_raw_doT_Dot_T_graphics_fields_4 >::get(), 6, TID(creature_graphics_role) },
    { FLD(STATIC_ARRAY, profession_texpos_gs), identity_traits<T_creature_raw_doT_Dot_T_graphics_fields_5 >::get(), 6, TID(creature_graphics_role) },
    { FLD(STATIC_ARRAY, add_color), identity_traits<bool >::get(), 6, TID(creature_graphics_role) },
    { FLD(STATIC_ARRAY, entity_link_add_color), identity_traits<T_creature_raw_doT_Dot_T_graphics_fields_6 >::get(), 6, TID(creature_graphics_role) },
    { FLD(STATIC_ARRAY, site_link_add_color), identity_traits<T_creature_raw_doT_Dot_T_graphics_fields_7 >::get(), 6, TID(creature_graphics_role) },
    { FLD(STATIC_ARRAY, profession_add_color), identity_traits<T_creature_raw_doT_Dot_T_graphics_fields_8 >::get(), 6, TID(creature_graphics_role) },
    { FLD(STL_VECTOR_PTR, appointments), identity_traits<df::creature_graphics_appointment >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity creature_raw::T_graphics::_identity(sizeof(creature_raw::T_graphics), &allocator_fn<creature_raw::T_graphics>, &creature_raw::_identity, "T_graphics",NULL,creature_raw_doT_Dot_T_graphics_fields);
  #define CUR_STRUCT creature_raw::T_profession_name
  static const struct_field_info creature_raw_doT_Dot_T_profession_name_fields[] = {
    { FLD(STATIC_ARRAY, singular), identity_traits<std::string >::get(), 112, TID(profession) },
    { FLD(STATIC_ARRAY, plural), identity_traits<std::string >::get(), 112, TID(profession) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity creature_raw::T_profession_name::_identity(sizeof(creature_raw::T_profession_name), &allocator_fn<creature_raw::T_profession_name>, &creature_raw::_identity, "T_profession_name",NULL,creature_raw_doT_Dot_T_profession_name_fields);
  #define CUR_STRUCT creature_raw::T_hive_product
  static const struct_field_info creature_raw_doT_Dot_T_hive_product_fields[] = {
    { FLD(CONTAINER, number), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, time), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, item_type), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, item_subtype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, material), &material_vec_ref::_identity },
    { FLD(STATIC_ARRAY, tmpstr), identity_traits<std::vector<std::string* > >::get(), 5, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity creature_raw::T_hive_product::_identity(sizeof(creature_raw::T_hive_product), &allocator_fn<creature_raw::T_hive_product>, &creature_raw::_identity, "T_hive_product",NULL,creature_raw_doT_Dot_T_hive_product_fields);
  #define CUR_STRUCT creature_raw
  static const struct_field_info creature_raw_fields[] = {
    { FLD(PRIMITIVE, creature_id), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, name), identity_traits<std::string >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, general_baby_name), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, general_child_name), identity_traits<std::string >::get(), 2, NULL },
    { FLD(PRIMITIVE, creature_tile), TID(uint8_t) },
    { FLD(PRIMITIVE, creature_soldier_tile), TID(uint8_t) },
    { FLD(PRIMITIVE, alttile), TID(uint8_t) },
    { FLD(PRIMITIVE, soldier_alttile), TID(uint8_t) },
    { FLD(PRIMITIVE, glowtile), TID(uint8_t) },
    { FLD(PRIMITIVE, temperature1), TID(uint16_t) },
    { FLD(PRIMITIVE, temperature2), TID(uint16_t) },
    { FLD(PRIMITIVE, frequency), TID(int16_t) },
    { FLD(STATIC_ARRAY, population_number), identity_traits<int16_t >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, cluster_number), identity_traits<int16_t >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, triggerable_group), identity_traits<int16_t >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, color), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, glowcolor), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(PRIMITIVE, adultsize), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, prefstring), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, sphere), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, caste), identity_traits<df::caste_raw >::get(), 0, NULL },
    { FLD(CONTAINER, pop_ratio), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::creature_raw_flags> >::get(), 0, TID(creature_raw_flags) },
    { FLD(SUBSTRUCT, graphics), &creature_raw::T_graphics::_identity },
    { FLD(CONTAINER, speech1), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, speech2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, speech3), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, material), identity_traits<df::material >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, tissue), identity_traits<df::tissue >::get(), 0, NULL },
    { FLD(SUBSTRUCT, profession_name), &creature_raw::T_profession_name::_identity },
    { FLD(PRIMITIVE, underground_layer_min), TID(int32_t) },
    { FLD(PRIMITIVE, underground_layer_max), TID(int32_t) },
    { FLD(CONTAINER, modifier_class), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, modifier_num_patterns), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, hive_product), &creature_raw::T_hive_product::_identity },
    { FLD(PRIMITIVE, source_hfid), TID(int32_t) },
    { FLD(PRIMITIVE, next_modifier_id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, raws), identity_traits<std::string >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity creature_raw::_identity(sizeof(creature_raw), &allocator_fn<creature_raw>, NULL, "creature_raw",NULL,creature_raw_fields);
  #define CUR_STRUCT creature_variation
  static const struct_field_info creature_variation_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, cv_convert_tag), identity_traits<df::creature_variation_convert_tag >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, cv_new_tag), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, cv_remove_tag), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, cv_unk_tag), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_v40_1), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_v40_3), identity_traits<std::string >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity creature_variation::_identity(sizeof(creature_variation), &allocator_fn<creature_variation>, NULL, "creature_variation",NULL,creature_variation_fields);
  #define CUR_STRUCT creature_variation_convert_tag
  static const struct_field_info creature_variation_convert_tag_fields[] = {
    { FLD(PRIMITIVE, cvct_master), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, cvct_target), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, cvct_replacement), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_v40_1), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_2), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity creature_variation_convert_tag::_identity(sizeof(creature_variation_convert_tag), &allocator_fn<creature_variation_convert_tag>, NULL, "creature_variation_convert_tag",NULL,creature_variation_convert_tag_fields);
  #define CUR_STRUCT crime::T_punishment
  static const struct_field_info crime_doT_Dot_T_punishment_fields[] = {
    { FLD(PRIMITIVE, hammerstrikes), TID(int32_t) },
    { FLD(PRIMITIVE, prison_time), TID(int32_t) },
    { FLD(PRIMITIVE, give_beating), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity crime::T_punishment::_identity(sizeof(crime::T_punishment), &allocator_fn<crime::T_punishment>, &crime::_identity, "T_punishment",NULL,crime_doT_Dot_T_punishment_fields);
  #define CUR_STRUCT crime::T_anon_1
  static const struct_field_info crime_doT_Dot_T_anon_1_fields[] = {
    { FLD(PRIMITIVE, death_id), TID(int32_t) },
    { FLD(PRIMITIVE, crime_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD(PRIMITIVE, event_year), TID(int32_t) },
    { FLD(PRIMITIVE, event_time), TID(int32_t) },
    { FLD(PRIMITIVE, witness), TID(int32_t) },
    { FLD(PRIMITIVE, accuses), TID(int32_t) },
    { FLD(PRIMITIVE, report_year), TID(int32_t) },
    { FLD(PRIMITIVE, report_time), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity crime::T_anon_1::_identity(sizeof(crime::T_anon_1), &allocator_fn<crime::T_anon_1>, &crime::_identity, "T_anon_1",NULL,crime_doT_Dot_T_anon_1_fields);
  #define CUR_STRUCT crime
  static const struct_field_info crime_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, mode), TID(crime::T_mode) },
    { FLD(SUBSTRUCT, punishment), &crime::T_punishment::_identity },
    { FLD(PRIMITIVE, criminal), TID(int32_t) },
    { FLD(PRIMITIVE, convicted), TID(int32_t) },
    { FLD(PRIMITIVE, victim), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(crime::T_flags) },
    { FLD(PRIMITIVE, death_id), TID(int32_t) },
    { FLD(PRIMITIVE, event_year), TID(int32_t) },
    { FLD(PRIMITIVE, event_time), TID(int32_t) },
    { FLD(PRIMITIVE, discovered_year), TID(int32_t) },
    { FLD(PRIMITIVE, discovered_time), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, entity), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, anon_1), &crime::T_anon_1::_identity, 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity crime::_identity(sizeof(crime), &allocator_fn<crime>, NULL, "crime",NULL,crime_fields);
  #define CUR_STRUCT cultural_identity::T_unk_c
  static const struct_field_info cultural_identity_doT_Dot_T_unk_c_fields[] = {
    { FLD(PRIMITIVE, group_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_20), TID(int32_t) },
    { FLD(CONTAINER, unk_24), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_34), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_44), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity cultural_identity::T_unk_c::_identity(sizeof(cultural_identity::T_unk_c), &allocator_fn<cultural_identity::T_unk_c>, &cultural_identity::_identity, "T_unk_c",NULL,cultural_identity_doT_Dot_T_unk_c_fields);
  #define CUR_STRUCT cultural_identity
  static const struct_field_info cultural_identity_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, civ_id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_c), &cultural_identity::T_unk_c::_identity, 0, NULL },
    { FLD(STATIC_ARRAY, unk_1c), identity_traits<int16_t >::get(), 22, NULL },
    { FLD(STATIC_ARRAY, unk_48), identity_traits<int32_t >::get(), 32, NULL },
    { FLD(STL_VECTOR_PTR, unk_c8), identity_traits<df::entity_event >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_d8), TID(int32_t) },
    { FLD(CONTAINER, unk_dc), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_ec), TID(int32_t) },
    { FLD(PRIMITIVE, unk_f0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_f4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_f8), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity cultural_identity::_identity(sizeof(cultural_identity), &allocator_fn<cultural_identity>, NULL, "cultural_identity",NULL,cultural_identity_fields);
  #define CUR_STRUCT curse_attr_change
  static const struct_field_info curse_attr_change_fields[] = {
    { FLD(STATIC_ARRAY, phys_att_perc), identity_traits<int32_t >::get(), 6, TID(physical_attribute_type) },
    { FLD(STATIC_ARRAY, phys_att_add), identity_traits<int32_t >::get(), 6, TID(physical_attribute_type) },
    { FLD(STATIC_ARRAY, ment_att_perc), identity_traits<int32_t >::get(), 13, TID(mental_attribute_type) },
    { FLD(STATIC_ARRAY, ment_att_add), identity_traits<int32_t >::get(), 13, TID(mental_attribute_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity curse_attr_change::_identity(sizeof(curse_attr_change), &allocator_fn<curse_attr_change>, NULL, "curse_attr_change",NULL,curse_attr_change_fields);
  #define CUR_STRUCT d_init::T_wound_color
  static const struct_field_info d_init_doT_Dot_T_wound_color_fields[] = {
    { FLD(STATIC_ARRAY, none), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, minor), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, inhibited), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, function_loss), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, broken), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, missing), identity_traits<int16_t >::get(), 3, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity d_init::T_wound_color::_identity(sizeof(d_init::T_wound_color), &allocator_fn<d_init::T_wound_color>, &d_init::_identity, "T_wound_color",NULL,d_init_doT_Dot_T_wound_color_fields);
  #define CUR_STRUCT d_init::T_store_dist
  static const struct_field_info d_init_doT_Dot_T_store_dist_fields[] = {
    { FLD(PRIMITIVE, item_decrease), TID(int16_t) },
    { FLD(PRIMITIVE, seed_combine), TID(int16_t) },
    { FLD(PRIMITIVE, bucket_combine), TID(int16_t) },
    { FLD(PRIMITIVE, barrel_combine), TID(int16_t) },
    { FLD(PRIMITIVE, bin_combine), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity d_init::T_store_dist::_identity(sizeof(d_init::T_store_dist), &allocator_fn<d_init::T_store_dist>, &d_init::_identity, "T_store_dist",NULL,d_init_doT_Dot_T_store_dist_fields);
  #define CUR_STRUCT d_init
  static const struct_field_info d_init_fields[] = {
    { FLD(CONTAINER, flags1), identity_traits<BitArray<df::d_init_flags1> >::get(), 0, TID(d_init_flags1) },
    { FLD(STATIC_ARRAY, nickname), identity_traits<df::d_init_nickname >::get(), 10, TID(game_type) },
    { FLD(PRIMITIVE, sky_tile), TID(uint8_t) },
    { FLD(STATIC_ARRAY, sky_color), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(PRIMITIVE, chasm_tile), TID(uint8_t) },
    { FLD(PRIMITIVE, pillar_tile), TID(uint8_t) },
    { FLD(STATIC_ARRAY, track_tiles), identity_traits<uint8_t >::get(), 15, NULL },
    { FLD(STATIC_ARRAY, track_tile_invert), identity_traits<uint8_t >::get(), 15, NULL },
    { FLD(STATIC_ARRAY, track_ramp_tiles), identity_traits<uint8_t >::get(), 15, NULL },
    { FLD(STATIC_ARRAY, track_ramp_invert), identity_traits<uint8_t >::get(), 15, NULL },
    { FLD(STATIC_ARRAY, tree_tiles), identity_traits<uint8_t >::get(), 104, NULL },
    { FLD(STATIC_ARRAY, chasm_color), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(SUBSTRUCT, wound_color), &d_init::T_wound_color::_identity },
    { FLD(PRIMITIVE, idlers), TID(d_init_idlers) },
    { FLD(PRIMITIVE, show_embark_tunnel), TID(d_init_tunnel) },
    { FLD(CONTAINER, flags2), identity_traits<BitArray<df::d_init_flags2> >::get(), 0, TID(d_init_flags2) },
    { FLD(PRIMITIVE, display_length), TID(int32_t) },
    { FLD(PRIMITIVE, adventurer_z_view), TID(d_init_z_view) },
    { FLD(PRIMITIVE, adventurer_z_view_size), TID(int32_t) },
    { FLD(CONTAINER, flags3), identity_traits<BitArray<df::d_init_flags3> >::get(), 0, TID(d_init_flags3) },
    { FLD(PRIMITIVE, population_cap), TID(int32_t) },
    { FLD(PRIMITIVE, strict_population_cap), TID(int32_t) },
    { FLD(PRIMITIVE, baby_cap_absolute), TID(int32_t) },
    { FLD(PRIMITIVE, baby_cap_percent), TID(int32_t) },
    { FLD(PRIMITIVE, specific_seed_cap), TID(int32_t) },
    { FLD(PRIMITIVE, fortress_seed_cap), TID(int32_t) },
    { FLD(STATIC_ARRAY, path_cost), identity_traits<int32_t >::get(), 4, NULL },
    { FLD(STATIC_ARRAY, embark_rect), identity_traits<int16_t >::get(), 2, NULL },
    { FLD(SUBSTRUCT, store_dist), &d_init::T_store_dist::_identity },
    { FLD(STATIC_ARRAY, set_labor_lists), identity_traits<int16_t >::get(), 2, NULL },
    { FLD(PRIMITIVE, graze_coefficient), TID(int32_t) },
    { FLD(CONTAINER, flags4), identity_traits<BitArray<df::d_init_flags4> >::get(), 0, TID(d_init_flags4) },
    { FLD(PRIMITIVE, post_prepare_embark_confirmation), TID(d_init_embark_confirm) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity d_init::_identity(sizeof(d_init), &allocator_fn<d_init>, NULL, "d_init",NULL,d_init_fields);
  #define CUR_STRUCT deep_vein_hollow
  static const struct_field_info deep_vein_hollow_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(SUBSTRUCT, tiles), &coord_path::_identity },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity deep_vein_hollow::_identity(sizeof(deep_vein_hollow), &allocator_fn<deep_vein_hollow>, NULL, "deep_vein_hollow",NULL,deep_vein_hollow_fields);
  #define CUR_STRUCT descriptor_color
  static const struct_field_info descriptor_color_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(CONTAINER, word_unk), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, words), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, color), TID(int8_t) },
    { FLD(PRIMITIVE, bold), TID(int8_t) },
    { FLD(PRIMITIVE, red), TID(float) },
    { FLD(PRIMITIVE, green), TID(float) },
    { FLD(PRIMITIVE, blue), TID(float) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity descriptor_color::_identity(sizeof(descriptor_color), &allocator_fn<descriptor_color>, NULL, "descriptor_color",NULL,descriptor_color_fields);
  #define CUR_STRUCT descriptor_pattern
  static const struct_field_info descriptor_pattern_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(CONTAINER, colors), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, pattern), TID(pattern_type) },
    { FLD(CONTAINER, cp_color), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity descriptor_pattern::_identity(sizeof(descriptor_pattern), &allocator_fn<descriptor_pattern>, NULL, "descriptor_pattern",NULL,descriptor_pattern_fields);
  #define CUR_STRUCT descriptor_shape
  static const struct_field_info descriptor_shape_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(CONTAINER, word_unk), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, words), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, adj), identity_traits<std::string >::get(), 0, NULL },
    { FLD(SUBSTRUCT, gems_use), TID(descriptor_shape::T_gems_use) },
    { FLD(PRIMITIVE, tile), TID(uint8_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity descriptor_shape::_identity(sizeof(descriptor_shape), &allocator_fn<descriptor_shape>, NULL, "descriptor_shape",NULL,descriptor_shape_fields);
  #define CUR_STRUCT dipscript_info
  static const struct_field_info dipscript_info_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, script_file), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, script_steps), identity_traits<df::script_stepst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, script_vars), identity_traits<df::script_varst >::get(), 0, NULL },
    { FLD(PRIMITIVE, code), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity dipscript_info::_identity(sizeof(dipscript_info), &allocator_fn<dipscript_info>, NULL, "dipscript_info",NULL,dipscript_info_fields);
  #define CUR_STRUCT dipscript_popup
  static const struct_field_info dipscript_popup_fields[] = {
    { FLD(POINTER, meeting_holder), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, activity), identity_traits<df::activity_info >::get(), 0, NULL },
    { FLD(SUBSTRUCT, flags), TID(dipscript_popup::T_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity dipscript_popup::_identity(sizeof(dipscript_popup), &allocator_fn<dipscript_popup>, NULL, "dipscript_popup",NULL,dipscript_popup_fields);
  #define CUR_STRUCT dye_info
  static const struct_field_info dye_info_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, dyer), TID(int32_t) },
    { FLD(PRIMITIVE, quality), TID(item_quality) },
    { FLD(PRIMITIVE, skill_rating), identity_traits<enum_field<df::skill_rating,int16_t> >::get() },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity dye_info::_identity(sizeof(dye_info), &allocator_fn<dye_info>, NULL, "dye_info",NULL,dye_info_fields);
  #define CUR_STRUCT effect_info
  static const struct_field_info effect_info_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(POINTER, anon_1), identity_traits<df::job >::get(), 0, NULL },
    { FLD(PRIMITIVE, type), TID(int16_t) },
    { FLD(PRIMITIVE, foreground), TID(int16_t) },
    { FLD(PRIMITIVE, background), TID(int16_t) },
    { FLD(PRIMITIVE, bright), TID(int8_t) },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity effect_info::_identity(sizeof(effect_info), &allocator_fn<effect_info>, NULL, "effect_info",NULL,effect_info_fields);
  #define CUR_STRUCT embark_item_choice::T_list
  static const struct_field_info embark_item_choice_doT_Dot_T_list_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mattype), TID(int16_t) },
    { FLD(PRIMITIVE, matindex), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity embark_item_choice::T_list::_identity(sizeof(embark_item_choice::T_list), &allocator_fn<embark_item_choice::T_list>, &embark_item_choice::_identity, "T_list",NULL,embark_item_choice_doT_Dot_T_list_fields);
  #define CUR_STRUCT embark_item_choice
  static const struct_field_info embark_item_choice_fields[] = {
    { FLD(STATIC_ARRAY, list), identity_traits<std::vector<df::embark_item_choice::T_list* > >::get(), 107, TID(entity_sell_category) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity embark_item_choice::_identity(sizeof(embark_item_choice), &allocator_fn<embark_item_choice>, NULL, "embark_item_choice",NULL,embark_item_choice_fields);
  #define CUR_STRUCT embark_location
  static const struct_field_info embark_location_fields[] = {
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD(PRIMITIVE, reclaim_site), TID(int16_t) },
    { FLD(PRIMITIVE, reclaim_idx), TID(int16_t) },
    { FLD(SUBSTRUCT, biome_rgn), &coord2d_path::_identity },
    { FLD(SUBSTRUCT, embark_pos_min), &coord2d::_identity },
    { FLD(SUBSTRUCT, embark_pos_max), &coord2d::_identity },
    { FLD(SUBSTRUCT, embark_biome_rgn), &coord2d::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity embark_location::_identity(sizeof(embark_location), &allocator_fn<embark_location>, NULL, "embark_location",NULL,embark_location_fields);
  #define CUR_STRUCT enum_traits<emotion_type>::attr_entry_type
  static const struct_field_info enum_traits_lT_emotion_type_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, color), identity_traits<int8_t>::get() },
    { FLD(PRIMITIVE, divider), identity_traits<int8_t>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<emotion_type>::attr_entry_type::_identity(sizeof(enum_traits<emotion_type>::attr_entry_type), NULL, TID(emotion_type), "_attr_entry_type", NULL, enum_traits_lT_emotion_type_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT enabler::T_overridden_grid_sizes
  static const struct_field_info enabler_doT_Dot_T_overridden_grid_sizes_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enabler::T_overridden_grid_sizes::_identity(sizeof(enabler::T_overridden_grid_sizes), &allocator_fn<enabler::T_overridden_grid_sizes>, &enabler::_identity, "T_overridden_grid_sizes",NULL,enabler_doT_Dot_T_overridden_grid_sizes_fields);
  #define CUR_STRUCT enabler::T_async_tobox::T_queue
  static const struct_field_info enabler_doT_Dot_T_async_tobox_doT_Dot_T_queue_fields[] = {
    { FLD(PRIMITIVE, cmd), TID(enabler::T_async_tobox::T_queue::T_cmd) },
    { FLD(PRIMITIVE, val), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enabler::T_async_tobox::T_queue::_identity(sizeof(enabler::T_async_tobox::T_queue), &allocator_fn<enabler::T_async_tobox::T_queue>, &enabler::T_async_tobox::_identity, "T_queue",NULL,enabler_doT_Dot_T_async_tobox_doT_Dot_T_queue_fields);
  #define CUR_STRUCT enabler::T_async_tobox
  static const struct_field_info enabler_doT_Dot_T_async_tobox_fields[] = {
    { FLD(POINTER, sem), NULL, 0, NULL },
    { FLD(CONTAINER, queue), identity_traits<std::deque<df::enabler::T_async_tobox::T_queue > >::get(), 0, NULL },
    { FLD(POINTER, sem_fill), NULL, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enabler::T_async_tobox::_identity(sizeof(enabler::T_async_tobox), &allocator_fn<enabler::T_async_tobox>, &enabler::_identity, "T_async_tobox",NULL,enabler_doT_Dot_T_async_tobox_fields);
  #define CUR_STRUCT enabler::T_async_frombox::T_queue
  static const struct_field_info enabler_doT_Dot_T_async_frombox_doT_Dot_T_queue_fields[] = {
    { FLD(PRIMITIVE, msg), TID(enabler::T_async_frombox::T_queue::T_msg) },
    { FLD(PRIMITIVE, fps), TID(int32_t) },
    { FLD(PRIMITIVE, x), TID(int32_t) },
    { FLD(PRIMITIVE, y), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enabler::T_async_frombox::T_queue::_identity(sizeof(enabler::T_async_frombox::T_queue), &allocator_fn<enabler::T_async_frombox::T_queue>, &enabler::T_async_frombox::_identity, "T_queue",NULL,enabler_doT_Dot_T_async_frombox_doT_Dot_T_queue_fields);
  #define CUR_STRUCT enabler::T_async_frombox
  static const struct_field_info enabler_doT_Dot_T_async_frombox_fields[] = {
    { FLD(POINTER, sem), NULL, 0, NULL },
    { FLD(CONTAINER, queue), identity_traits<std::deque<df::enabler::T_async_frombox::T_queue > >::get(), 0, NULL },
    { FLD(POINTER, sem_fill), NULL, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enabler::T_async_frombox::_identity(sizeof(enabler::T_async_frombox), &allocator_fn<enabler::T_async_frombox>, &enabler::_identity, "T_async_frombox",NULL,enabler_doT_Dot_T_async_frombox_fields);
  #define CUR_STRUCT enabler::T_async_zoom
  static const struct_field_info enabler_doT_Dot_T_async_zoom_fields[] = {
    { FLD(POINTER, sem), NULL, 0, NULL },
    { FLD(CONTAINER, queue), identity_traits<std::deque<df::zoom_commands > >::get(), 0, NULL },
    { FLD(POINTER, sem_fill), NULL, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enabler::T_async_zoom::_identity(sizeof(enabler::T_async_zoom), &allocator_fn<enabler::T_async_zoom>, &enabler::_identity, "T_async_zoom",NULL,enabler_doT_Dot_T_async_zoom_fields);
  #define CUR_STRUCT enabler::T_textures
  static const struct_field_info enabler_doT_Dot_T_textures_fields[] = {
    { FLD(STL_VECTOR_PTR, raws), NULL, 0, NULL },
    { FLD(PRIMITIVE, uploaded), TID(bool) },
    { FLD(PRIMITIVE, gl_catalog), TID(uint32_t) },
    { FLD(POINTER, gl_texpos), NULL, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enabler::T_textures::_identity(sizeof(enabler::T_textures), &allocator_fn<enabler::T_textures>, &enabler::_identity, "T_textures",NULL,enabler_doT_Dot_T_textures_fields);
  #define CUR_STRUCT enabler::T_simticks
  static const struct_field_info enabler_doT_Dot_T_simticks_fields[] = {
    { FLD(POINTER, sem), NULL, 0, NULL },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enabler::T_simticks::_identity(sizeof(enabler::T_simticks), &allocator_fn<enabler::T_simticks>, &enabler::_identity, "T_simticks",NULL,enabler_doT_Dot_T_simticks_fields);
  #define CUR_STRUCT enabler::T_gputicks
  static const struct_field_info enabler_doT_Dot_T_gputicks_fields[] = {
    { FLD(POINTER, sem), NULL, 0, NULL },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enabler::T_gputicks::_identity(sizeof(enabler::T_gputicks), &allocator_fn<enabler::T_gputicks>, &enabler::_identity, "T_gputicks",NULL,enabler_doT_Dot_T_gputicks_fields);
  typedef float T_enabler_fields[3];
  #define CUR_STRUCT enabler
  static const struct_field_info enabler_fields[] = {
    { FLD(PRIMITIVE, fullscreen), TID(bool) },
    { FLD(CONTAINER, overridden_grid_sizes), identity_traits<std::deque<df::enabler::T_overridden_grid_sizes > >::get(), 0, NULL },
    { FLD(POINTER, renderer), identity_traits<df::renderer >::get(), 0, NULL },
    { FLD(PRIMITIVE, calculated_fps), TID(int32_t) },
    { FLD(PRIMITIVE, calculated_gfps), TID(int32_t) },
    { FLD(CONTAINER, frame_timings), identity_traits<std::deque<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, gframe_timings), identity_traits<std::deque<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, frame_sum), TID(int32_t) },
    { FLD(PRIMITIVE, gframe_sum), TID(int32_t) },
    { FLD(PRIMITIVE, frame_last), TID(int32_t) },
    { FLD(PRIMITIVE, gframe_last), TID(int32_t) },
    { FLD(PRIMITIVE, fps), TID(float) },
    { FLD(PRIMITIVE, gfps), TID(float) },
    { FLD(PRIMITIVE, fps_per_gfps), TID(float) },
    { FLD(PRIMITIVE, last_tick), TID(uint32_t) },
    { FLD(PRIMITIVE, outstanding_frames), TID(float) },
    { FLD(PRIMITIVE, outstanding_gframes), TID(float) },
    { FLD(PRIMITIVE, async_frames), TID(uint32_t) },
    { FLD(PRIMITIVE, async_paused), TID(bool) },
    { FLD(SUBSTRUCT, async_tobox), &enabler::T_async_tobox::_identity },
    { FLD(SUBSTRUCT, async_frombox), &enabler::T_async_frombox::_identity },
    { FLD(SUBSTRUCT, async_zoom), &enabler::T_async_zoom::_identity },
    { FLD(POINTER, async_fromcomplete), NULL, 0, NULL },
    { FLD(PRIMITIVE, renderer_threadid), TID(uint32_t) },
    { FLD(PRIMITIVE, command_line), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, ccolor), identity_traits<T_enabler_fields >::get(), 16, NULL },
    { FLD(SUBSTRUCT, flag), TID(enabler::T_flag) },
    { FLD(PRIMITIVE, mouse_lbut), TID(int8_t) },
    { FLD(PRIMITIVE, mouse_rbut), TID(int8_t) },
    { FLD(PRIMITIVE, mouse_lbut_down), TID(int8_t) },
    { FLD(PRIMITIVE, mouse_rbut_down), TID(int8_t) },
    { FLD(PRIMITIVE, mouse_lbut_lift), TID(int8_t) },
    { FLD(PRIMITIVE, mouse_rbut_lift), TID(int8_t) },
    { FLD(PRIMITIVE, tracking_on), TID(int8_t) },
    { FLD(SUBSTRUCT, textures), &enabler::T_textures::_identity },
    { FLD(PRIMITIVE, sync), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, text_system), NULL, 0, NULL },
    { FLD(SUBSTRUCT, simticks), &enabler::T_simticks::_identity },
    { FLD(SUBSTRUCT, gputicks), &enabler::T_gputicks::_identity },
    { FLD(PRIMITIVE, clock), TID(uint32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enabler::_identity(sizeof(enabler), &allocator_fn<enabler>, NULL, "enabler",NULL,enabler_fields);
  #define CUR_STRUCT engraving
  static const struct_field_info engraving_fields[] = {
    { FLD(PRIMITIVE, artist), TID(int32_t) },
    { FLD(PRIMITIVE, masterpiece_event), TID(int32_t) },
    { FLD(PRIMITIVE, skill_rating), TID(skill_rating) },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(SUBSTRUCT, flags), TID(engraving_flags) },
    { FLD(PRIMITIVE, tile), TID(int8_t) },
    { FLD(PRIMITIVE, art_id), TID(int32_t) },
    { FLD(PRIMITIVE, art_subid), TID(int16_t) },
    { FLD(PRIMITIVE, quality), TID(item_quality) },
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD(PRIMITIVE, unk2), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity engraving::_identity(sizeof(engraving), &allocator_fn<engraving>, NULL, "engraving",NULL,engraving_fields);
  #define CUR_STRUCT entity_activity_statistics::T_food
  static const struct_field_info entity_activity_statistics_doT_Dot_T_food_fields[] = {
    { FLD(PRIMITIVE, total), TID(int32_t) },
    { FLD(PRIMITIVE, meat), TID(int32_t) },
    { FLD(PRIMITIVE, fish), TID(int32_t) },
    { FLD(PRIMITIVE, other), TID(int32_t) },
    { FLD(PRIMITIVE, seeds), TID(int32_t) },
    { FLD(PRIMITIVE, plant), TID(int32_t) },
    { FLD(PRIMITIVE, drink), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_activity_statistics::T_food::_identity(sizeof(entity_activity_statistics::T_food), &allocator_fn<entity_activity_statistics::T_food>, &entity_activity_statistics::_identity, "T_food",NULL,entity_activity_statistics_doT_Dot_T_food_fields);
  #define CUR_STRUCT entity_activity_statistics::T_wealth
  static const struct_field_info entity_activity_statistics_doT_Dot_T_wealth_fields[] = {
    { FLD(PRIMITIVE, total), TID(int32_t) },
    { FLD(PRIMITIVE, weapons), TID(int32_t) },
    { FLD(PRIMITIVE, armor), TID(int32_t) },
    { FLD(PRIMITIVE, furniture), TID(int32_t) },
    { FLD(PRIMITIVE, other), TID(int32_t) },
    { FLD(PRIMITIVE, architecture), TID(int32_t) },
    { FLD(PRIMITIVE, displayed), TID(int32_t) },
    { FLD(PRIMITIVE, held), TID(int32_t) },
    { FLD(PRIMITIVE, imported), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, exported), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_activity_statistics::T_wealth::_identity(sizeof(entity_activity_statistics::T_wealth), &allocator_fn<entity_activity_statistics::T_wealth>, &entity_activity_statistics::_identity, "T_wealth",NULL,entity_activity_statistics_doT_Dot_T_wealth_fields);
  typedef int32_t T_entity_activity_statistics_fields[260];
  #define CUR_STRUCT entity_activity_statistics
  static const struct_field_info entity_activity_statistics_fields[] = {
    { FLD(SUBSTRUCT, food), &entity_activity_statistics::T_food::_identity },
    { FLD(STATIC_ARRAY, unit_counts), identity_traits<int16_t >::get(), 152, TID(profession) },
    { FLD(PRIMITIVE, population), TID(int16_t) },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), TID(int16_t) },
    { FLD(PRIMITIVE, anon_3), TID(int16_t) },
    { FLD(PRIMITIVE, trained_animals), TID(int16_t) },
    { FLD(PRIMITIVE, other_animals), TID(int16_t) },
    { FLD(PRIMITIVE, anon_4), TID(int16_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(STATIC_ARRAY, item_counts), identity_traits<int32_t >::get(), 112, TID(item_type) },
    { FLD(CONTAINER, created_weapons), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, wealth), &entity_activity_statistics::T_wealth::_identity },
    { FLD(STATIC_ARRAY, recent_jobs), identity_traits<T_entity_activity_statistics_fields >::get(), 7, NULL },
    { FLD(PRIMITIVE, excavated_tiles), TID(int32_t) },
    { FLD(STATIC_ARRAY, death_history), identity_traits<int32_t >::get(), 5, NULL },
    { FLD(STATIC_ARRAY, insanity_history), identity_traits<int32_t >::get(), 5, NULL },
    { FLD(STATIC_ARRAY, execution_history), identity_traits<int32_t >::get(), 5, NULL },
    { FLD(STATIC_ARRAY, noble_death_history), identity_traits<int32_t >::get(), 5, NULL },
    { FLD(PRIMITIVE, total_deaths), TID(int32_t) },
    { FLD(PRIMITIVE, total_insanities), TID(int32_t) },
    { FLD(PRIMITIVE, total_executions), TID(int32_t) },
    { FLD(PRIMITIVE, num_artifacts), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(CONTAINER, discovered_creature_foods), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, discovered_creatures), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, discovered_plant_foods), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, discovered_plants), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(PRIMITIVE, discovered_water_features), TID(int16_t) },
    { FLD(PRIMITIVE, discovered_subterranean_features), TID(int16_t) },
    { FLD(PRIMITIVE, discovered_chasm_features), TID(int16_t) },
    { FLD(PRIMITIVE, discovered_magma_features), TID(int16_t) },
    { FLD(PRIMITIVE, discovered_feature_layers), TID(int16_t) },
    { FLD(PRIMITIVE, migrant_wave_idx), TID(int32_t) },
    { FLD(CONTAINER, found_minerals), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, found_misc), TID(entity_activity_statistics::T_found_misc) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_activity_statistics::_identity(sizeof(entity_activity_statistics), &allocator_fn<entity_activity_statistics>, NULL, "entity_activity_statistics",NULL,entity_activity_statistics_fields);
  #define CUR_STRUCT entity_buy_prices
  static const struct_field_info entity_buy_prices_fields[] = {
    { FLD(POINTER, items), identity_traits<df::entity_buy_requests >::get(), 0, NULL },
    { FLD(CONTAINER, price), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_buy_prices::_identity(sizeof(entity_buy_prices), &allocator_fn<entity_buy_prices>, NULL, "entity_buy_prices",NULL,entity_buy_prices_fields);
  #define CUR_STRUCT entity_buy_requests
  static const struct_field_info entity_buy_requests_fields[] = {
    { FLD(CONTAINER, item_type), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, item_subtype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_20), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_30), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mat_cats), identity_traits<std::vector<df::job_material_category > >::get(), 0, NULL },
    { FLD(CONTAINER, priority), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_buy_requests::_identity(sizeof(entity_buy_requests), &allocator_fn<entity_buy_requests>, NULL, "entity_buy_requests",NULL,entity_buy_requests_fields);
  #define CUR_STRUCT entity_claim_mask::T_map
  static const struct_field_info entity_claim_mask_doT_Dot_T_map_fields[] = {
    { FLD(CONTAINER, entities), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, region_masks), identity_traits<df::entity_claim_mask::T_map::T_region_masks >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_claim_mask::T_map::_identity(sizeof(entity_claim_mask::T_map), &allocator_fn<entity_claim_mask::T_map>, &entity_claim_mask::_identity, "T_map",NULL,entity_claim_mask_doT_Dot_T_map_fields);
  #define CUR_STRUCT entity_claim_mask
  static const struct_field_info entity_claim_mask_fields[] = {
    { FLD(POINTER, map), identity_traits<df::entity_claim_mask::T_map* >::get(), 1, NULL },
    { FLD(PRIMITIVE, width), TID(int16_t) },
    { FLD(PRIMITIVE, height), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_claim_mask::_identity(sizeof(entity_claim_mask), &allocator_fn<entity_claim_mask>, NULL, "entity_claim_mask",NULL,entity_claim_mask_fields);
  #define CUR_STRUCT entity_entity_link
  static const struct_field_info entity_entity_link_fields[] = {
    { FLD(PRIMITIVE, type), identity_traits<enum_field<df::entity_entity_link_type,int16_t> >::get() },
    { FLD(PRIMITIVE, target), TID(int32_t) },
    { FLD(PRIMITIVE, strength), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_entity_link::_identity(sizeof(entity_entity_link), &allocator_fn<entity_entity_link>, NULL, "entity_entity_link",NULL,entity_entity_link_fields);
  #define CUR_STRUCT entity_event::T_data::T_invasion
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_invasion_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_invasion>::identity(sizeof(entity_event::T_data::T_invasion), &allocator_fn<entity_event::T_data::T_invasion>, TID(entity_event::T_data), "T_invasion", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_invasion_fields);
  #define CUR_STRUCT entity_event::T_data::T_abduction
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_abduction_fields[] = {
    { FLD(PRIMITIVE, histfig_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_abduction>::identity(sizeof(entity_event::T_data::T_abduction), &allocator_fn<entity_event::T_data::T_abduction>, TID(entity_event::T_data), "T_abduction", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_abduction_fields);
  #define CUR_STRUCT entity_event::T_data::T_incident
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_incident_fields[] = {
    { FLD(PRIMITIVE, incident_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_incident>::identity(sizeof(entity_event::T_data::T_incident), &allocator_fn<entity_event::T_data::T_incident>, TID(entity_event::T_data), "T_incident", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_incident_fields);
  #define CUR_STRUCT entity_event::T_data::T_occupation
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_occupation_fields[] = {
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_occupation>::identity(sizeof(entity_event::T_data::T_occupation), &allocator_fn<entity_event::T_data::T_occupation>, TID(entity_event::T_data), "T_occupation", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_occupation_fields);
  #define CUR_STRUCT entity_event::T_data::T_beast
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_beast_fields[] = {
    { FLD(PRIMITIVE, histfig_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, region_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_beast>::identity(sizeof(entity_event::T_data::T_beast), &allocator_fn<entity_event::T_data::T_beast>, TID(entity_event::T_data), "T_beast", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_beast_fields);
  #define CUR_STRUCT entity_event::T_data::T_group
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_group_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_group>::identity(sizeof(entity_event::T_data::T_group), &allocator_fn<entity_event::T_data::T_group>, TID(entity_event::T_data), "T_group", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_group_fields);
  #define CUR_STRUCT entity_event::T_data::T_harass
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_harass_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_harass>::identity(sizeof(entity_event::T_data::T_harass), &allocator_fn<entity_event::T_data::T_harass>, TID(entity_event::T_data), "T_harass", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_harass_fields);
  #define CUR_STRUCT entity_event::T_data::T_flee
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_flee_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_flee>::identity(sizeof(entity_event::T_data::T_flee), &allocator_fn<entity_event::T_data::T_flee>, TID(entity_event::T_data), "T_flee", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_flee_fields);
  #define CUR_STRUCT entity_event::T_data::T_abandon
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_abandon_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_abandon>::identity(sizeof(entity_event::T_data::T_abandon), &allocator_fn<entity_event::T_data::T_abandon>, TID(entity_event::T_data), "T_abandon", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_abandon_fields);
  #define CUR_STRUCT entity_event::T_data::T_reclaimed
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_reclaimed_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_reclaimed>::identity(sizeof(entity_event::T_data::T_reclaimed), &allocator_fn<entity_event::T_data::T_reclaimed>, TID(entity_event::T_data), "T_reclaimed", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_reclaimed_fields);
  #define CUR_STRUCT entity_event::T_data::T_founded
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_founded_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_founded>::identity(sizeof(entity_event::T_data::T_founded), &allocator_fn<entity_event::T_data::T_founded>, TID(entity_event::T_data), "T_founded", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_founded_fields);
  #define CUR_STRUCT entity_event::T_data::T_reclaiming
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_reclaiming_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_reclaiming>::identity(sizeof(entity_event::T_data::T_reclaiming), &allocator_fn<entity_event::T_data::T_reclaiming>, TID(entity_event::T_data), "T_reclaiming", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_reclaiming_fields);
  #define CUR_STRUCT entity_event::T_data::T_founding
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_founding_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, region_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_founding>::identity(sizeof(entity_event::T_data::T_founding), &allocator_fn<entity_event::T_data::T_founding>, TID(entity_event::T_data), "T_founding", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_founding_fields);
  #define CUR_STRUCT entity_event::T_data::T_leave
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_leave_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_leave>::identity(sizeof(entity_event::T_data::T_leave), &allocator_fn<entity_event::T_data::T_leave>, TID(entity_event::T_data), "T_leave", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_leave_fields);
  #define CUR_STRUCT entity_event::T_data::T_insurrection
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_insurrection_fields[] = {
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_insurrection>::identity(sizeof(entity_event::T_data::T_insurrection), &allocator_fn<entity_event::T_data::T_insurrection>, TID(entity_event::T_data), "T_insurrection", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_insurrection_fields);
  #define CUR_STRUCT entity_event::T_data::T_insurrection_end
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_insurrection_end_fields[] = {
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, result), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_insurrection_end>::identity(sizeof(entity_event::T_data::T_insurrection_end), &allocator_fn<entity_event::T_data::T_insurrection_end>, TID(entity_event::T_data), "T_insurrection_end", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_insurrection_end_fields);
  #define CUR_STRUCT entity_event::T_data::T_succession
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_succession_fields[] = {
    { FLD(PRIMITIVE, histfig_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, position_assignment_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_succession>::identity(sizeof(entity_event::T_data::T_succession), &allocator_fn<entity_event::T_data::T_succession>, TID(entity_event::T_data), "T_succession", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_succession_fields);
  #define CUR_STRUCT entity_event::T_data::T_claim
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_claim_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_claim>::identity(sizeof(entity_event::T_data::T_claim), &allocator_fn<entity_event::T_data::T_claim>, TID(entity_event::T_data), "T_claim", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_claim_fields);
  #define CUR_STRUCT entity_event::T_data::T_accept_tribute_offer
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_accept_tribute_offer_fields[] = {
    { FLD(PRIMITIVE, entity1_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, entity2_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_accept_tribute_offer>::identity(sizeof(entity_event::T_data::T_accept_tribute_offer), &allocator_fn<entity_event::T_data::T_accept_tribute_offer>, TID(entity_event::T_data), "T_accept_tribute_offer", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_accept_tribute_offer_fields);
  #define CUR_STRUCT entity_event::T_data::T_refuse_tribute_offer
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_refuse_tribute_offer_fields[] = {
    { FLD(PRIMITIVE, entity1_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, entity2_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_refuse_tribute_offer>::identity(sizeof(entity_event::T_data::T_refuse_tribute_offer), &allocator_fn<entity_event::T_data::T_refuse_tribute_offer>, TID(entity_event::T_data), "T_refuse_tribute_offer", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_refuse_tribute_offer_fields);
  #define CUR_STRUCT entity_event::T_data::T_accept_tribute_demand
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_accept_tribute_demand_fields[] = {
    { FLD(PRIMITIVE, entity1_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, entity2_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_accept_tribute_demand>::identity(sizeof(entity_event::T_data::T_accept_tribute_demand), &allocator_fn<entity_event::T_data::T_accept_tribute_demand>, TID(entity_event::T_data), "T_accept_tribute_demand", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_accept_tribute_demand_fields);
  #define CUR_STRUCT entity_event::T_data::T_refuse_tribute_demand
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_refuse_tribute_demand_fields[] = {
    { FLD(PRIMITIVE, entity1_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, entity2_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_refuse_tribute_demand>::identity(sizeof(entity_event::T_data::T_refuse_tribute_demand), &allocator_fn<entity_event::T_data::T_refuse_tribute_demand>, TID(entity_event::T_data), "T_refuse_tribute_demand", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_refuse_tribute_demand_fields);
  #define CUR_STRUCT entity_event::T_data::T_accept_peace_offer
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_accept_peace_offer_fields[] = {
    { FLD(PRIMITIVE, entity1_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, entity2_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_accept_peace_offer>::identity(sizeof(entity_event::T_data::T_accept_peace_offer), &allocator_fn<entity_event::T_data::T_accept_peace_offer>, TID(entity_event::T_data), "T_accept_peace_offer", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_accept_peace_offer_fields);
  #define CUR_STRUCT entity_event::T_data::T_refuse_peace_offer
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_refuse_peace_offer_fields[] = {
    { FLD(PRIMITIVE, entity1_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, entity2_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_refuse_peace_offer>::identity(sizeof(entity_event::T_data::T_refuse_peace_offer), &allocator_fn<entity_event::T_data::T_refuse_peace_offer>, TID(entity_event::T_data), "T_refuse_peace_offer", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_refuse_peace_offer_fields);
  #define CUR_STRUCT entity_event::T_data::T_cease_tribute_offer
  static const struct_field_info entity_event_doT_Dot_T_data_doT_Dot_T_cease_tribute_offer_fields[] = {
    { FLD(PRIMITIVE, entity1_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, entity2_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data::T_cease_tribute_offer>::identity(sizeof(entity_event::T_data::T_cease_tribute_offer), &allocator_fn<entity_event::T_data::T_cease_tribute_offer>, TID(entity_event::T_data), "T_cease_tribute_offer", NULL, entity_event_doT_Dot_T_data_doT_Dot_T_cease_tribute_offer_fields);
  #define CUR_STRUCT entity_event::T_data
  static const struct_field_info entity_event_doT_Dot_T_data_fields[] = {
    { FLD(SUBSTRUCT, invasion), TID(entity_event::T_data::T_invasion) },
    { FLD(SUBSTRUCT, abduction), TID(entity_event::T_data::T_abduction) },
    { FLD(SUBSTRUCT, incident), TID(entity_event::T_data::T_incident) },
    { FLD(SUBSTRUCT, occupation), TID(entity_event::T_data::T_occupation) },
    { FLD(SUBSTRUCT, beast), TID(entity_event::T_data::T_beast) },
    { FLD(SUBSTRUCT, group), TID(entity_event::T_data::T_group) },
    { FLD(SUBSTRUCT, harass), TID(entity_event::T_data::T_harass) },
    { FLD(SUBSTRUCT, flee), TID(entity_event::T_data::T_flee) },
    { FLD(SUBSTRUCT, abandon), TID(entity_event::T_data::T_abandon) },
    { FLD(SUBSTRUCT, reclaimed), TID(entity_event::T_data::T_reclaimed) },
    { FLD(SUBSTRUCT, founded), TID(entity_event::T_data::T_founded) },
    { FLD(SUBSTRUCT, reclaiming), TID(entity_event::T_data::T_reclaiming) },
    { FLD(SUBSTRUCT, founding), TID(entity_event::T_data::T_founding) },
    { FLD(SUBSTRUCT, leave), TID(entity_event::T_data::T_leave) },
    { FLD(SUBSTRUCT, insurrection), TID(entity_event::T_data::T_insurrection) },
    { FLD(SUBSTRUCT, insurrection_end), TID(entity_event::T_data::T_insurrection_end) },
    { FLD(SUBSTRUCT, succession), TID(entity_event::T_data::T_succession) },
    { FLD(SUBSTRUCT, claim), TID(entity_event::T_data::T_claim) },
    { FLD(SUBSTRUCT, accept_tribute_offer), TID(entity_event::T_data::T_accept_tribute_offer) },
    { FLD(SUBSTRUCT, refuse_tribute_offer), TID(entity_event::T_data::T_refuse_tribute_offer) },
    { FLD(SUBSTRUCT, accept_tribute_demand), TID(entity_event::T_data::T_accept_tribute_demand) },
    { FLD(SUBSTRUCT, refuse_tribute_demand), TID(entity_event::T_data::T_refuse_tribute_demand) },
    { FLD(SUBSTRUCT, accept_peace_offer), TID(entity_event::T_data::T_accept_peace_offer) },
    { FLD(SUBSTRUCT, refuse_peace_offer), TID(entity_event::T_data::T_refuse_peace_offer) },
    { FLD(SUBSTRUCT, cease_tribute_offer), TID(entity_event::T_data::T_cease_tribute_offer) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<entity_event::T_data>::identity(sizeof(entity_event::T_data), &allocator_fn<entity_event::T_data>, &entity_event::_identity, "T_data", NULL, entity_event_doT_Dot_T_data_fields);
  #define CUR_STRUCT entity_event
  static const struct_field_info entity_event_fields[] = {
    { FLD(SUBSTRUCT, data), TID(entity_event::T_data) },
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, year_tick), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, type), TID(entity_event_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_event::_identity(sizeof(entity_event), &allocator_fn<entity_event>, NULL, "entity_event",NULL,entity_event_fields);
  #define CUR_STRUCT entity_population
  static const struct_field_info entity_population_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(CONTAINER, races), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, counts), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk3), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk4), identity_traits<df::entity_population_unk4 >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk5), TID(int32_t) },
    { FLD(PRIMITIVE, unk6), TID(int32_t) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, flags), TID(int32_t) },
    { FLD(PRIMITIVE, civ_id), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_population::_identity(sizeof(entity_population), &allocator_fn<entity_population>, NULL, "entity_population",NULL,entity_population_fields);
  #define CUR_STRUCT entity_population_unk4::T_anon_1
  static const struct_field_info entity_population_unk4_doT_Dot_T_anon_1_fields[] = {
    { FLD(PRIMITIVE, idx), TID(int32_t) },
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD(PRIMITIVE, unk2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_population_unk4::T_anon_1::_identity(sizeof(entity_population_unk4::T_anon_1), &allocator_fn<entity_population_unk4::T_anon_1>, &entity_population_unk4::_identity, "T_anon_1",NULL,entity_population_unk4_doT_Dot_T_anon_1_fields);
  #define CUR_STRUCT entity_population_unk4::T_anon_3
  static const struct_field_info entity_population_unk4_doT_Dot_T_anon_3_fields[] = {
    { FLD(PRIMITIVE, idx), TID(int32_t) },
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_population_unk4::T_anon_3::_identity(sizeof(entity_population_unk4::T_anon_3), &allocator_fn<entity_population_unk4::T_anon_3>, &entity_population_unk4::_identity, "T_anon_3",NULL,entity_population_unk4_doT_Dot_T_anon_3_fields);
  #define CUR_STRUCT entity_population_unk4
  static const struct_field_info entity_population_unk4_fields[] = {
    { FLD(STL_VECTOR_PTR, anon_1), &entity_population_unk4::T_anon_1::_identity, 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_3), &entity_population_unk4::T_anon_3::_identity, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_population_unk4::_identity(sizeof(entity_population_unk4), &allocator_fn<entity_population_unk4>, NULL, "entity_population_unk4",NULL,entity_population_unk4_fields);
  #define CUR_STRUCT entity_position
  static const struct_field_info entity_position_fields[] = {
    { FLD(PRIMITIVE, code), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::entity_position_flags> >::get(), 0, TID(entity_position_flags) },
    { FLD(CONTAINER, allowed_creature), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, allowed_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, rejected_creature), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, rejected_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, name), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, name_female), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, name_male), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, spouse), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, spouse_female), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, spouse_male), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, squad), identity_traits<std::string >::get(), 2, NULL },
    { FLD(PRIMITIVE, land_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, squad_size), TID(int16_t) },
    { FLD(CONTAINER, commander_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, commander_civ), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, commander_types), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, land_holder), TID(int16_t) },
    { FLD(PRIMITIVE, requires_population), TID(int16_t) },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, precedence), TID(int32_t) },
    { FLD(PRIMITIVE, replaced_by), TID(int32_t) },
    { FLD(PRIMITIVE, number), TID(int16_t) },
    { FLD(CONTAINER, appointed_by), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, appointed_by_civ), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, succession_by_position), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, responsibilities), identity_traits<bool >::get(), 25, TID(entity_position_responsibility) },
    { FLD(STATIC_ARRAY, color), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(PRIMITIVE, required_boxes), TID(int32_t) },
    { FLD(PRIMITIVE, required_cabinets), TID(int32_t) },
    { FLD(PRIMITIVE, required_racks), TID(int32_t) },
    { FLD(PRIMITIVE, required_stands), TID(int32_t) },
    { FLD(PRIMITIVE, required_office), TID(int32_t) },
    { FLD(PRIMITIVE, required_bedroom), TID(int32_t) },
    { FLD(PRIMITIVE, required_dining), TID(int32_t) },
    { FLD(PRIMITIVE, required_tomb), TID(int32_t) },
    { FLD(PRIMITIVE, mandate_max), TID(int32_t) },
    { FLD(PRIMITIVE, demand_max), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_position::_identity(sizeof(entity_position), &allocator_fn<entity_position>, NULL, "entity_position",NULL,entity_position_fields);
  #define CUR_STRUCT entity_position_assignment
  static const struct_field_info entity_position_assignment_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, histfig2), TID(int32_t) },
    { FLD(PRIMITIVE, position_id), TID(int32_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(PRIMITIVE, squad_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_position_assignment::_identity(sizeof(entity_position_assignment), &allocator_fn<entity_position_assignment>, NULL, "entity_position_assignment",NULL,entity_position_assignment_fields);
  #define CUR_STRUCT entity_position_raw
  static const struct_field_info entity_position_raw_fields[] = {
    { FLD(PRIMITIVE, code), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::entity_position_raw_flags> >::get(), 0, TID(entity_position_raw_flags) },
    { FLD(STATIC_ARRAY, allowed_creature_str), identity_traits<std::vector<std::string* > >::get(), 2, NULL },
    { FLD(CONTAINER, allowed_creature), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, allowed_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, rejected_creature_str), identity_traits<std::vector<std::string* > >::get(), 2, NULL },
    { FLD(CONTAINER, rejected_creature), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, rejected_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, name), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, name_female), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, name_male), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, spouse), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, spouse_female), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, spouse_male), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, squad), identity_traits<std::string >::get(), 2, NULL },
    { FLD(PRIMITIVE, land_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, squad_size), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, commander_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, commander_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, commander_types), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, land_holder), TID(int16_t) },
    { FLD(PRIMITIVE, number), TID(int16_t) },
    { FLD(PRIMITIVE, execution_skill), TID(job_skill) },
    { FLD(PRIMITIVE, precedence), TID(int32_t) },
    { FLD(PRIMITIVE, replaced_by_str), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, replaced_by), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, appointed_by_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, appointed_by), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, succession_by_position_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, succession_by_position), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, responsibilities), identity_traits<bool >::get(), 25, TID(entity_position_responsibility) },
    { FLD(STATIC_ARRAY, color), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(PRIMITIVE, required_boxes), TID(int32_t) },
    { FLD(PRIMITIVE, required_cabinets), TID(int32_t) },
    { FLD(PRIMITIVE, required_racks), TID(int32_t) },
    { FLD(PRIMITIVE, required_stands), TID(int32_t) },
    { FLD(PRIMITIVE, required_office), TID(int32_t) },
    { FLD(PRIMITIVE, required_bedroom), TID(int32_t) },
    { FLD(PRIMITIVE, required_dining), TID(int32_t) },
    { FLD(PRIMITIVE, required_tomb), TID(int32_t) },
    { FLD(PRIMITIVE, mandate_max), TID(int32_t) },
    { FLD(PRIMITIVE, demand_max), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_position_raw::_identity(sizeof(entity_position_raw), &allocator_fn<entity_position_raw>, NULL, "entity_position_raw",NULL,entity_position_raw_fields);
  #define CUR_STRUCT entity_raw::T_equipment
  static const struct_field_info entity_raw_doT_Dot_T_equipment_fields[] = {
    { FLD(CONTAINER, digger_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, weapon_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, armor_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, ammo_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, helm_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, gloves_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shoes_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pants_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shield_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, trapcomp_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, toy_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, instrument_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, tool_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, siegeammo_id), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, armor_rarity), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, helm_rarity), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, gloves_rarity), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shoes_rarity), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pants_rarity), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, digger_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, weapon_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, armor_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, ammo_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, helm_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, gloves_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, shoes_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, pants_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, shield_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, trapcomp_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, toy_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, instrument_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, siegeammo_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, tool_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_raw::T_equipment::_identity(sizeof(entity_raw::T_equipment), &allocator_fn<entity_raw::T_equipment>, &entity_raw::_identity, "T_equipment",NULL,entity_raw_doT_Dot_T_equipment_fields);
  #define CUR_STRUCT entity_raw::T_symbols
  static const struct_field_info entity_raw_doT_Dot_T_symbols_fields[] = {
    { FLD(STATIC_ARRAY, symbols1), identity_traits<df::language_word_table >::get(), 14, NULL },
    { FLD(STATIC_ARRAY, symbols2), identity_traits<df::language_word_table >::get(), 14, NULL },
    { FLD(STATIC_ARRAY, select_symbol), identity_traits<std::vector<std::string* > >::get(), 14, NULL },
    { FLD(STATIC_ARRAY, subselect_symbol), identity_traits<std::vector<std::string* > >::get(), 14, NULL },
    { FLD(STATIC_ARRAY, cull_symbol), identity_traits<std::vector<std::string* > >::get(), 14, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_raw::T_symbols::_identity(sizeof(entity_raw::T_symbols), &allocator_fn<entity_raw::T_symbols>, &entity_raw::_identity, "T_symbols",NULL,entity_raw_doT_Dot_T_symbols_fields);
  #define CUR_STRUCT entity_raw::T_progress_trigger
  static const struct_field_info entity_raw_doT_Dot_T_progress_trigger_fields[] = {
    { FLD(PRIMITIVE, population), TID(int16_t) },
    { FLD(PRIMITIVE, production), TID(int16_t) },
    { FLD(PRIMITIVE, trade), TID(int16_t) },
    { FLD(PRIMITIVE, pop_siege), TID(int16_t) },
    { FLD(PRIMITIVE, prod_siege), TID(int16_t) },
    { FLD(PRIMITIVE, trade_siege), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_raw::T_progress_trigger::_identity(sizeof(entity_raw::T_progress_trigger), &allocator_fn<entity_raw::T_progress_trigger>, &entity_raw::_identity, "T_progress_trigger",NULL,entity_raw_doT_Dot_T_progress_trigger_fields);
  #define CUR_STRUCT entity_raw::T_jobs
  static const struct_field_info entity_raw_doT_Dot_T_jobs_fields[] = {
    { FLD(STATIC_ARRAY, permitted_job), identity_traits<bool >::get(), 112, TID(profession) },
    { FLD(STATIC_ARRAY, permitted_labor), identity_traits<bool >::get(), 94, TID(unit_labor) },
    { FLD(STATIC_ARRAY, permitted_skill), identity_traits<bool >::get(), 118, TID(job_skill) },
    { FLD(STATIC_ARRAY, world_construction), identity_traits<bool >::get(), 4, TID(world_construction_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_raw::T_jobs::_identity(sizeof(entity_raw::T_jobs), &allocator_fn<entity_raw::T_jobs>, &entity_raw::_identity, "T_jobs",NULL,entity_raw_doT_Dot_T_jobs_fields);
  #define CUR_STRUCT entity_raw::T_tissue_styles
  static const struct_field_info entity_raw_doT_Dot_T_tissue_styles_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(CONTAINER, preferred_shapings), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, maintain_length_min), TID(int32_t) },
    { FLD(PRIMITIVE, maintain_length_max), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_raw::T_tissue_styles::_identity(sizeof(entity_raw::T_tissue_styles), &allocator_fn<entity_raw::T_tissue_styles>, &entity_raw::_identity, "T_tissue_styles",NULL,entity_raw_doT_Dot_T_tissue_styles_fields);
  #define CUR_STRUCT entity_raw::T_workshops
  static const struct_field_info entity_raw_doT_Dot_T_workshops_fields[] = {
    { FLD(STL_VECTOR_PTR, permitted_building_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, permitted_building_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, permitted_reaction_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, permitted_reaction_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_raw::T_workshops::_identity(sizeof(entity_raw::T_workshops), &allocator_fn<entity_raw::T_workshops>, &entity_raw::_identity, "T_workshops",NULL,entity_raw_doT_Dot_T_workshops_fields);
  #define CUR_STRUCT entity_raw::T_land_holder_trigger
  static const struct_field_info entity_raw_doT_Dot_T_land_holder_trigger_fields[] = {
    { FLD(STATIC_ARRAY, num), identity_traits<int32_t >::get(), 10, NULL },
    { FLD(STATIC_ARRAY, population), identity_traits<int32_t >::get(), 10, NULL },
    { FLD(STATIC_ARRAY, wealth), identity_traits<int32_t >::get(), 10, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_raw::T_land_holder_trigger::_identity(sizeof(entity_raw::T_land_holder_trigger), &allocator_fn<entity_raw::T_land_holder_trigger>, &entity_raw::_identity, "T_land_holder_trigger",NULL,entity_raw_doT_Dot_T_land_holder_trigger_fields);
  #define CUR_STRUCT entity_raw
  static const struct_field_info entity_raw_fields[] = {
    { FLD(PRIMITIVE, code), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, creature_ids), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, creatures), identity_traits<std::string >::get(), 0, NULL },
    { FLD(SUBSTRUCT, equipment), &entity_raw::T_equipment::_identity },
    { FLD(CONTAINER, currency_value), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::entity_raw_flags> >::get(), 0, TID(entity_raw_flags) },
    { FLD(PRIMITIVE, translation), identity_traits<std::string >::get() },
    { FLD(SUBSTRUCT, symbols), &entity_raw::T_symbols::_identity },
    { FLD(STATIC_ARRAY, sphere_alignment), identity_traits<int32_t >::get(), 130, TID(sphere_type) },
    { FLD(STATIC_ARRAY, art_facet_modifier), identity_traits<int32_t >::get(), 4, TID(art_facet_type) },
    { FLD(STATIC_ARRAY, art_image_element_modifier), identity_traits<int32_t >::get(), 5, TID(art_image_element_type) },
    { FLD(STATIC_ARRAY, item_improvement_modifier), identity_traits<int32_t >::get(), 11, TID(improvement_type) },
    { FLD(PRIMITIVE, adventure_tier), TID(int32_t) },
    { FLD(STATIC_ARRAY, friendly_color), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(PRIMITIVE, default_site_type), TID(int32_t) },
    { FLD(STATIC_ARRAY, likes_site), identity_traits<int8_t >::get(), 11, TID(site_type) },
    { FLD(STATIC_ARRAY, tolerates_site), identity_traits<int8_t >::get(), 11, TID(site_type) },
    { FLD(STATIC_ARRAY, biome_support), identity_traits<int32_t >::get(), 51, TID(biome_type) },
    { FLD(STATIC_ARRAY, start_biome), identity_traits<int8_t >::get(), 51, TID(biome_type) },
    { FLD(STATIC_ARRAY, settlement_biome), identity_traits<int8_t >::get(), 51, TID(biome_type) },
    { FLD(STATIC_ARRAY, active_season), identity_traits<int8_t >::get(), 4, NULL },
    { FLD(SUBSTRUCT, progress_trigger), &entity_raw::T_progress_trigger::_identity },
    { FLD(STATIC_ARRAY, ethic), identity_traits<df::ethic_response >::get(), 22, TID(ethic_type) },
    { FLD(STATIC_ARRAY, values), identity_traits<int32_t >::get(), 32, TID(value_type) },
    { FLD(PRIMITIVE, max_site_pop_number), TID(int32_t) },
    { FLD(PRIMITIVE, max_pop_number), TID(int32_t) },
    { FLD(PRIMITIVE, max_starting_civ_number), TID(int32_t) },
    { FLD(CONTAINER, religion), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, religion_sphere), identity_traits<std::vector<enum_field<df::sphere_type,int16_t> > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, jobs), &entity_raw::T_jobs::_identity },
    { FLD(STL_VECTOR_PTR, positions), identity_traits<df::entity_position_raw >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, variable_positions), identity_traits<int8_t >::get(), 25, TID(entity_position_responsibility) },
    { FLD(STATIC_ARRAY, site_variable_positions), identity_traits<int8_t >::get(), 25, TID(entity_position_responsibility) },
    { FLD(STL_VECTOR_PTR, tissue_styles), &entity_raw::T_tissue_styles::_identity, 0, NULL },
    { FLD(SUBSTRUCT, workshops), &entity_raw::T_workshops::_identity },
    { FLD(SUBSTRUCT, land_holder_trigger), &entity_raw::T_land_holder_trigger::_identity },
    { FLD(PRIMITIVE, banditry), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, gem_shapes_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, stone_shapes_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, gem_shapes), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, stone_shapes), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, source_hfid), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, currency_str1), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, currency_str2), identity_traits<std::string >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_raw::_identity(sizeof(entity_raw), &allocator_fn<entity_raw>, NULL, "entity_raw",NULL,entity_raw_fields);
  #define CUR_STRUCT entity_recipe
  static const struct_field_info entity_recipe_fields[] = {
    { FLD(PRIMITIVE, subtype), TID(int16_t) },
    { FLD(CONTAINER, item_types), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, item_subtypes), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mat_types), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mat_indices), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_recipe::_identity(sizeof(entity_recipe), &allocator_fn<entity_recipe>, NULL, "entity_recipe",NULL,entity_recipe_fields);
  #define CUR_STRUCT entity_sell_prices
  static const struct_field_info entity_sell_prices_fields[] = {
    { FLD(POINTER, items), identity_traits<df::entity_sell_requests >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, price), identity_traits<std::vector<int32_t > >::get(), 107, TID(entity_sell_category) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_sell_prices::_identity(sizeof(entity_sell_prices), &allocator_fn<entity_sell_prices>, NULL, "entity_sell_prices",NULL,entity_sell_prices_fields);
  #define CUR_STRUCT entity_sell_requests
  static const struct_field_info entity_sell_requests_fields[] = {
    { FLD(STATIC_ARRAY, priority), identity_traits<std::vector<int8_t > >::get(), 107, TID(entity_sell_category) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_sell_requests::_identity(sizeof(entity_sell_requests), &allocator_fn<entity_sell_requests>, NULL, "entity_sell_requests",NULL,entity_sell_requests_fields);
  #define CUR_STRUCT entity_site_link::T_anon_12
  static const struct_field_info entity_site_link_doT_Dot_T_anon_12_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_site_link::T_anon_12::_identity(sizeof(entity_site_link::T_anon_12), &allocator_fn<entity_site_link::T_anon_12>, &entity_site_link::_identity, "T_anon_12",NULL,entity_site_link_doT_Dot_T_anon_12_fields);
  #define CUR_STRUCT entity_site_link
  static const struct_field_info entity_site_link_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD(PRIMITIVE, anon_9), TID(int32_t) },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { FLD(PRIMITIVE, anon_11), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, anon_12), &entity_site_link::T_anon_12::_identity, 0, NULL },
    { FLD(PRIMITIVE, anon_13), TID(int32_t) },
    { FLD(PRIMITIVE, anon_14), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_site_link::_identity(sizeof(entity_site_link), &allocator_fn<entity_site_link>, NULL, "entity_site_link",NULL,entity_site_link_fields);
  #define CUR_STRUCT entity_tissue_style
  static const struct_field_info entity_tissue_style_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(CONTAINER, preferred_shapings), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, maintain_length_min), TID(int32_t) },
    { FLD(PRIMITIVE, maintain_length_max), TID(int32_t) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_tissue_style::_identity(sizeof(entity_tissue_style), &allocator_fn<entity_tissue_style>, NULL, "entity_tissue_style",NULL,entity_tissue_style_fields);
  #define CUR_STRUCT entity_uniform
  static const struct_field_info entity_uniform_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int16_t) },
    { FLD(STATIC_ARRAY, uniform_item_types), identity_traits<std::vector<df::item_type > >::get(), 7, TID(uniform_category) },
    { FLD(STATIC_ARRAY, uniform_item_subtypes), identity_traits<std::vector<int16_t > >::get(), 7, TID(uniform_category) },
    { FLD(STATIC_ARRAY, uniform_item_info), identity_traits<std::vector<df::entity_uniform_item* > >::get(), 7, TID(uniform_category) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(SUBSTRUCT, flags), TID(uniform_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_uniform::_identity(sizeof(entity_uniform), &allocator_fn<entity_uniform>, NULL, "entity_uniform",NULL,entity_uniform_fields);
  #define CUR_STRUCT entity_uniform_item
  static const struct_field_info entity_uniform_item_fields[] = {
    { FLD(PRIMITIVE, random_dye), TID(int8_t) },
    { FLD(PRIMITIVE, armorlevel), TID(int8_t) },
    { FLD(PRIMITIVE, item_color), TID(int16_t) },
    { FLD(PRIMITIVE, art_image_id), TID(int32_t) },
    { FLD(PRIMITIVE, art_image_subid), TID(int16_t) },
    { FLD(PRIMITIVE, image_thread_color), TID(int16_t) },
    { FLD(PRIMITIVE, image_material_class), TID(entity_material_category) },
    { FLD(PRIMITIVE, maker_race), TID(int16_t) },
    { FLD(SUBSTRUCT, indiv_choice), TID(uniform_indiv_choice) },
    { FLD(PRIMITIVE, mattype), TID(int16_t) },
    { FLD(PRIMITIVE, matindex), TID(int32_t) },
    { FLD(PRIMITIVE, material_class), TID(entity_material_category) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity entity_uniform_item::_identity(sizeof(entity_uniform_item), &allocator_fn<entity_uniform_item>, NULL, "entity_uniform_item",NULL,entity_uniform_item_fields);
  #define CUR_STRUCT feature
  static const struct_field_info feature_fields[] = {
    { FLD(STL_VECTOR_PTR, population), identity_traits<df::world_population >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int16_t) },
    { FLD(SUBSTRUCT, embark_pos), &coord2d_path::_identity },
    { FLD(CONTAINER, min_map_z), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, max_map_z), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature::_identity(sizeof(feature), &allocator_fn<feature>, "feature","featurest",NULL,feature_fields);
  #define CUR_STRUCT feature_alteration
  static const struct_field_info feature_alteration_fields[] = {
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_alteration::_identity(sizeof(feature_alteration), &allocator_fn<feature_alteration>, "feature_alteration","feature_alterationst",NULL,feature_alteration_fields);
  #define CUR_STRUCT feature_alteration_new_lava_fill_zst
  static const struct_field_info feature_alteration_new_lava_fill_zst_fields[] = {
    { FLD(PRIMITIVE, magma_fill_z), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_alteration_new_lava_fill_zst::_identity(sizeof(feature_alteration_new_lava_fill_zst), &allocator_fn<feature_alteration_new_lava_fill_zst>, "feature_alteration_new_lava_fill_zst",NULL,&feature_alteration::_identity,feature_alteration_new_lava_fill_zst_fields);
  #define CUR_STRUCT feature_alteration_new_pop_maxst
  static const struct_field_info feature_alteration_new_pop_maxst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_alteration_new_pop_maxst::_identity(sizeof(feature_alteration_new_pop_maxst), &allocator_fn<feature_alteration_new_pop_maxst>, "feature_alteration_new_pop_maxst",NULL,&feature_alteration::_identity,feature_alteration_new_pop_maxst_fields);
  virtual_identity feature_cavest::_identity(sizeof(feature_cavest), &allocator_fn<feature_cavest>, "feature_cavest",NULL,&feature::_identity,NULL);
  virtual_identity feature_deep_special_tubest::_identity(sizeof(feature_deep_special_tubest), &allocator_fn<feature_deep_special_tubest>, "feature_deep_special_tubest",NULL,&feature::_identity,NULL);
  virtual_identity feature_deep_surface_portalst::_identity(sizeof(feature_deep_surface_portalst), &allocator_fn<feature_deep_surface_portalst>, "feature_deep_surface_portalst",NULL,&feature::_identity,NULL);
  #define CUR_STRUCT feature_init
  static const struct_field_info feature_init_fields[] = {
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::feature_init_flags> >::get(), 0, TID(feature_init_flags) },
    { FLD(STL_VECTOR_PTR, alterations), identity_traits<df::feature_alteration >::get(), 0, NULL },
    { FLD(PRIMITIVE, start_x), TID(int16_t) },
    { FLD(PRIMITIVE, start_y), TID(int16_t) },
    { FLD(PRIMITIVE, end_x), TID(int16_t) },
    { FLD(PRIMITIVE, end_y), TID(int16_t) },
    { FLD(PRIMITIVE, start_depth), TID(int16_t) },
    { FLD(PRIMITIVE, end_depth), TID(int16_t) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, createFeature) },
    { METHOD(OBJ_METHOD, recreateFeature) },
    { METHOD(OBJ_METHOD, destroyFeature) },
    { METHOD(OBJ_METHOD, getFeature) },
    { METHOD(OBJ_METHOD, getMaterial) },
    { METHOD(OBJ_METHOD, getColor) },
    { METHOD(OBJ_METHOD, getName) },
    { METHOD(OBJ_METHOD, isWater) },
    { METHOD(OBJ_METHOD, isSubterranean) },
    { METHOD(OBJ_METHOD, isMagma) },
    { METHOD(OBJ_METHOD, isChasm) },
    { METHOD(OBJ_METHOD, isLayer) },
    { METHOD(OBJ_METHOD, getLayer) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_init::_identity(sizeof(feature_init), &allocator_fn<feature_init>, "feature_init","feature_initst",NULL,feature_init_fields);
  #define CUR_STRUCT feature_init_cavest
  static const struct_field_info feature_init_cavest_fields[] = {
    { FLD(POINTER, feature), identity_traits<df::feature_cavest >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_init_cavest::_identity(sizeof(feature_init_cavest), &allocator_fn<feature_init_cavest>, "feature_init_cavest",NULL,&feature_init::_identity,feature_init_cavest_fields);
  #define CUR_STRUCT feature_init_deep_special_tubest
  static const struct_field_info feature_init_deep_special_tubest_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(POINTER, feature), identity_traits<df::feature_deep_special_tubest >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_init_deep_special_tubest::_identity(sizeof(feature_init_deep_special_tubest), &allocator_fn<feature_init_deep_special_tubest>, "feature_init_deep_special_tubest",NULL,&feature_init::_identity,feature_init_deep_special_tubest_fields);
  #define CUR_STRUCT feature_init_deep_surface_portalst
  static const struct_field_info feature_init_deep_surface_portalst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(POINTER, feature), identity_traits<df::feature_deep_surface_portalst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_init_deep_surface_portalst::_identity(sizeof(feature_init_deep_surface_portalst), &allocator_fn<feature_init_deep_surface_portalst>, "feature_init_deep_surface_portalst",NULL,&feature_init::_identity,feature_init_deep_surface_portalst_fields);
  #define CUR_STRUCT feature_init_magma_core_from_layerst
  static const struct_field_info feature_init_magma_core_from_layerst_fields[] = {
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(POINTER, feature), identity_traits<df::feature_magma_core_from_layerst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_init_magma_core_from_layerst::_identity(sizeof(feature_init_magma_core_from_layerst), &allocator_fn<feature_init_magma_core_from_layerst>, "feature_init_magma_core_from_layerst",NULL,&feature_init::_identity,feature_init_magma_core_from_layerst_fields);
  #define CUR_STRUCT feature_init_magma_poolst
  static const struct_field_info feature_init_magma_poolst_fields[] = {
    { FLD(POINTER, feature), identity_traits<df::feature_magma_poolst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_init_magma_poolst::_identity(sizeof(feature_init_magma_poolst), &allocator_fn<feature_init_magma_poolst>, "feature_init_magma_poolst",NULL,&feature_init::_identity,feature_init_magma_poolst_fields);
  #define CUR_STRUCT feature_init_outdoor_riverst
  static const struct_field_info feature_init_outdoor_riverst_fields[] = {
    { FLD(POINTER, feature), identity_traits<df::feature_outdoor_riverst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_init_outdoor_riverst::_identity(sizeof(feature_init_outdoor_riverst), &allocator_fn<feature_init_outdoor_riverst>, "feature_init_outdoor_riverst",NULL,&feature_init::_identity,feature_init_outdoor_riverst_fields);
  #define CUR_STRUCT feature_init_pitst
  static const struct_field_info feature_init_pitst_fields[] = {
    { FLD(POINTER, feature), identity_traits<df::feature_pitst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_init_pitst::_identity(sizeof(feature_init_pitst), &allocator_fn<feature_init_pitst>, "feature_init_pitst",NULL,&feature_init::_identity,feature_init_pitst_fields);
  #define CUR_STRUCT feature_init_subterranean_from_layerst
  static const struct_field_info feature_init_subterranean_from_layerst_fields[] = {
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(POINTER, feature), identity_traits<df::feature_subterranean_from_layerst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_init_subterranean_from_layerst::_identity(sizeof(feature_init_subterranean_from_layerst), &allocator_fn<feature_init_subterranean_from_layerst>, "feature_init_subterranean_from_layerst",NULL,&feature_init::_identity,feature_init_subterranean_from_layerst_fields);
  #define CUR_STRUCT feature_init_underworld_from_layerst
  static const struct_field_info feature_init_underworld_from_layerst_fields[] = {
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(POINTER, feature), identity_traits<df::feature_underworld_from_layerst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_init_underworld_from_layerst::_identity(sizeof(feature_init_underworld_from_layerst), &allocator_fn<feature_init_underworld_from_layerst>, "feature_init_underworld_from_layerst",NULL,&feature_init::_identity,feature_init_underworld_from_layerst_fields);
  #define CUR_STRUCT feature_init_volcanost
  static const struct_field_info feature_init_volcanost_fields[] = {
    { FLD(POINTER, feature), identity_traits<df::feature_volcanost >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_init_volcanost::_identity(sizeof(feature_init_volcanost), &allocator_fn<feature_init_volcanost>, "feature_init_volcanost",NULL,&feature_init::_identity,feature_init_volcanost_fields);
  virtual_identity feature_magma_core_from_layerst::_identity(sizeof(feature_magma_core_from_layerst), &allocator_fn<feature_magma_core_from_layerst>, "feature_magma_core_from_layerst",NULL,&feature::_identity,NULL);
  #define CUR_STRUCT feature_magma_poolst
  static const struct_field_info feature_magma_poolst_fields[] = {
    { FLD(PRIMITIVE, magma_fill_z), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_magma_poolst::_identity(sizeof(feature_magma_poolst), &allocator_fn<feature_magma_poolst>, "feature_magma_poolst",NULL,&feature::_identity,feature_magma_poolst_fields);
  virtual_identity feature_outdoor_riverst::_identity(sizeof(feature_outdoor_riverst), &allocator_fn<feature_outdoor_riverst>, "feature_outdoor_riverst",NULL,&feature::_identity,NULL);
  virtual_identity feature_pitst::_identity(sizeof(feature_pitst), &allocator_fn<feature_pitst>, "feature_pitst",NULL,&feature::_identity,NULL);
  virtual_identity feature_subterranean_from_layerst::_identity(sizeof(feature_subterranean_from_layerst), &allocator_fn<feature_subterranean_from_layerst>, "feature_subterranean_from_layerst",NULL,&feature::_identity,NULL);
  virtual_identity feature_underworld_from_layerst::_identity(sizeof(feature_underworld_from_layerst), &allocator_fn<feature_underworld_from_layerst>, "feature_underworld_from_layerst",NULL,&feature::_identity,NULL);
  #define CUR_STRUCT feature_volcanost
  static const struct_field_info feature_volcanost_fields[] = {
    { FLD(PRIMITIVE, magma_fill_z), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity feature_volcanost::_identity(sizeof(feature_volcanost), &allocator_fn<feature_volcanost>, "feature_volcanost",NULL,&feature::_identity,feature_volcanost_fields);
  #define CUR_STRUCT file_compressorst
  static const struct_field_info file_compressorst_fields[] = {
    { FLD(PRIMITIVE, compressed), TID(bool) },
    { FLD(PRIMITIVE, f), identity_traits<std::fstream >::get() },
    { FLD(POINTER, in_buffer), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(PRIMITIVE, in_buffersize), TID(int32_t) },
    { FLD(PRIMITIVE, in_buffer_amount_loaded), TID(int32_t) },
    { FLD(PRIMITIVE, in_buffer_position), TID(int32_t) },
    { FLD(POINTER, out_buffer), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(PRIMITIVE, out_buffersize), TID(int32_t) },
    { FLD(PRIMITIVE, out_buffer_amount_written), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity file_compressorst::_identity(sizeof(file_compressorst), &allocator_fn<file_compressorst>, NULL, "file_compressorst",NULL,file_compressorst_fields);
  #define CUR_STRUCT fire
  static const struct_field_info fire_fields[] = {
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(PRIMITIVE, timer), TID(int16_t) },
    { FLD(PRIMITIVE, temperature), TID(uint16_t) },
    { FLD(PRIMITIVE, unk1), TID(uint16_t) },
    { FLD(PRIMITIVE, unk2), TID(uint16_t) },
    { FLD(PRIMITIVE, unk3), TID(uint16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity fire::_identity(sizeof(fire), &allocator_fn<fire>, NULL, "fire",NULL,fire_fields);
  #define CUR_STRUCT flow_guide
  static const struct_field_info flow_guide_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int8_t) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity flow_guide::_identity(sizeof(flow_guide), &allocator_fn<flow_guide>, "flow_guide","flow_guidest",NULL,flow_guide_fields);
  #define CUR_STRUCT flow_guide_item_cloudst
  static const struct_field_info flow_guide_item_cloudst_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mattype), TID(int16_t) },
    { FLD(PRIMITIVE, matindex), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD(STATIC_ARRAY, anon_1), identity_traits<df::coord >::get(), 15, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity flow_guide_item_cloudst::_identity(sizeof(flow_guide_item_cloudst), &allocator_fn<flow_guide_item_cloudst>, "flow_guide_item_cloudst",NULL,&flow_guide::_identity,flow_guide_item_cloudst_fields);
  #define CUR_STRUCT flow_guide_trailing_flowst
  static const struct_field_info flow_guide_trailing_flowst_fields[] = {
    { FLD(STATIC_ARRAY, anon_1), identity_traits<df::coord >::get(), 15, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity flow_guide_trailing_flowst::_identity(sizeof(flow_guide_trailing_flowst), &allocator_fn<flow_guide_trailing_flowst>, "flow_guide_trailing_flowst",NULL,&flow_guide::_identity,flow_guide_trailing_flowst_fields);
  #define CUR_STRUCT flow_info
  static const struct_field_info flow_info_fields[] = {
    { FLD(PRIMITIVE, type), TID(flow_type) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, density), TID(int16_t) },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(SUBSTRUCT, dest), &coord::_identity },
    { FLD(PRIMITIVE, expanding), TID(bool) },
    { FLD(PRIMITIVE, reuse), TID(bool) },
    { FLD(PRIMITIVE, guide_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity flow_info::_identity(sizeof(flow_info), &allocator_fn<flow_info>, NULL, "flow_info",NULL,flow_info_fields);
  #define CUR_STRUCT flow_reuse_pool
  static const struct_field_info flow_reuse_pool_fields[] = {
    { FLD(PRIMITIVE, reuse_idx), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(flow_reuse_pool::T_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity flow_reuse_pool::_identity(sizeof(flow_reuse_pool), &allocator_fn<flow_reuse_pool>, NULL, "flow_reuse_pool",NULL,flow_reuse_pool_fields);
  #define CUR_STRUCT gait_info
  static const struct_field_info gait_info_fields[] = {
    { FLD(PRIMITIVE, action_string_idx), TID(int32_t) },
    { FLD(PRIMITIVE, full_speed), TID(int32_t) },
    { FLD(PRIMITIVE, buildup_time), TID(int32_t) },
    { FLD(PRIMITIVE, turn_max), TID(int32_t) },
    { FLD(PRIMITIVE, start_speed), TID(int32_t) },
    { FLD(PRIMITIVE, energy_use), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(gait_info::T_flags) },
    { FLD(PRIMITIVE, stealth_slows), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity gait_info::_identity(sizeof(gait_info), &allocator_fn<gait_info>, NULL, "gait_info",NULL,gait_info_fields);
  #define CUR_STRUCT general_ref
  static const struct_field_info general_ref_fields[] = {
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, getItem) },
    { METHOD(OBJ_METHOD, getUnit) },
    { METHOD(OBJ_METHOD, getProjectile) },
    { METHOD(OBJ_METHOD, getBuilding) },
    { METHOD(OBJ_METHOD, getEntity) },
    { METHOD(OBJ_METHOD, getArtifact) },
    { METHOD(OBJ_METHOD, getNemesis) },
    { METHOD(OBJ_METHOD, setID) },
    { METHOD(OBJ_METHOD, getID) },
    { METHOD(OBJ_METHOD, setLocation) },
    { METHOD(OBJ_METHOD, getLocation) },
    { METHOD(OBJ_METHOD, clone) },
    { METHOD(OBJ_METHOD, getSecretName) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref::_identity(sizeof(general_ref), &allocator_fn<general_ref>, "general_ref","general_refst",NULL,general_ref_fields);
  #define CUR_STRUCT general_ref_abstract_buildingst
  static const struct_field_info general_ref_abstract_buildingst_fields[] = {
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, building_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_abstract_buildingst::_identity(sizeof(general_ref_abstract_buildingst), &allocator_fn<general_ref_abstract_buildingst>, "general_ref_abstract_buildingst",NULL,&general_ref::_identity,general_ref_abstract_buildingst_fields);
  #define CUR_STRUCT general_ref_artifact
  static const struct_field_info general_ref_artifact_fields[] = {
    { FLD(PRIMITIVE, artifact_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_artifact::_identity(sizeof(general_ref_artifact), &allocator_fn<general_ref_artifact>, "general_ref_artifact","general_ref_artifactst",&general_ref::_identity,general_ref_artifact_fields);
  #define CUR_STRUCT general_ref_building
  static const struct_field_info general_ref_building_fields[] = {
    { FLD(PRIMITIVE, building_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_building::_identity(sizeof(general_ref_building), &allocator_fn<general_ref_building>, "general_ref_building","general_ref_buildingst",&general_ref::_identity,general_ref_building_fields);
  virtual_identity general_ref_building_cagedst::_identity(sizeof(general_ref_building_cagedst), &allocator_fn<general_ref_building_cagedst>, "general_ref_building_cagedst",NULL,&general_ref_building::_identity,NULL);
  virtual_identity general_ref_building_chainst::_identity(sizeof(general_ref_building_chainst), &allocator_fn<general_ref_building_chainst>, "general_ref_building_chainst",NULL,&general_ref_building::_identity,NULL);
  virtual_identity general_ref_building_civzone_assignedst::_identity(sizeof(general_ref_building_civzone_assignedst), &allocator_fn<general_ref_building_civzone_assignedst>, "general_ref_building_civzone_assignedst",NULL,&general_ref_building::_identity,NULL);
  virtual_identity general_ref_building_destinationst::_identity(sizeof(general_ref_building_destinationst), &allocator_fn<general_ref_building_destinationst>, "general_ref_building_destinationst",NULL,&general_ref_building::_identity,NULL);
  virtual_identity general_ref_building_holderst::_identity(sizeof(general_ref_building_holderst), &allocator_fn<general_ref_building_holderst>, "general_ref_building_holderst",NULL,&general_ref_building::_identity,NULL);
  virtual_identity general_ref_building_nest_boxst::_identity(sizeof(general_ref_building_nest_boxst), &allocator_fn<general_ref_building_nest_boxst>, "general_ref_building_nest_boxst",NULL,&general_ref_building::_identity,NULL);
  virtual_identity general_ref_building_triggerst::_identity(sizeof(general_ref_building_triggerst), &allocator_fn<general_ref_building_triggerst>, "general_ref_building_triggerst",NULL,&general_ref_building::_identity,NULL);
  virtual_identity general_ref_building_triggertargetst::_identity(sizeof(general_ref_building_triggertargetst), &allocator_fn<general_ref_building_triggertargetst>, "general_ref_building_triggertargetst",NULL,&general_ref_building::_identity,NULL);
  virtual_identity general_ref_building_use_target_1st::_identity(sizeof(general_ref_building_use_target_1st), &allocator_fn<general_ref_building_use_target_1st>, "general_ref_building_use_target_1st",NULL,&general_ref_building::_identity,NULL);
  virtual_identity general_ref_building_use_target_2st::_identity(sizeof(general_ref_building_use_target_2st), &allocator_fn<general_ref_building_use_target_2st>, "general_ref_building_use_target_2st",NULL,&general_ref_building::_identity,NULL);
  #define CUR_STRUCT general_ref_building_well_tag
  static const struct_field_info general_ref_building_well_tag_fields[] = {
    { FLD(PRIMITIVE, direction), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_building_well_tag::_identity(sizeof(general_ref_building_well_tag), &allocator_fn<general_ref_building_well_tag>, "general_ref_building_well_tag","general_ref_building_well_tagst",&general_ref_building::_identity,general_ref_building_well_tag_fields);
  #define CUR_STRUCT general_ref_coinbatch
  static const struct_field_info general_ref_coinbatch_fields[] = {
    { FLD(PRIMITIVE, batch), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_coinbatch::_identity(sizeof(general_ref_coinbatch), &allocator_fn<general_ref_coinbatch>, "general_ref_coinbatch","general_ref_coinbatchst",&general_ref::_identity,general_ref_coinbatch_fields);
  virtual_identity general_ref_contained_in_itemst::_identity(sizeof(general_ref_contained_in_itemst), &allocator_fn<general_ref_contained_in_itemst>, "general_ref_contained_in_itemst",NULL,&general_ref_item::_identity,NULL);
  virtual_identity general_ref_contains_itemst::_identity(sizeof(general_ref_contains_itemst), &allocator_fn<general_ref_contains_itemst>, "general_ref_contains_itemst",NULL,&general_ref_item::_identity,NULL);
  virtual_identity general_ref_contains_unitst::_identity(sizeof(general_ref_contains_unitst), &allocator_fn<general_ref_contains_unitst>, "general_ref_contains_unitst",NULL,&general_ref_unit::_identity,NULL);
  #define CUR_STRUCT general_ref_creaturest
  static const struct_field_info general_ref_creaturest_fields[] = {
    { FLD(PRIMITIVE, race), TID(int32_t) },
    { FLD(PRIMITIVE, caste), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(general_ref_creaturest::T_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_creaturest::_identity(sizeof(general_ref_creaturest), &allocator_fn<general_ref_creaturest>, "general_ref_creaturest",NULL,&general_ref::_identity,general_ref_creaturest_fields);
  #define CUR_STRUCT general_ref_entity
  static const struct_field_info general_ref_entity_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_entity::_identity(sizeof(general_ref_entity), &allocator_fn<general_ref_entity>, "general_ref_entity","general_ref_entityst",&general_ref::_identity,general_ref_entity_fields);
  #define CUR_STRUCT general_ref_entity_art_image
  static const struct_field_info general_ref_entity_art_image_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_entity_art_image::_identity(sizeof(general_ref_entity_art_image), &allocator_fn<general_ref_entity_art_image>, "general_ref_entity_art_image","general_ref_entity_art_imagest",&general_ref::_identity,general_ref_entity_art_image_fields);
  virtual_identity general_ref_entity_itemownerst::_identity(sizeof(general_ref_entity_itemownerst), &allocator_fn<general_ref_entity_itemownerst>, "general_ref_entity_itemownerst",NULL,&general_ref_entity::_identity,NULL);
  virtual_identity general_ref_entity_offeredst::_identity(sizeof(general_ref_entity_offeredst), &allocator_fn<general_ref_entity_offeredst>, "general_ref_entity_offeredst",NULL,&general_ref_entity::_identity,NULL);
  #define CUR_STRUCT general_ref_entity_popst
  static const struct_field_info general_ref_entity_popst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, race), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(general_ref_entity_popst::T_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_entity_popst::_identity(sizeof(general_ref_entity_popst), &allocator_fn<general_ref_entity_popst>, "general_ref_entity_popst",NULL,&general_ref::_identity,general_ref_entity_popst_fields);
  virtual_identity general_ref_entity_stolenst::_identity(sizeof(general_ref_entity_stolenst), &allocator_fn<general_ref_entity_stolenst>, "general_ref_entity_stolenst",NULL,&general_ref_entity::_identity,NULL);
  #define CUR_STRUCT general_ref_feature_layerst
  static const struct_field_info general_ref_feature_layerst_fields[] = {
    { FLD(PRIMITIVE, underground_region_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_feature_layerst::_identity(sizeof(general_ref_feature_layerst), &allocator_fn<general_ref_feature_layerst>, "general_ref_feature_layerst",NULL,&general_ref::_identity,general_ref_feature_layerst_fields);
  #define CUR_STRUCT general_ref_historical_eventst
  static const struct_field_info general_ref_historical_eventst_fields[] = {
    { FLD(PRIMITIVE, event_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_historical_eventst::_identity(sizeof(general_ref_historical_eventst), &allocator_fn<general_ref_historical_eventst>, "general_ref_historical_eventst",NULL,&general_ref::_identity,general_ref_historical_eventst_fields);
  #define CUR_STRUCT general_ref_historical_figurest
  static const struct_field_info general_ref_historical_figurest_fields[] = {
    { FLD(PRIMITIVE, hist_figure_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_historical_figurest::_identity(sizeof(general_ref_historical_figurest), &allocator_fn<general_ref_historical_figurest>, "general_ref_historical_figurest",NULL,&general_ref::_identity,general_ref_historical_figurest_fields);
  #define CUR_STRUCT general_ref_interactionst
  static const struct_field_info general_ref_interactionst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_interactionst::_identity(sizeof(general_ref_interactionst), &allocator_fn<general_ref_interactionst>, "general_ref_interactionst",NULL,&general_ref::_identity,general_ref_interactionst_fields);
  virtual_identity general_ref_is_artifactst::_identity(sizeof(general_ref_is_artifactst), &allocator_fn<general_ref_is_artifactst>, "general_ref_is_artifactst",NULL,&general_ref_artifact::_identity,NULL);
  virtual_identity general_ref_is_nemesisst::_identity(sizeof(general_ref_is_nemesisst), &allocator_fn<general_ref_is_nemesisst>, "general_ref_is_nemesisst",NULL,&general_ref_nemesis::_identity,NULL);
  #define CUR_STRUCT general_ref_item
  static const struct_field_info general_ref_item_fields[] = {
    { FLD(PRIMITIVE, item_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_item::_identity(sizeof(general_ref_item), &allocator_fn<general_ref_item>, "general_ref_item","general_ref_itemst",&general_ref::_identity,general_ref_item_fields);
  #define CUR_STRUCT general_ref_item_type
  static const struct_field_info general_ref_item_type_fields[] = {
    { FLD(PRIMITIVE, type), identity_traits<enum_field<df::item_type,int32_t> >::get() },
    { FLD(PRIMITIVE, subtype), TID(int32_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_item_type::_identity(sizeof(general_ref_item_type), &allocator_fn<general_ref_item_type>, "general_ref_item_type","general_ref_item_typest",&general_ref::_identity,general_ref_item_type_fields);
  #define CUR_STRUCT general_ref_locationst
  static const struct_field_info general_ref_locationst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_locationst::_identity(sizeof(general_ref_locationst), &allocator_fn<general_ref_locationst>, "general_ref_locationst",NULL,&general_ref::_identity,general_ref_locationst_fields);
  #define CUR_STRUCT general_ref_mapsquare
  static const struct_field_info general_ref_mapsquare_fields[] = {
    { FLD(PRIMITIVE, tiletype), TID(tiletype) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_mapsquare::_identity(sizeof(general_ref_mapsquare), &allocator_fn<general_ref_mapsquare>, "general_ref_mapsquare","general_ref_mapsquarest",&general_ref::_identity,general_ref_mapsquare_fields);
  #define CUR_STRUCT general_ref_nemesis
  static const struct_field_info general_ref_nemesis_fields[] = {
    { FLD(PRIMITIVE, nemesis_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_nemesis::_identity(sizeof(general_ref_nemesis), &allocator_fn<general_ref_nemesis>, "general_ref_nemesis","general_ref_nemesisst",&general_ref::_identity,general_ref_nemesis_fields);
  #define CUR_STRUCT general_ref_projectile
  static const struct_field_info general_ref_projectile_fields[] = {
    { FLD(PRIMITIVE, projectile_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_projectile::_identity(sizeof(general_ref_projectile), &allocator_fn<general_ref_projectile>, "general_ref_projectile","general_ref_projectilest",&general_ref::_identity,general_ref_projectile_fields);
  #define CUR_STRUCT general_ref_sitest
  static const struct_field_info general_ref_sitest_fields[] = {
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_sitest::_identity(sizeof(general_ref_sitest), &allocator_fn<general_ref_sitest>, "general_ref_sitest",NULL,&general_ref::_identity,general_ref_sitest_fields);
  #define CUR_STRUCT general_ref_spherest
  static const struct_field_info general_ref_spherest_fields[] = {
    { FLD(PRIMITIVE, sphere_type), identity_traits<enum_field<df::sphere_type,int16_t> >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_spherest::_identity(sizeof(general_ref_spherest), &allocator_fn<general_ref_spherest>, "general_ref_spherest",NULL,&general_ref::_identity,general_ref_spherest_fields);
  #define CUR_STRUCT general_ref_subregionst
  static const struct_field_info general_ref_subregionst_fields[] = {
    { FLD(PRIMITIVE, region_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_subregionst::_identity(sizeof(general_ref_subregionst), &allocator_fn<general_ref_subregionst>, "general_ref_subregionst",NULL,&general_ref::_identity,general_ref_subregionst_fields);
  #define CUR_STRUCT general_ref_unit
  static const struct_field_info general_ref_unit_fields[] = {
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_unit::_identity(sizeof(general_ref_unit), &allocator_fn<general_ref_unit>, "general_ref_unit","general_ref_unitst",&general_ref::_identity,general_ref_unit_fields);
  virtual_identity general_ref_unit_beateest::_identity(sizeof(general_ref_unit_beateest), &allocator_fn<general_ref_unit_beateest>, "general_ref_unit_beateest",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_cageest::_identity(sizeof(general_ref_unit_cageest), &allocator_fn<general_ref_unit_cageest>, "general_ref_unit_cageest",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_foodreceiverst::_identity(sizeof(general_ref_unit_foodreceiverst), &allocator_fn<general_ref_unit_foodreceiverst>, "general_ref_unit_foodreceiverst",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_holderst::_identity(sizeof(general_ref_unit_holderst), &allocator_fn<general_ref_unit_holderst>, "general_ref_unit_holderst",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_infantst::_identity(sizeof(general_ref_unit_infantst), &allocator_fn<general_ref_unit_infantst>, "general_ref_unit_infantst",NULL,&general_ref_unit::_identity,NULL);
  #define CUR_STRUCT general_ref_unit_itemownerst
  static const struct_field_info general_ref_unit_itemownerst_fields[] = {
    { FLD(SUBSTRUCT, flags), TID(general_ref_unit_itemownerst::T_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity general_ref_unit_itemownerst::_identity(sizeof(general_ref_unit_itemownerst), &allocator_fn<general_ref_unit_itemownerst>, "general_ref_unit_itemownerst",NULL,&general_ref_unit::_identity,general_ref_unit_itemownerst_fields);
  virtual_identity general_ref_unit_kidnapeest::_identity(sizeof(general_ref_unit_kidnapeest), &allocator_fn<general_ref_unit_kidnapeest>, "general_ref_unit_kidnapeest",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_milkeest::_identity(sizeof(general_ref_unit_milkeest), &allocator_fn<general_ref_unit_milkeest>, "general_ref_unit_milkeest",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_patientst::_identity(sizeof(general_ref_unit_patientst), &allocator_fn<general_ref_unit_patientst>, "general_ref_unit_patientst",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_reporteest::_identity(sizeof(general_ref_unit_reporteest), &allocator_fn<general_ref_unit_reporteest>, "general_ref_unit_reporteest",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_riderst::_identity(sizeof(general_ref_unit_riderst), &allocator_fn<general_ref_unit_riderst>, "general_ref_unit_riderst",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_sheareest::_identity(sizeof(general_ref_unit_sheareest), &allocator_fn<general_ref_unit_sheareest>, "general_ref_unit_sheareest",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_slaughtereest::_identity(sizeof(general_ref_unit_slaughtereest), &allocator_fn<general_ref_unit_slaughtereest>, "general_ref_unit_slaughtereest",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_suckeest::_identity(sizeof(general_ref_unit_suckeest), &allocator_fn<general_ref_unit_suckeest>, "general_ref_unit_suckeest",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_tradebringerst::_identity(sizeof(general_ref_unit_tradebringerst), &allocator_fn<general_ref_unit_tradebringerst>, "general_ref_unit_tradebringerst",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_traineest::_identity(sizeof(general_ref_unit_traineest), &allocator_fn<general_ref_unit_traineest>, "general_ref_unit_traineest",NULL,&general_ref_unit::_identity,NULL);
  virtual_identity general_ref_unit_workerst::_identity(sizeof(general_ref_unit_workerst), &allocator_fn<general_ref_unit_workerst>, "general_ref_unit_workerst",NULL,&general_ref_unit::_identity,NULL);
  #define CUR_STRUCT enum_traits<geo_layer_type>::attr_entry_type
  static const struct_field_info enum_traits_lT_geo_layer_type_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, flag), identity_traits<df::inorganic_flags>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<geo_layer_type>::attr_entry_type::_identity(sizeof(enum_traits<geo_layer_type>::attr_entry_type), NULL, TID(geo_layer_type), "_attr_entry_type", NULL, enum_traits_lT_geo_layer_type_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT glowing_barrier
  static const struct_field_info glowing_barrier_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(CONTAINER, buildings), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity glowing_barrier::_identity(sizeof(glowing_barrier), &allocator_fn<glowing_barrier>, NULL, "glowing_barrier",NULL,glowing_barrier_fields);
  #define CUR_STRUCT graphic
  static const struct_field_info graphic_fields[] = {
    { FLD(PRIMITIVE, screenx), TID(int32_t) },
    { FLD(PRIMITIVE, screeny), TID(int32_t) },
    { FLD(PRIMITIVE, screenf), TID(int8_t) },
    { FLD(PRIMITIVE, screenb), TID(int8_t) },
    { FLD(PRIMITIVE, screenbright), TID(int8_t) },
    { FLD(POINTER, screen), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos), identity_traits<int32_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos_addcolor), identity_traits<int8_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos_grayscale), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos_cf), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos_cbr), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(STATIC_ARRAY, clipx), identity_traits<int32_t >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, clipy), identity_traits<int32_t >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, tex_pos), identity_traits<int32_t >::get(), 1, NULL },
    { FLD(PRIMITIVE, rect_id), TID(int32_t) },
    { FLD(STATIC_ARRAY, print_time), identity_traits<int64_t >::get(), 100, NULL },
    { FLD(PRIMITIVE, print_index), TID(int32_t) },
    { FLD(PRIMITIVE, display_frames), TID(int8_t) },
    { FLD(PRIMITIVE, force_full_display_count), TID(int16_t) },
    { FLD(PRIMITIVE, original_rect), TID(int8_t) },
    { FLD(PRIMITIVE, dimx), TID(int32_t) },
    { FLD(PRIMITIVE, dimy), TID(int32_t) },
    { FLD(PRIMITIVE, mouse_x), TID(int32_t) },
    { FLD(PRIMITIVE, mouse_y), TID(int32_t) },
    { FLD(POINTER, screen_limit), identity_traits<uint8_t >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity graphic::_identity(sizeof(graphic), &allocator_fn<graphic>, NULL, "graphic",NULL,graphic_fields);
  #define CUR_STRUCT hauling_route
  static const struct_field_info hauling_route_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, stops), identity_traits<df::hauling_stop >::get(), 0, NULL },
    { FLD(CONTAINER, vehicle_ids), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, vehicle_stops), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity hauling_route::_identity(sizeof(hauling_route), &allocator_fn<hauling_route>, NULL, "hauling_route",NULL,hauling_route_fields);
  #define CUR_STRUCT hauling_stop
  static const struct_field_info hauling_stop_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(SUBSTRUCT, settings), &stockpile_settings::_identity },
    { FLD(STL_VECTOR_PTR, conditions), identity_traits<df::stop_depart_condition >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, stockpiles), identity_traits<df::route_stockpile_link >::get(), 0, NULL },
    { FLD(PRIMITIVE, time_waiting), TID(int32_t) },
    { FLD(PRIMITIVE, cart_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity hauling_stop::_identity(sizeof(hauling_stop), &allocator_fn<hauling_stop>, NULL, "hauling_stop",NULL,hauling_stop_fields);
  #define CUR_STRUCT histfig_entity_link
  static const struct_field_info histfig_entity_link_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, link_strength), TID(int16_t) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, getPosition) },
    { METHOD(OBJ_METHOD, getPositionStartYear) },
    { METHOD(OBJ_METHOD, getPositionEndYear) },
    { METHOD(OBJ_METHOD, generate_xml) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity histfig_entity_link::_identity(sizeof(histfig_entity_link), &allocator_fn<histfig_entity_link>, "histfig_entity_link","histfig_entity_linkst",NULL,histfig_entity_link_fields);
  virtual_identity histfig_entity_link_criminalst::_identity(sizeof(histfig_entity_link_criminalst), &allocator_fn<histfig_entity_link_criminalst>, "histfig_entity_link_criminalst",NULL,&histfig_entity_link::_identity,NULL);
  virtual_identity histfig_entity_link_enemyst::_identity(sizeof(histfig_entity_link_enemyst), &allocator_fn<histfig_entity_link_enemyst>, "histfig_entity_link_enemyst",NULL,&histfig_entity_link::_identity,NULL);
  virtual_identity histfig_entity_link_former_memberst::_identity(sizeof(histfig_entity_link_former_memberst), &allocator_fn<histfig_entity_link_former_memberst>, "histfig_entity_link_former_memberst",NULL,&histfig_entity_link::_identity,NULL);
  virtual_identity histfig_entity_link_former_mercenaryst::_identity(sizeof(histfig_entity_link_former_mercenaryst), &allocator_fn<histfig_entity_link_former_mercenaryst>, "histfig_entity_link_former_mercenaryst",NULL,&histfig_entity_link::_identity,NULL);
  #define CUR_STRUCT histfig_entity_link_former_positionst
  static const struct_field_info histfig_entity_link_former_positionst_fields[] = {
    { FLD(PRIMITIVE, assignment_id), TID(int32_t) },
    { FLD(PRIMITIVE, start_year), TID(int32_t) },
    { FLD(PRIMITIVE, end_year), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity histfig_entity_link_former_positionst::_identity(sizeof(histfig_entity_link_former_positionst), &allocator_fn<histfig_entity_link_former_positionst>, "histfig_entity_link_former_positionst",NULL,&histfig_entity_link::_identity,histfig_entity_link_former_positionst_fields);
  virtual_identity histfig_entity_link_former_prisonerst::_identity(sizeof(histfig_entity_link_former_prisonerst), &allocator_fn<histfig_entity_link_former_prisonerst>, "histfig_entity_link_former_prisonerst",NULL,&histfig_entity_link::_identity,NULL);
  virtual_identity histfig_entity_link_former_slavest::_identity(sizeof(histfig_entity_link_former_slavest), &allocator_fn<histfig_entity_link_former_slavest>, "histfig_entity_link_former_slavest",NULL,&histfig_entity_link::_identity,NULL);
  #define CUR_STRUCT histfig_entity_link_former_squadst
  static const struct_field_info histfig_entity_link_former_squadst_fields[] = {
    { FLD(PRIMITIVE, squad_id), TID(int32_t) },
    { FLD(PRIMITIVE, start_year), TID(int32_t) },
    { FLD(PRIMITIVE, end_year), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity histfig_entity_link_former_squadst::_identity(sizeof(histfig_entity_link_former_squadst), &allocator_fn<histfig_entity_link_former_squadst>, "histfig_entity_link_former_squadst",NULL,&histfig_entity_link::_identity,histfig_entity_link_former_squadst_fields);
  virtual_identity histfig_entity_link_memberst::_identity(sizeof(histfig_entity_link_memberst), &allocator_fn<histfig_entity_link_memberst>, "histfig_entity_link_memberst",NULL,&histfig_entity_link::_identity,NULL);
  virtual_identity histfig_entity_link_mercenaryst::_identity(sizeof(histfig_entity_link_mercenaryst), &allocator_fn<histfig_entity_link_mercenaryst>, "histfig_entity_link_mercenaryst",NULL,&histfig_entity_link::_identity,NULL);
  #define CUR_STRUCT histfig_entity_link_position_claimst
  static const struct_field_info histfig_entity_link_position_claimst_fields[] = {
    { FLD(PRIMITIVE, assignment_id), TID(int32_t) },
    { FLD(PRIMITIVE, start_year), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity histfig_entity_link_position_claimst::_identity(sizeof(histfig_entity_link_position_claimst), &allocator_fn<histfig_entity_link_position_claimst>, "histfig_entity_link_position_claimst",NULL,&histfig_entity_link::_identity,histfig_entity_link_position_claimst_fields);
  #define CUR_STRUCT histfig_entity_link_positionst
  static const struct_field_info histfig_entity_link_positionst_fields[] = {
    { FLD(PRIMITIVE, assignment_id), TID(int32_t) },
    { FLD(PRIMITIVE, start_year), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity histfig_entity_link_positionst::_identity(sizeof(histfig_entity_link_positionst), &allocator_fn<histfig_entity_link_positionst>, "histfig_entity_link_positionst",NULL,&histfig_entity_link::_identity,histfig_entity_link_positionst_fields);
  virtual_identity histfig_entity_link_prisonerst::_identity(sizeof(histfig_entity_link_prisonerst), &allocator_fn<histfig_entity_link_prisonerst>, "histfig_entity_link_prisonerst",NULL,&histfig_entity_link::_identity,NULL);
  virtual_identity histfig_entity_link_slavest::_identity(sizeof(histfig_entity_link_slavest), &allocator_fn<histfig_entity_link_slavest>, "histfig_entity_link_slavest",NULL,&histfig_entity_link::_identity,NULL);
  #define CUR_STRUCT histfig_entity_link_squadst
  static const struct_field_info histfig_entity_link_squadst_fields[] = {
    { FLD(PRIMITIVE, squad_id), TID(int32_t) },
    { FLD(PRIMITIVE, squad_position), TID(int32_t) },
    { FLD(PRIMITIVE, start_year), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity histfig_entity_link_squadst::_identity(sizeof(histfig_entity_link_squadst), &allocator_fn<histfig_entity_link_squadst>, "histfig_entity_link_squadst",NULL,&histfig_entity_link::_identity,histfig_entity_link_squadst_fields);
  #define CUR_STRUCT histfig_hf_link
  static const struct_field_info histfig_hf_link_fields[] = {
    { FLD(PRIMITIVE, target_hf), TID(int32_t) },
    { FLD(PRIMITIVE, link_strength), TID(int16_t) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity histfig_hf_link::_identity(sizeof(histfig_hf_link), &allocator_fn<histfig_hf_link>, "histfig_hf_link","histfig_hf_linkst",NULL,histfig_hf_link_fields);
  virtual_identity histfig_hf_link_apprenticest::_identity(sizeof(histfig_hf_link_apprenticest), &allocator_fn<histfig_hf_link_apprenticest>, "histfig_hf_link_apprenticest",NULL,&histfig_hf_link::_identity,NULL);
  virtual_identity histfig_hf_link_childst::_identity(sizeof(histfig_hf_link_childst), &allocator_fn<histfig_hf_link_childst>, "histfig_hf_link_childst",NULL,&histfig_hf_link::_identity,NULL);
  #define CUR_STRUCT histfig_hf_link_companionst
  static const struct_field_info histfig_hf_link_companionst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity histfig_hf_link_companionst::_identity(sizeof(histfig_hf_link_companionst), &allocator_fn<histfig_hf_link_companionst>, "histfig_hf_link_companionst",NULL,&histfig_hf_link::_identity,histfig_hf_link_companionst_fields);
  virtual_identity histfig_hf_link_deityst::_identity(sizeof(histfig_hf_link_deityst), &allocator_fn<histfig_hf_link_deityst>, "histfig_hf_link_deityst",NULL,&histfig_hf_link::_identity,NULL);
  virtual_identity histfig_hf_link_fatherst::_identity(sizeof(histfig_hf_link_fatherst), &allocator_fn<histfig_hf_link_fatherst>, "histfig_hf_link_fatherst",NULL,&histfig_hf_link::_identity,NULL);
  virtual_identity histfig_hf_link_imprisonerst::_identity(sizeof(histfig_hf_link_imprisonerst), &allocator_fn<histfig_hf_link_imprisonerst>, "histfig_hf_link_imprisonerst",NULL,&histfig_hf_link::_identity,NULL);
  virtual_identity histfig_hf_link_loverst::_identity(sizeof(histfig_hf_link_loverst), &allocator_fn<histfig_hf_link_loverst>, "histfig_hf_link_loverst",NULL,&histfig_hf_link::_identity,NULL);
  virtual_identity histfig_hf_link_masterst::_identity(sizeof(histfig_hf_link_masterst), &allocator_fn<histfig_hf_link_masterst>, "histfig_hf_link_masterst",NULL,&histfig_hf_link::_identity,NULL);
  virtual_identity histfig_hf_link_motherst::_identity(sizeof(histfig_hf_link_motherst), &allocator_fn<histfig_hf_link_motherst>, "histfig_hf_link_motherst",NULL,&histfig_hf_link::_identity,NULL);
  virtual_identity histfig_hf_link_prisonerst::_identity(sizeof(histfig_hf_link_prisonerst), &allocator_fn<histfig_hf_link_prisonerst>, "histfig_hf_link_prisonerst",NULL,&histfig_hf_link::_identity,NULL);
  virtual_identity histfig_hf_link_spousest::_identity(sizeof(histfig_hf_link_spousest), &allocator_fn<histfig_hf_link_spousest>, "histfig_hf_link_spousest",NULL,&histfig_hf_link::_identity,NULL);
  #define CUR_STRUCT histfig_site_link
  static const struct_field_info histfig_site_link_fields[] = {
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, sub_id), TID(int32_t) },
    { FLD(PRIMITIVE, entity), TID(int32_t) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity histfig_site_link::_identity(sizeof(histfig_site_link), &allocator_fn<histfig_site_link>, "histfig_site_link","histfig_site_linkst",NULL,histfig_site_link_fields);
  virtual_identity histfig_site_link_hangoutst::_identity(sizeof(histfig_site_link_hangoutst), &allocator_fn<histfig_site_link_hangoutst>, "histfig_site_link_hangoutst",NULL,&histfig_site_link::_identity,NULL);
  virtual_identity histfig_site_link_home_site_abstract_buildingst::_identity(sizeof(histfig_site_link_home_site_abstract_buildingst), &allocator_fn<histfig_site_link_home_site_abstract_buildingst>, "histfig_site_link_home_site_abstract_buildingst",NULL,&histfig_site_link::_identity,NULL);
  virtual_identity histfig_site_link_home_site_realization_buildingst::_identity(sizeof(histfig_site_link_home_site_realization_buildingst), &allocator_fn<histfig_site_link_home_site_realization_buildingst>, "histfig_site_link_home_site_realization_buildingst",NULL,&histfig_site_link::_identity,NULL);
  virtual_identity histfig_site_link_home_site_realization_sulst::_identity(sizeof(histfig_site_link_home_site_realization_sulst), &allocator_fn<histfig_site_link_home_site_realization_sulst>, "histfig_site_link_home_site_realization_sulst",NULL,&histfig_site_link::_identity,NULL);
  virtual_identity histfig_site_link_lairst::_identity(sizeof(histfig_site_link_lairst), &allocator_fn<histfig_site_link_lairst>, "histfig_site_link_lairst",NULL,&histfig_site_link::_identity,NULL);
  virtual_identity histfig_site_link_seat_of_powerst::_identity(sizeof(histfig_site_link_seat_of_powerst), &allocator_fn<histfig_site_link_seat_of_powerst>, "histfig_site_link_seat_of_powerst",NULL,&histfig_site_link::_identity,NULL);
  #define CUR_STRUCT historical_entity::T_resources::T_metal
  static const struct_field_info historical_entity_doT_Dot_T_resources_doT_Dot_T_metal_fields[] = {
    { FLD(SUBSTRUCT, pick), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, weapon), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, ranged), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, ammo), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, ammo2), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, armor), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, anvil), &material_vec_ref::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_resources::T_metal::_identity(sizeof(historical_entity::T_resources::T_metal), &allocator_fn<historical_entity::T_resources::T_metal>, &historical_entity::T_resources::_identity, "T_metal",NULL,historical_entity_doT_Dot_T_resources_doT_Dot_T_metal_fields);
  #define CUR_STRUCT historical_entity::T_resources::T_organic
  static const struct_field_info historical_entity_doT_Dot_T_resources_doT_Dot_T_organic_fields[] = {
    { FLD(SUBSTRUCT, leather), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, fiber), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, silk), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, wool), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, wood), &material_vec_ref::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_resources::T_organic::_identity(sizeof(historical_entity::T_resources::T_organic), &allocator_fn<historical_entity::T_resources::T_organic>, &historical_entity::T_resources::_identity, "T_organic",NULL,historical_entity_doT_Dot_T_resources_doT_Dot_T_organic_fields);
  #define CUR_STRUCT historical_entity::T_resources::T_refuse
  static const struct_field_info historical_entity_doT_Dot_T_resources_doT_Dot_T_refuse_fields[] = {
    { FLD(SUBSTRUCT, bone), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, shell), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, pearl), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, ivory), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, horn), &material_vec_ref::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_resources::T_refuse::_identity(sizeof(historical_entity::T_resources::T_refuse), &allocator_fn<historical_entity::T_resources::T_refuse>, &historical_entity::T_resources::_identity, "T_refuse",NULL,historical_entity_doT_Dot_T_resources_doT_Dot_T_refuse_fields);
  #define CUR_STRUCT historical_entity::T_resources::T_misc_mat
  static const struct_field_info historical_entity_doT_Dot_T_resources_doT_Dot_T_misc_mat_fields[] = {
    { FLD(SUBSTRUCT, others), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, glass), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, sand), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, clay), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, crafts), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, glass_unused), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, barrels), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, flasks), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, quivers), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, backpacks), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, cages), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, wood2), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, rock_metal), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, booze), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, cheese), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, powders), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, extracts), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, meat), &material_vec_ref::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_resources::T_misc_mat::_identity(sizeof(historical_entity::T_resources::T_misc_mat), &allocator_fn<historical_entity::T_resources::T_misc_mat>, &historical_entity::T_resources::_identity, "T_misc_mat",NULL,historical_entity_doT_Dot_T_resources_doT_Dot_T_misc_mat_fields);
  #define CUR_STRUCT historical_entity::T_resources::T_wood_products
  static const struct_field_info historical_entity_doT_Dot_T_resources_doT_Dot_T_wood_products_fields[] = {
    { FLD(CONTAINER, item_type), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, item_subtype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, material), &material_vec_ref::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_resources::T_wood_products::_identity(sizeof(historical_entity::T_resources::T_wood_products), &allocator_fn<historical_entity::T_resources::T_wood_products>, &historical_entity::T_resources::_identity, "T_wood_products",NULL,historical_entity_doT_Dot_T_resources_doT_Dot_T_wood_products_fields);
  #define CUR_STRUCT historical_entity::T_resources::T_animals
  static const struct_field_info historical_entity_doT_Dot_T_resources_doT_Dot_T_animals_fields[] = {
    { FLD(CONTAINER, pet_races), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, wagon_races), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pack_animal_races), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, wagon_puller_races), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mount_races), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, minion_races), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, exotic_pet_races), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pet_castes), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, wagon_castes), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pack_animal_castes), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, wagon_puller_castes), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mount_castes), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, minion_castes), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, exotic_pet_castes), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_resources::T_animals::_identity(sizeof(historical_entity::T_resources::T_animals), &allocator_fn<historical_entity::T_resources::T_animals>, &historical_entity::T_resources::_identity, "T_animals",NULL,historical_entity_doT_Dot_T_resources_doT_Dot_T_animals_fields);
  #define CUR_STRUCT historical_entity::T_resources::T_unk13
  static const struct_field_info historical_entity_doT_Dot_T_resources_doT_Dot_T_unk13_fields[] = {
    { FLD(PRIMITIVE, unk1), TID(int16_t) },
    { FLD(PRIMITIVE, unk2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_resources::T_unk13::_identity(sizeof(historical_entity::T_resources::T_unk13), &allocator_fn<historical_entity::T_resources::T_unk13>, &historical_entity::T_resources::_identity, "T_unk13",NULL,historical_entity_doT_Dot_T_resources_doT_Dot_T_unk13_fields);
  #define CUR_STRUCT historical_entity::T_resources
  static const struct_field_info historical_entity_doT_Dot_T_resources_fields[] = {
    { FLD(CONTAINER, digger_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, weapon_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, training_weapon_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, armor_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, ammo_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, helm_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, gloves_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shoes_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pants_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shield_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, trapcomp_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, toy_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, instrument_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, siegeammo_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, tool_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, metal), &historical_entity::T_resources::T_metal::_identity },
    { FLD(SUBSTRUCT, organic), &historical_entity::T_resources::T_organic::_identity },
    { FLD(CONTAINER, metals), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, stones), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, gems), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, refuse), &historical_entity::T_resources::T_refuse::_identity },
    { FLD(SUBSTRUCT, misc_mat), &historical_entity::T_resources::T_misc_mat::_identity },
    { FLD(CONTAINER, fish_races), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, fish_castes), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, egg_races), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, egg_castes), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, plants), &material_vec_ref::_identity },
    { FLD(CONTAINER, tree_fruit_plants), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, tree_fruit_growths), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shrub_fruit_plants), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shrub_fruit_growths), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, seeds), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, wood_products), &historical_entity::T_resources::T_wood_products::_identity },
    { FLD(SUBSTRUCT, animals), &historical_entity::T_resources::T_animals::_identity },
    { FLD(STL_VECTOR_PTR, meat_fish_recipes), identity_traits<df::entity_recipe >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, other_recipes), identity_traits<df::entity_recipe >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, unk13), &historical_entity::T_resources::T_unk13::_identity, 3, NULL },
    { FLD(STL_VECTOR_PTR, unk14), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk15a), TID(int16_t) },
    { FLD(PRIMITIVE, unk15b), TID(int16_t) },
    { FLD(STATIC_ARRAY, ethic), identity_traits<df::ethic_response >::get(), 22, TID(ethic_type) },
    { FLD(STATIC_ARRAY, values), identity_traits<int32_t >::get(), 32, TID(value_type) },
    { FLD(CONTAINER, art_image_types), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, art_image_ids), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, art_image_subids), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, discovered_creature_foods), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, discovered_creatures), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, discovered_plant_foods), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, discovered_plants), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, unk23), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk24), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_resources::_identity(sizeof(historical_entity::T_resources), &allocator_fn<historical_entity::T_resources>, &historical_entity::_identity, "T_resources",NULL,historical_entity_doT_Dot_T_resources_fields);
  #define CUR_STRUCT historical_entity::T_unknown1b::T_unk32e
  static const struct_field_info historical_entity_doT_Dot_T_unknown1b_doT_Dot_T_unk32e_fields[] = {
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_6), TID(int16_t) },
    { FLD(PRIMITIVE, anon_7), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_unknown1b::T_unk32e::_identity(sizeof(historical_entity::T_unknown1b::T_unk32e), &allocator_fn<historical_entity::T_unknown1b::T_unk32e>, &historical_entity::T_unknown1b::_identity, "T_unk32e",NULL,historical_entity_doT_Dot_T_unknown1b_doT_Dot_T_unk32e_fields);
  #define CUR_STRUCT historical_entity::T_unknown1b::T_diplomacy
  static const struct_field_info historical_entity_doT_Dot_T_unknown1b_doT_Dot_T_diplomacy_fields[] = {
    { FLD(PRIMITIVE, group_id), TID(int32_t) },
    { FLD(PRIMITIVE, relation), TID(int16_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_unknown1b::T_diplomacy::_identity(sizeof(historical_entity::T_unknown1b::T_diplomacy), &allocator_fn<historical_entity::T_unknown1b::T_diplomacy>, &historical_entity::T_unknown1b::_identity, "T_diplomacy",NULL,historical_entity_doT_Dot_T_unknown1b_doT_Dot_T_diplomacy_fields);
  #define CUR_STRUCT historical_entity::T_unknown1b
  static const struct_field_info historical_entity_doT_Dot_T_unknown1b_fields[] = {
    { FLD(CONTAINER, unk32b), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, worship), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk32d), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk32e), &historical_entity::T_unknown1b::T_unk32e::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, diplomacy), &historical_entity::T_unknown1b::T_diplomacy::_identity, 0, NULL },
    { FLD(PRIMITIVE, unk33), TID(int16_t) },
    { FLD(CONTAINER, unk34a), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk34b), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk34c), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk34d), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk34e), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_unknown1b::_identity(sizeof(historical_entity::T_unknown1b), &allocator_fn<historical_entity::T_unknown1b>, &historical_entity::_identity, "T_unknown1b",NULL,historical_entity_doT_Dot_T_unknown1b_fields);
  #define CUR_STRUCT historical_entity::T_positions
  static const struct_field_info historical_entity_doT_Dot_T_positions_fields[] = {
    { FLD(STL_VECTOR_PTR, own), identity_traits<df::entity_position >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, site), identity_traits<df::entity_position >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, conquered_site), identity_traits<df::entity_position >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_position_id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, assignments), identity_traits<df::entity_position_assignment >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_assignment_id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_v40_1), identity_traits<df::entity_position_assignment >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_v40_2), identity_traits<df::entity_position_assignment >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_v40_3), identity_traits<df::entity_position_assignment >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_4), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_5), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_positions::_identity(sizeof(historical_entity::T_positions), &allocator_fn<historical_entity::T_positions>, &historical_entity::_identity, "T_positions",NULL,historical_entity_doT_Dot_T_positions_fields);
  #define CUR_STRUCT historical_entity::T_tissue_styles
  static const struct_field_info historical_entity_doT_Dot_T_tissue_styles_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::entity_tissue_style >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_style_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_tissue_styles::_identity(sizeof(historical_entity::T_tissue_styles), &allocator_fn<historical_entity::T_tissue_styles>, &historical_entity::_identity, "T_tissue_styles",NULL,historical_entity_doT_Dot_T_tissue_styles_fields);
  #define CUR_STRUCT historical_entity::T_unknown1d
  static const struct_field_info historical_entity_doT_Dot_T_unknown1d_fields[] = {
    { FLD(PRIMITIVE, unk42), TID(int32_t) },
    { FLD(CONTAINER, unk43), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk44), TID(int32_t) },
    { FLD(PRIMITIVE, unk44a), TID(int32_t) },
    { FLD(STATIC_ARRAY, unk44b), identity_traits<int32_t >::get(), 15, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_unknown1d::_identity(sizeof(historical_entity::T_unknown1d), &allocator_fn<historical_entity::T_unknown1d>, &historical_entity::_identity, "T_unknown1d",NULL,historical_entity_doT_Dot_T_unknown1d_fields);
  #define CUR_STRUCT historical_entity::T_training_knowledge
  static const struct_field_info historical_entity_doT_Dot_T_training_knowledge_fields[] = {
    { FLD(CONTAINER, level), identity_traits<std::vector<df::training_knowledge_level > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_10), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_training_knowledge::_identity(sizeof(historical_entity::T_training_knowledge), &allocator_fn<historical_entity::T_training_knowledge>, &historical_entity::_identity, "T_training_knowledge",NULL,historical_entity_doT_Dot_T_training_knowledge_fields);
  #define CUR_STRUCT historical_entity::T_unknown1e
  static const struct_field_info historical_entity_doT_Dot_T_unknown1e_fields[] = {
    { FLD(PRIMITIVE, unk47), TID(int16_t) },
    { FLD(PRIMITIVE, unk48), TID(int32_t) },
    { FLD(PRIMITIVE, unk49a), TID(int32_t) },
    { FLD(PRIMITIVE, unk49b), TID(int32_t) },
    { FLD(PRIMITIVE, unk49c), TID(int32_t) },
    { FLD(STATIC_ARRAY, unk49d), identity_traits<int32_t >::get(), 10, NULL },
    { FLD(PRIMITIVE, unk49e), TID(int32_t) },
    { FLD(PRIMITIVE, unk49f), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_unknown1e::_identity(sizeof(historical_entity::T_unknown1e), &allocator_fn<historical_entity::T_unknown1e>, &historical_entity::_identity, "T_unknown1e",NULL,historical_entity_doT_Dot_T_unknown1e_fields);
  #define CUR_STRUCT historical_entity::T_derived_resources
  static const struct_field_info historical_entity_doT_Dot_T_derived_resources_fields[] = {
    { FLD(SUBSTRUCT, mill_cookable), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, mill_dye), &material_vec_ref::_identity },
    { FLD(CONTAINER, armor_leather), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, armor_chain), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, armor_plate), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, armor_under), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, armor_over), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, armor_cover), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pants_leather), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pants_chain), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pants_plate), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pants_under), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pants_over), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pants_cover), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, helm_leather), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, helm_chain), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, helm_plate), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, helm_under), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, helm_over), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, helm_cover), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shoes_leather), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shoes_chain), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shoes_plate), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shoes_under), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shoes_over), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shoes_cover), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, gloves_leather), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, gloves_chain), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, gloves_plate), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, gloves_under), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, gloves_over), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, gloves_cover), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_derived_resources::_identity(sizeof(historical_entity::T_derived_resources), &allocator_fn<historical_entity::T_derived_resources>, &historical_entity::_identity, "T_derived_resources",NULL,historical_entity_doT_Dot_T_derived_resources_fields);
  #define CUR_STRUCT historical_entity::T_claims
  static const struct_field_info historical_entity_doT_Dot_T_claims_fields[] = {
    { FLD(SUBSTRUCT, areas), &coord2d_path::_identity },
    { FLD(SUBSTRUCT, unk1), &coord2d_path::_identity },
    { FLD(SUBSTRUCT, unk2), &coord2d_path::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_claims::_identity(sizeof(historical_entity::T_claims), &allocator_fn<historical_entity::T_claims>, &historical_entity::_identity, "T_claims",NULL,historical_entity_doT_Dot_T_claims_fields);
  #define CUR_STRUCT historical_entity::T_unknown2
  static const struct_field_info historical_entity_doT_Dot_T_unknown2_fields[] = {
    { FLD(PRIMITIVE, metal_proficiency), TID(int32_t) },
    { FLD(CONTAINER, unk10), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(POINTER, resource_allotment), identity_traits<df::resource_allotment_data >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk12a), TID(int16_t) },
    { FLD(PRIMITIVE, unk12b), TID(int16_t) },
    { FLD(PRIMITIVE, unk13), TID(bool) },
    { FLD(PRIMITIVE, unk14), TID(int32_t) },
    { FLD(PRIMITIVE, unk15), TID(int32_t) },
    { FLD(PRIMITIVE, unk16), TID(int32_t) },
    { FLD(PRIMITIVE, unk17), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, unk18), NULL, 0, NULL },
    { FLD(STL_VECTOR_PTR, unk19), NULL, 0, NULL },
    { FLD(PRIMITIVE, unk20), TID(int16_t) },
    { FLD(PRIMITIVE, unk21), TID(int32_t) },
    { FLD(PRIMITIVE, unk22), TID(int32_t) },
    { FLD(PRIMITIVE, unk23), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk24), NULL, 0, NULL },
    { FLD(STL_VECTOR_PTR, unk25), NULL, 0, NULL },
    { FLD(STATIC_ARRAY, unk26), identity_traits<int32_t >::get(), 177, NULL },
    { FLD(STL_VECTOR_PTR, unk28), NULL, 0, NULL },
    { FLD(STL_VECTOR_PTR, unk29), NULL, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::T_unknown2::_identity(sizeof(historical_entity::T_unknown2), &allocator_fn<historical_entity::T_unknown2>, &historical_entity::_identity, "T_unknown2",NULL,historical_entity_doT_Dot_T_unknown2_fields);
  #define CUR_STRUCT historical_entity
  static const struct_field_info historical_entity_fields[] = {
    { FLD(PRIMITIVE, type), identity_traits<enum_field<df::historical_entity_type,int16_t> >::get() },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(POINTER, entity_raw), identity_traits<df::entity_raw >::get(), 0, NULL },
    { FLD(PRIMITIVE, save_file_id), TID(int32_t) },
    { FLD(PRIMITIVE, next_member_idx), TID(int16_t) },
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(SUBSTRUCT, flags), TID(historical_entity::T_flags) },
    { FLD(STL_VECTOR_PTR, entity_links), identity_traits<df::entity_entity_link >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, site_links), identity_traits<df::entity_site_link >::get(), 0, NULL },
    { FLD(CONTAINER, histfig_ids), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, populations), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, nemesis_ids), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, resources), &historical_entity::T_resources::_identity },
    { FLD(STL_VECTOR_PTR, uniforms), identity_traits<df::entity_uniform >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_uniform_id), TID(int32_t) },
    { FLD(SUBSTRUCT, unknown1b), &historical_entity::T_unknown1b::_identity },
    { FLD(SUBSTRUCT, positions), &historical_entity::T_positions::_identity },
    { FLD(SUBSTRUCT, tissue_styles), &historical_entity::T_tissue_styles::_identity },
    { FLD(CONTAINER, squads), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, unknown1d), &historical_entity::T_unknown1d::_identity },
    { FLD(POINTER, training_knowledge), &historical_entity::T_training_knowledge::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, events), identity_traits<df::entity_event >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_v40_1a), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1b), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1d), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1e), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, meeting_events), identity_traits<df::meeting_event >::get(), 0, NULL },
    { FLD(POINTER, activity_stats), identity_traits<df::entity_activity_statistics >::get(), 0, NULL },
    { FLD(SUBSTRUCT, unknown1e), &historical_entity::T_unknown1e::_identity },
    { FLD(STL_VECTOR_PTR, armies), identity_traits<df::army >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, army_controllers), identity_traits<df::army_controller >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, hist_figures), identity_traits<df::historical_figure >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, nemesis), identity_traits<df::nemesis_record >::get(), 0, NULL },
    { FLD(SUBSTRUCT, derived_resources), &historical_entity::T_derived_resources::_identity },
    { FLD(STATIC_ARRAY, assignments_by_type), identity_traits<std::vector<df::entity_position_assignment* > >::get(), 25, TID(entity_position_responsibility) },
    { FLD(SUBSTRUCT, claims), &historical_entity::T_claims::_identity },
    { FLD(CONTAINER, children), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, unknown2), &historical_entity::T_unknown2::_identity },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_entity::_identity(sizeof(historical_entity), &allocator_fn<historical_entity>, NULL, "historical_entity",NULL,historical_entity_fields);
  #define CUR_STRUCT historical_figure::T_worldgen::T_unk_c
  static const struct_field_info historical_figure_doT_Dot_T_worldgen_doT_Dot_T_unk_c_fields[] = {
    { FLD(CONTAINER, unk_0), identity_traits<DfArray<uint8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_8), identity_traits<DfArray<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure::T_worldgen::T_unk_c::_identity(sizeof(historical_figure::T_worldgen::T_unk_c), &allocator_fn<historical_figure::T_worldgen::T_unk_c>, &historical_figure::T_worldgen::_identity, "T_unk_c",NULL,historical_figure_doT_Dot_T_worldgen_doT_Dot_T_unk_c_fields);
  #define CUR_STRUCT historical_figure::T_worldgen
  static const struct_field_info historical_figure_doT_Dot_T_worldgen_fields[] = {
    { FLD(POINTER, unk_0), identity_traits<df::world_site >::get(), 0, NULL },
    { FLD(POINTER, unk_4), identity_traits<df::language_name >::get(), 0, NULL },
    { FLD(POINTER, unk_8), identity_traits<df::world_underground_region >::get(), 0, NULL },
    { FLD(POINTER, unk_c), &historical_figure::T_worldgen::T_unk_c::_identity, 0, NULL },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure::T_worldgen::_identity(sizeof(historical_figure::T_worldgen), &allocator_fn<historical_figure::T_worldgen>, &historical_figure::_identity, "T_worldgen",NULL,historical_figure_doT_Dot_T_worldgen_fields);
  #define CUR_STRUCT historical_figure
  static const struct_field_info historical_figure_fields[] = {
    { FLD(PRIMITIVE, profession), TID(profession) },
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(PRIMITIVE, sex), TID(int8_t) },
    { FLD(SUBSTRUCT, orientation_flags), TID(orientation_flags) },
    { FLD(PRIMITIVE, appeared_year), TID(int32_t) },
    { FLD(PRIMITIVE, born_year), TID(int32_t) },
    { FLD(PRIMITIVE, born_seconds), TID(int32_t) },
    { FLD(PRIMITIVE, curse_year), TID(int32_t) },
    { FLD(PRIMITIVE, curse_seconds), TID(int32_t) },
    { FLD(PRIMITIVE, birth_year_bias), TID(int32_t) },
    { FLD(PRIMITIVE, birth_time_bias), TID(int32_t) },
    { FLD(PRIMITIVE, old_year), TID(int32_t) },
    { FLD(PRIMITIVE, old_seconds), TID(int32_t) },
    { FLD(PRIMITIVE, died_year), TID(int32_t) },
    { FLD(PRIMITIVE, died_seconds), TID(int32_t) },
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, civ_id), TID(int32_t) },
    { FLD(PRIMITIVE, population_id), TID(int32_t) },
    { FLD(PRIMITIVE, breed_id), TID(int32_t) },
    { FLD(PRIMITIVE, cultural_identity), TID(int32_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::histfig_flags> >::get(), 0, TID(histfig_flags) },
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, unit_id2), TID(int32_t) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, unk4), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, entity_links), identity_traits<df::histfig_entity_link >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, site_links), identity_traits<df::histfig_site_link >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, histfig_links), identity_traits<df::histfig_hf_link >::get(), 0, NULL },
    { FLD(POINTER, info), identity_traits<df::historical_figure_info >::get(), 0, NULL },
    { FLD(SUBSTRUCT, worldgen), &historical_figure::T_worldgen::_identity },
    { FLD(PRIMITIVE, unk_v4019_1), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure::_identity(sizeof(historical_figure), &allocator_fn<historical_figure>, NULL, "historical_figure",NULL,historical_figure_fields);
  #define CUR_STRUCT historical_figure_info::T_skills
  static const struct_field_info historical_figure_info_doT_Dot_T_skills_fields[] = {
    { FLD(CONTAINER, skills), identity_traits<std::vector<df::job_skill > >::get(), 0, NULL },
    { FLD(CONTAINER, points), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_20), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_30), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_60), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::T_skills::_identity(sizeof(historical_figure_info::T_skills), &allocator_fn<historical_figure_info::T_skills>, &historical_figure_info::_identity, "T_skills",NULL,historical_figure_info_doT_Dot_T_skills_fields);
  #define CUR_STRUCT historical_figure_info::T_masterpieces
  static const struct_field_info historical_figure_info_doT_Dot_T_masterpieces_fields[] = {
    { FLD(CONTAINER, events), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, events2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::T_masterpieces::_identity(sizeof(historical_figure_info::T_masterpieces), &allocator_fn<historical_figure_info::T_masterpieces>, &historical_figure_info::_identity, "T_masterpieces",NULL,historical_figure_info_doT_Dot_T_masterpieces_fields);
  #define CUR_STRUCT historical_figure_info::T_unk_14
  static const struct_field_info historical_figure_info_doT_Dot_T_unk_14_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int16_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region_id), TID(int32_t) },
    { FLD(PRIMITIVE, beast_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(SUBSTRUCT, region), &coord2d::_identity },
    { FLD(PRIMITIVE, unk_14), TID(int8_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::T_unk_14::_identity(sizeof(historical_figure_info::T_unk_14), &allocator_fn<historical_figure_info::T_unk_14>, &historical_figure_info::_identity, "T_unk_14",NULL,historical_figure_info_doT_Dot_T_unk_14_fields);
  #define CUR_STRUCT historical_figure_info::T_wounds
  static const struct_field_info historical_figure_info_doT_Dot_T_wounds_fields[] = {
    { FLD(CONTAINER, events), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, status), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::T_wounds::_identity(sizeof(historical_figure_info::T_wounds), &allocator_fn<historical_figure_info::T_wounds>, &historical_figure_info::_identity, "T_wounds",NULL,historical_figure_info_doT_Dot_T_wounds_fields);
  #define CUR_STRUCT historical_figure_info::T_secret::T_anon_3
  static const struct_field_info historical_figure_info_doT_Dot_T_secret_doT_Dot_T_anon_3_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::T_secret::T_anon_3::_identity(sizeof(historical_figure_info::T_secret::T_anon_3), &allocator_fn<historical_figure_info::T_secret::T_anon_3>, &historical_figure_info::T_secret::_identity, "T_anon_3",NULL,historical_figure_info_doT_Dot_T_secret_doT_Dot_T_anon_3_fields);
  #define CUR_STRUCT historical_figure_info::T_secret::T_anon_9
  static const struct_field_info historical_figure_info_doT_Dot_T_secret_doT_Dot_T_anon_9_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::T_secret::T_anon_9::_identity(sizeof(historical_figure_info::T_secret::T_anon_9), &allocator_fn<historical_figure_info::T_secret::T_anon_9>, &historical_figure_info::T_secret::_identity, "T_anon_9",NULL,historical_figure_info_doT_Dot_T_secret_doT_Dot_T_anon_9_fields);
  #define CUR_STRUCT historical_figure_info::T_secret
  static const struct_field_info historical_figure_info_doT_Dot_T_secret_fields[] = {
    { FLD(STL_VECTOR_PTR, interactions), identity_traits<df::interaction >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_3), &historical_figure_info::T_secret::T_anon_3::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_4), identity_traits<df::entity_event >::get(), 0, NULL },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_6), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_8), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_9), &historical_figure_info::T_secret::T_anon_9::_identity, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::T_secret::_identity(sizeof(historical_figure_info::T_secret), &allocator_fn<historical_figure_info::T_secret>, &historical_figure_info::_identity, "T_secret",NULL,historical_figure_info_doT_Dot_T_secret_fields);
  #define CUR_STRUCT historical_figure_info::T_curse
  static const struct_field_info historical_figure_info_doT_Dot_T_curse_fields[] = {
    { FLD(STL_VECTOR_PTR, active_interactions), identity_traits<df::interaction >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, active_effects), identity_traits<df::interaction_effect >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, can_do), identity_traits<df::interaction >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_30), TID(int32_t) },
    { FLD(PRIMITIVE, unk_34), TID(int32_t) },
    { FLD(PRIMITIVE, unk_38), TID(int32_t) },
    { FLD(PRIMITIVE, unk_3c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_40), TID(int8_t) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_adjective), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, race), TID(int32_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(CONTAINER, unk_a0), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_b0), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_c0), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_d0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_d4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_d8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_dc), TID(int32_t) },
    { FLD(PRIMITIVE, unk_e0), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_fc), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::T_curse::_identity(sizeof(historical_figure_info::T_curse), &allocator_fn<historical_figure_info::T_curse>, &historical_figure_info::_identity, "T_curse",NULL,historical_figure_info_doT_Dot_T_curse_fields);
  #define CUR_STRUCT historical_figure_info::T_reputation::T_wanted
  static const struct_field_info historical_figure_info_doT_Dot_T_reputation_doT_Dot_T_wanted_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, discovered_year), TID(int32_t) },
    { FLD(PRIMITIVE, discovered_time), TID(int32_t) },
    { FLD(PRIMITIVE, unsolved_murders), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::T_reputation::T_wanted::_identity(sizeof(historical_figure_info::T_reputation::T_wanted), &allocator_fn<historical_figure_info::T_reputation::T_wanted>, &historical_figure_info::T_reputation::_identity, "T_wanted",NULL,historical_figure_info_doT_Dot_T_reputation_doT_Dot_T_wanted_fields);
  #define CUR_STRUCT historical_figure_info::T_reputation::T_anon_1
  static const struct_field_info historical_figure_info_doT_Dot_T_reputation_doT_Dot_T_anon_1_fields[] = {
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, discovered_year), TID(int32_t) },
    { FLD(PRIMITIVE, discovered_time), TID(int32_t) },
    { FLD(PRIMITIVE, unsolved_murders), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::T_reputation::T_anon_1::_identity(sizeof(historical_figure_info::T_reputation::T_anon_1), &allocator_fn<historical_figure_info::T_reputation::T_anon_1>, &historical_figure_info::T_reputation::_identity, "T_anon_1",NULL,historical_figure_info_doT_Dot_T_reputation_doT_Dot_T_anon_1_fields);
  #define CUR_STRUCT historical_figure_info::T_reputation
  static const struct_field_info historical_figure_info_doT_Dot_T_reputation_fields[] = {
    { FLD(STL_VECTOR_PTR, wanted), &historical_figure_info::T_reputation::T_wanted::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_1), &historical_figure_info::T_reputation::T_anon_1::_identity, 0, NULL },
    { FLD(PRIMITIVE, cur_identity), TID(int32_t) },
    { FLD(CONTAINER, all_identities), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::T_reputation::_identity(sizeof(historical_figure_info::T_reputation), &allocator_fn<historical_figure_info::T_reputation>, &historical_figure_info::_identity, "T_reputation",NULL,historical_figure_info_doT_Dot_T_reputation_fields);
  #define CUR_STRUCT historical_figure_info::T_relationships::T_anon_1
  static const struct_field_info historical_figure_info_doT_Dot_T_relationships_doT_Dot_T_anon_1_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::T_relationships::T_anon_1::_identity(sizeof(historical_figure_info::T_relationships::T_anon_1), &allocator_fn<historical_figure_info::T_relationships::T_anon_1>, &historical_figure_info::T_relationships::_identity, "T_anon_1",NULL,historical_figure_info_doT_Dot_T_relationships_doT_Dot_T_anon_1_fields);
  #define CUR_STRUCT historical_figure_info::T_relationships
  static const struct_field_info historical_figure_info_doT_Dot_T_relationships_fields[] = {
    { FLD(STL_VECTOR_PTR, anon_1), &historical_figure_info::T_relationships::T_anon_1::_identity, 0, NULL },
    { FLD(CONTAINER, identities), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::T_relationships::_identity(sizeof(historical_figure_info::T_relationships), &allocator_fn<historical_figure_info::T_relationships>, &historical_figure_info::_identity, "T_relationships",NULL,historical_figure_info_doT_Dot_T_relationships_fields);
  #define CUR_STRUCT historical_figure_info
  static const struct_field_info historical_figure_info_fields[] = {
    { FLD(POINTER, spheres), identity_traits<std::vector<enum_field<df::sphere_type,int16_t> > >::get(), 0, NULL },
    { FLD(POINTER, skills), &historical_figure_info::T_skills::_identity, 0, NULL },
    { FLD(POINTER, pets), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(POINTER, personality), identity_traits<df::unit_personality >::get(), 0, NULL },
    { FLD(POINTER, masterpieces), &historical_figure_info::T_masterpieces::_identity, 0, NULL },
    { FLD(POINTER, unk_14), &historical_figure_info::T_unk_14::_identity, 0, NULL },
    { FLD(POINTER, kills), identity_traits<df::historical_kills >::get(), 0, NULL },
    { FLD(POINTER, wounds), &historical_figure_info::T_wounds::_identity, 0, NULL },
    { FLD(POINTER, secret), &historical_figure_info::T_secret::_identity, 0, NULL },
    { FLD(POINTER, curse), &historical_figure_info::T_curse::_identity, 0, NULL },
    { FLD(POINTER, books), identity_traits<std::vector<df::artifact_record* > >::get(), 0, NULL },
    { FLD(POINTER, reputation), &historical_figure_info::T_reputation::_identity, 0, NULL },
    { FLD(POINTER, relationships), &historical_figure_info::T_relationships::_identity, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_figure_info::_identity(sizeof(historical_figure_info), &allocator_fn<historical_figure_info>, NULL, "historical_figure_info",NULL,historical_figure_info_fields);
  #define CUR_STRUCT historical_kills
  static const struct_field_info historical_kills_fields[] = {
    { FLD(CONTAINER, events), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, killed_race), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, killed_caste), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_30), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_40), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, killed_site), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, killed_undead), identity_traits<std::vector<df::historical_kills::T_killed_undead > >::get(), 0, NULL },
    { FLD(CONTAINER, killed_count), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity historical_kills::_identity(sizeof(historical_kills), &allocator_fn<historical_kills>, NULL, "historical_kills",NULL,historical_kills_fields);
  #define CUR_STRUCT history_era::T_title
  static const struct_field_info history_era_doT_Dot_T_title_fields[] = {
    { FLD(PRIMITIVE, type), TID(era_type) },
    { FLD(PRIMITIVE, histfig_1), TID(int32_t) },
    { FLD(PRIMITIVE, histfig_2), TID(int32_t) },
    { FLD(PRIMITIVE, ordinal), TID(int32_t) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, percent), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity history_era::T_title::_identity(sizeof(history_era::T_title), &allocator_fn<history_era::T_title>, &history_era::_identity, "T_title",NULL,history_era_doT_Dot_T_title_fields);
  #define CUR_STRUCT history_era::T_details
  static const struct_field_info history_era_doT_Dot_T_details_fields[] = {
    { FLD(PRIMITIVE, living_powers), TID(int32_t) },
    { FLD(PRIMITIVE, living_megabeasts), TID(int32_t) },
    { FLD(PRIMITIVE, living_semimegabeasts), TID(int32_t) },
    { FLD(PRIMITIVE, power_hf1), TID(int32_t) },
    { FLD(PRIMITIVE, power_hf2), TID(int32_t) },
    { FLD(PRIMITIVE, power_hf3), TID(int32_t) },
    { FLD(CONTAINER, civilized_races), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, civilized_total), TID(int32_t) },
    { FLD(PRIMITIVE, civilized_mundane), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity history_era::T_details::_identity(sizeof(history_era::T_details), &allocator_fn<history_era::T_details>, &history_era::_identity, "T_details",NULL,history_era_doT_Dot_T_details_fields);
  #define CUR_STRUCT history_era
  static const struct_field_info history_era_fields[] = {
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(SUBSTRUCT, title), &history_era::T_title::_identity },
    { FLD(SUBSTRUCT, details), &history_era::T_details::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity history_era::_identity(sizeof(history_era), &allocator_fn<history_era>, NULL, "history_era",NULL,history_era_fields);
  #define CUR_STRUCT history_event
  static const struct_field_info history_event_fields[] = {
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, seconds), TID(int32_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, getWarStatus) },
    { METHOD(OBJ_METHOD, getAngerModifier) },
    { METHOD(OBJ_METHOD, getHappinessModifier) },
    { METHOD(OBJ_METHOD, madeFirstContact) },
    { METHOD(OBJ_METHOD, getKilledHistfigID) },
    { METHOD(OBJ_METHOD, wasHistfigKilled) },
    { METHOD(OBJ_METHOD, wasHistfigRevived) },
    { METHOD(OBJ_METHOD, getRelatedHistfigIDs) },
    { METHOD(OBJ_METHOD, getRelatedSiteIDs) },
    { METHOD(OBJ_METHOD, getRelatedSiteStructureIDs) },
    { METHOD(OBJ_METHOD, getRelatedArtifactIDs) },
    { METHOD(OBJ_METHOD, getRelatedRegionIDs) },
    { METHOD(OBJ_METHOD, getRelatedLayerIDs) },
    { METHOD(OBJ_METHOD, getRelatedEntityIDs) },
    { METHOD(OBJ_METHOD, isRelatedToHistfigID) },
    { METHOD(OBJ_METHOD, isRelatedToSiteID) },
    { METHOD(OBJ_METHOD, isRelatedToSiteStructure) },
    { METHOD(OBJ_METHOD, isRelatedToArtifactID) },
    { METHOD(OBJ_METHOD, isRelatedToRegionID) },
    { METHOD(OBJ_METHOD, isRelatedToLayerID) },
    { METHOD(OBJ_METHOD, isRelatedToEntityID) },
    { METHOD(OBJ_METHOD, getSentence) },
    { METHOD(OBJ_METHOD, getPhrase) },
    { METHOD(OBJ_METHOD, populateArtImage) },
    { METHOD(OBJ_METHOD, generate_xml) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event::_identity(sizeof(history_event), &allocator_fn<history_event>, "history_event","history_eventst",NULL,history_event_fields);
  #define CUR_STRUCT history_event_add_hf_entity_linkst
  static const struct_field_info history_event_add_hf_entity_linkst_fields[] = {
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, link_type), TID(histfig_entity_link_type) },
    { FLD(PRIMITIVE, position_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_add_hf_entity_linkst::_identity(sizeof(history_event_add_hf_entity_linkst), &allocator_fn<history_event_add_hf_entity_linkst>, "history_event_add_hf_entity_linkst",NULL,&history_event::_identity,history_event_add_hf_entity_linkst_fields);
  #define CUR_STRUCT history_event_add_hf_hf_linkst
  static const struct_field_info history_event_add_hf_hf_linkst_fields[] = {
    { FLD(PRIMITIVE, hf), TID(int32_t) },
    { FLD(PRIMITIVE, hf_target), TID(int32_t) },
    { FLD(PRIMITIVE, type), TID(histfig_hf_link_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_add_hf_hf_linkst::_identity(sizeof(history_event_add_hf_hf_linkst), &allocator_fn<history_event_add_hf_hf_linkst>, "history_event_add_hf_hf_linkst",NULL,&history_event::_identity,history_event_add_hf_hf_linkst_fields);
  #define CUR_STRUCT history_event_add_hf_site_linkst
  static const struct_field_info history_event_add_hf_site_linkst_fields[] = {
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, structure), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, type), TID(histfig_site_link_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_add_hf_site_linkst::_identity(sizeof(history_event_add_hf_site_linkst), &allocator_fn<history_event_add_hf_site_linkst>, "history_event_add_hf_site_linkst",NULL,&history_event::_identity,history_event_add_hf_site_linkst_fields);
  #define CUR_STRUCT history_event_agreement_concludedst
  static const struct_field_info history_event_agreement_concludedst_fields[] = {
    { FLD(PRIMITIVE, agreement_id), TID(int32_t) },
    { FLD(PRIMITIVE, subject_id), TID(int32_t) },
    { FLD(PRIMITIVE, reason), TID(agreement_conclusion_reason) },
    { FLD(PRIMITIVE, concluder_hf), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_agreement_concludedst::_identity(sizeof(history_event_agreement_concludedst), &allocator_fn<history_event_agreement_concludedst>, "history_event_agreement_concludedst",NULL,&history_event::_identity,history_event_agreement_concludedst_fields);
  #define CUR_STRUCT history_event_agreement_formedst
  static const struct_field_info history_event_agreement_formedst_fields[] = {
    { FLD(PRIMITIVE, agreement_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_agreement_formedst::_identity(sizeof(history_event_agreement_formedst), &allocator_fn<history_event_agreement_formedst>, "history_event_agreement_formedst",NULL,&history_event::_identity,history_event_agreement_formedst_fields);
  #define CUR_STRUCT history_event_agreements_voidedst
  static const struct_field_info history_event_agreements_voidedst_fields[] = {
    { FLD(PRIMITIVE, source), TID(int32_t) },
    { FLD(PRIMITIVE, destination), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_agreements_voidedst::_identity(sizeof(history_event_agreements_voidedst), &allocator_fn<history_event_agreements_voidedst>, "history_event_agreements_voidedst",NULL,&history_event::_identity,history_event_agreements_voidedst_fields);
  #define CUR_STRUCT history_event_artifact_createdst
  static const struct_field_info history_event_artifact_createdst_fields[] = {
    { FLD(PRIMITIVE, artifact_id), TID(int32_t) },
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, hfid), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, flags2), TID(uint32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_artifact_createdst::_identity(sizeof(history_event_artifact_createdst), &allocator_fn<history_event_artifact_createdst>, "history_event_artifact_createdst",NULL,&history_event::_identity,history_event_artifact_createdst_fields);
  #define CUR_STRUCT history_event_artifact_droppedst
  static const struct_field_info history_event_artifact_droppedst_fields[] = {
    { FLD(PRIMITIVE, artifact), TID(int32_t) },
    { FLD(PRIMITIVE, unit), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(CONTAINER, flags2), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_artifact_droppedst::_identity(sizeof(history_event_artifact_droppedst), &allocator_fn<history_event_artifact_droppedst>, "history_event_artifact_droppedst",NULL,&history_event::_identity,history_event_artifact_droppedst_fields);
  #define CUR_STRUCT history_event_artifact_foundst
  static const struct_field_info history_event_artifact_foundst_fields[] = {
    { FLD(PRIMITIVE, artifact), TID(int32_t) },
    { FLD(PRIMITIVE, unit), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_artifact_foundst::_identity(sizeof(history_event_artifact_foundst), &allocator_fn<history_event_artifact_foundst>, "history_event_artifact_foundst",NULL,&history_event::_identity,history_event_artifact_foundst_fields);
  #define CUR_STRUCT history_event_artifact_hiddenst
  static const struct_field_info history_event_artifact_hiddenst_fields[] = {
    { FLD(PRIMITIVE, artifact), TID(int32_t) },
    { FLD(PRIMITIVE, unit), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_artifact_hiddenst::_identity(sizeof(history_event_artifact_hiddenst), &allocator_fn<history_event_artifact_hiddenst>, "history_event_artifact_hiddenst",NULL,&history_event::_identity,history_event_artifact_hiddenst_fields);
  #define CUR_STRUCT history_event_artifact_lostst
  static const struct_field_info history_event_artifact_lostst_fields[] = {
    { FLD(PRIMITIVE, artifact), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_artifact_lostst::_identity(sizeof(history_event_artifact_lostst), &allocator_fn<history_event_artifact_lostst>, "history_event_artifact_lostst",NULL,&history_event::_identity,history_event_artifact_lostst_fields);
  #define CUR_STRUCT history_event_artifact_possessedst
  static const struct_field_info history_event_artifact_possessedst_fields[] = {
    { FLD(PRIMITIVE, artifact), TID(int32_t) },
    { FLD(PRIMITIVE, unit), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_artifact_possessedst::_identity(sizeof(history_event_artifact_possessedst), &allocator_fn<history_event_artifact_possessedst>, "history_event_artifact_possessedst",NULL,&history_event::_identity,history_event_artifact_possessedst_fields);
  #define CUR_STRUCT history_event_artifact_recoveredst
  static const struct_field_info history_event_artifact_recoveredst_fields[] = {
    { FLD(PRIMITIVE, artifact), TID(int32_t) },
    { FLD(PRIMITIVE, unit), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_artifact_recoveredst::_identity(sizeof(history_event_artifact_recoveredst), &allocator_fn<history_event_artifact_recoveredst>, "history_event_artifact_recoveredst",NULL,&history_event::_identity,history_event_artifact_recoveredst_fields);
  #define CUR_STRUCT history_event_artifact_storedst
  static const struct_field_info history_event_artifact_storedst_fields[] = {
    { FLD(PRIMITIVE, artifact), TID(int32_t) },
    { FLD(PRIMITIVE, unit), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_artifact_storedst::_identity(sizeof(history_event_artifact_storedst), &allocator_fn<history_event_artifact_storedst>, "history_event_artifact_storedst",NULL,&history_event::_identity,history_event_artifact_storedst_fields);
  #define CUR_STRUCT history_event_assume_identityst
  static const struct_field_info history_event_assume_identityst_fields[] = {
    { FLD(PRIMITIVE, trickster), TID(int32_t) },
    { FLD(PRIMITIVE, identity), TID(int32_t) },
    { FLD(PRIMITIVE, target), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_assume_identityst::_identity(sizeof(history_event_assume_identityst), &allocator_fn<history_event_assume_identityst>, "history_event_assume_identityst",NULL,&history_event::_identity,history_event_assume_identityst_fields);
  #define CUR_STRUCT history_event_body_abusedst::T_props::T_item
  static const struct_field_info history_event_body_abusedst_doT_Dot_T_props_doT_Dot_T_item_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int32_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<history_event_body_abusedst::T_props::T_item>::identity(sizeof(history_event_body_abusedst::T_props::T_item), &allocator_fn<history_event_body_abusedst::T_props::T_item>, TID(history_event_body_abusedst::T_props), "T_item", NULL, history_event_body_abusedst_doT_Dot_T_props_doT_Dot_T_item_fields);
  #define CUR_STRUCT history_event_body_abusedst::T_props
  static const struct_field_info history_event_body_abusedst_doT_Dot_T_props_fields[] = {
    { FLD(SUBSTRUCT, item), TID(history_event_body_abusedst::T_props::T_item) },
    { FLD(PRIMITIVE, structure), TID(int32_t) },
    { FLD(PRIMITIVE, pile_type), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<history_event_body_abusedst::T_props>::identity(sizeof(history_event_body_abusedst::T_props), &allocator_fn<history_event_body_abusedst::T_props>, &history_event_body_abusedst::_identity, "T_props", NULL, history_event_body_abusedst_doT_Dot_T_props_fields);
  #define CUR_STRUCT history_event_body_abusedst
  static const struct_field_info history_event_body_abusedst_fields[] = {
    { FLD(CONTAINER, bodies), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD(PRIMITIVE, abuse_type), TID(int16_t) },
    { FLD(SUBSTRUCT, props), TID(history_event_body_abusedst::T_props) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_body_abusedst::_identity(sizeof(history_event_body_abusedst), &allocator_fn<history_event_body_abusedst>, "history_event_body_abusedst",NULL,&history_event::_identity,history_event_body_abusedst_fields);
  #define CUR_STRUCT history_event_change_creature_typest
  static const struct_field_info history_event_change_creature_typest_fields[] = {
    { FLD(PRIMITIVE, changee), TID(int32_t) },
    { FLD(PRIMITIVE, changer), TID(int32_t) },
    { FLD(PRIMITIVE, old_race), TID(int32_t) },
    { FLD(PRIMITIVE, old_caste), TID(int32_t) },
    { FLD(PRIMITIVE, new_race), TID(int32_t) },
    { FLD(PRIMITIVE, new_caste), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_change_creature_typest::_identity(sizeof(history_event_change_creature_typest), &allocator_fn<history_event_change_creature_typest>, "history_event_change_creature_typest",NULL,&history_event::_identity,history_event_change_creature_typest_fields);
  #define CUR_STRUCT history_event_change_hf_body_statest
  static const struct_field_info history_event_change_hf_body_statest_fields[] = {
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, body_state), identity_traits<enum_field<df::histfig_body_state,int8_t> >::get() },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, structure), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_change_hf_body_statest::_identity(sizeof(history_event_change_hf_body_statest), &allocator_fn<history_event_change_hf_body_statest>, "history_event_change_hf_body_statest",NULL,&history_event::_identity,history_event_change_hf_body_statest_fields);
  #define CUR_STRUCT history_event_change_hf_jobst
  static const struct_field_info history_event_change_hf_jobst_fields[] = {
    { FLD(PRIMITIVE, hfid), TID(int32_t) },
    { FLD(PRIMITIVE, new_job), TID(profession) },
    { FLD(PRIMITIVE, old_job), TID(profession) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_change_hf_jobst::_identity(sizeof(history_event_change_hf_jobst), &allocator_fn<history_event_change_hf_jobst>, "history_event_change_hf_jobst",NULL,&history_event::_identity,history_event_change_hf_jobst_fields);
  #define CUR_STRUCT history_event_change_hf_statest
  static const struct_field_info history_event_change_hf_statest_fields[] = {
    { FLD(PRIMITIVE, hfid), TID(int32_t) },
    { FLD(PRIMITIVE, state), TID(int16_t) },
    { FLD(PRIMITIVE, substate), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_change_hf_statest::_identity(sizeof(history_event_change_hf_statest), &allocator_fn<history_event_change_hf_statest>, "history_event_change_hf_statest",NULL,&history_event::_identity,history_event_change_hf_statest_fields);
  #define CUR_STRUCT history_event_collection
  static const struct_field_info history_event_collection_fields[] = {
    { FLD(CONTAINER, events), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, collections), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, start_year), TID(int32_t) },
    { FLD(PRIMITIVE, end_year), TID(int32_t) },
    { FLD(PRIMITIVE, start_seconds), TID(int32_t) },
    { FLD(PRIMITIVE, end_seconds), TID(int32_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, generate_xml) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, categorize) },
    { METHOD(OBJ_METHOD, uncategorize) },
    { METHOD(OBJ_METHOD, getName) },
    { METHOD(OBJ_METHOD, getRegionCoords) },
    { METHOD(OBJ_METHOD, getParent) },
    { METHOD(OBJ_METHOD, isBetweenEntities) },
    { METHOD(OBJ_METHOD, updateEndTime) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_collection::_identity(sizeof(history_event_collection), &allocator_fn<history_event_collection>, "history_event_collection","history_event_collectionst",NULL,history_event_collection_fields);
  #define CUR_STRUCT history_event_collection_abductionst
  static const struct_field_info history_event_collection_abductionst_fields[] = {
    { FLD(PRIMITIVE, parent_collection), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD(PRIMITIVE, attacker_civ), TID(int32_t) },
    { FLD(PRIMITIVE, defender_civ), TID(int32_t) },
    { FLD(CONTAINER, snatcher_hf), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, victim_hf), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, ordinal), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_collection_abductionst::_identity(sizeof(history_event_collection_abductionst), &allocator_fn<history_event_collection_abductionst>, "history_event_collection_abductionst",NULL,&history_event_collection::_identity,history_event_collection_abductionst_fields);
  #define CUR_STRUCT history_event_collection_battlest
  static const struct_field_info history_event_collection_battlest_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, parent_collection), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD(CONTAINER, attacker_civ), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, defender_civ), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, attacker_hf), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, defender_hf), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, noncombat_hf), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, attacker_squad_entity_pop), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, attacker_squad_counts), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, attacker_squad_deaths), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, attacker_squad_races), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, attacker_squad_sites), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, defender_squad_entity_pops), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, defender_squad_counts), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, defender_squad_deaths), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, defender_squad_races), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, defender_squad_sites), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, outcome), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_collection_battlest::_identity(sizeof(history_event_collection_battlest), &allocator_fn<history_event_collection_battlest>, "history_event_collection_battlest",NULL,&history_event_collection::_identity,history_event_collection_battlest_fields);
  #define CUR_STRUCT history_event_collection_beast_attackst
  static const struct_field_info history_event_collection_beast_attackst_fields[] = {
    { FLD(PRIMITIVE, parent_collection), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD(PRIMITIVE, defender_civ), TID(int32_t) },
    { FLD(CONTAINER, attacker_hf), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, ordinal), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_collection_beast_attackst::_identity(sizeof(history_event_collection_beast_attackst), &allocator_fn<history_event_collection_beast_attackst>, "history_event_collection_beast_attackst",NULL,&history_event_collection::_identity,history_event_collection_beast_attackst_fields);
  #define CUR_STRUCT history_event_collection_duelst
  static const struct_field_info history_event_collection_duelst_fields[] = {
    { FLD(PRIMITIVE, parent_collection), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD(PRIMITIVE, attacker_hf), TID(int32_t) },
    { FLD(PRIMITIVE, defender_hf), TID(int32_t) },
    { FLD(PRIMITIVE, ordinal), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_collection_duelst::_identity(sizeof(history_event_collection_duelst), &allocator_fn<history_event_collection_duelst>, "history_event_collection_duelst",NULL,&history_event_collection::_identity,history_event_collection_duelst_fields);
  #define CUR_STRUCT history_event_collection_insurrectionst
  static const struct_field_info history_event_collection_insurrectionst_fields[] = {
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, target_civ), TID(int32_t) },
    { FLD(PRIMITIVE, ordinal), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_collection_insurrectionst::_identity(sizeof(history_event_collection_insurrectionst), &allocator_fn<history_event_collection_insurrectionst>, "history_event_collection_insurrectionst",NULL,&history_event_collection::_identity,history_event_collection_insurrectionst_fields);
  #define CUR_STRUCT history_event_collection_journeyst
  static const struct_field_info history_event_collection_journeyst_fields[] = {
    { FLD(CONTAINER, traveler_hf), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, ordinal), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_collection_journeyst::_identity(sizeof(history_event_collection_journeyst), &allocator_fn<history_event_collection_journeyst>, "history_event_collection_journeyst",NULL,&history_event_collection::_identity,history_event_collection_journeyst_fields);
  #define CUR_STRUCT history_event_collection_site_conqueredst
  static const struct_field_info history_event_collection_site_conqueredst_fields[] = {
    { FLD(PRIMITIVE, parent_collection), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(CONTAINER, attacker_civ), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, defender_civ), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, ordinal), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_collection_site_conqueredst::_identity(sizeof(history_event_collection_site_conqueredst), &allocator_fn<history_event_collection_site_conqueredst>, "history_event_collection_site_conqueredst",NULL,&history_event_collection::_identity,history_event_collection_site_conqueredst_fields);
  #define CUR_STRUCT history_event_collection_theftst
  static const struct_field_info history_event_collection_theftst_fields[] = {
    { FLD(PRIMITIVE, parent_collection), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD(PRIMITIVE, thief_civ), TID(int32_t) },
    { FLD(PRIMITIVE, victim_civ), TID(int32_t) },
    { FLD(CONTAINER, thief_hf), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, stolen_item_types), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, stolen_item_subtypes), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, stolen_mat_types), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, stolen_mat_indices), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, stolen_item_ids), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_6), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, ordinal), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_collection_theftst::_identity(sizeof(history_event_collection_theftst), &allocator_fn<history_event_collection_theftst>, "history_event_collection_theftst",NULL,&history_event_collection::_identity,history_event_collection_theftst_fields);
  #define CUR_STRUCT history_event_collection_warst::T_unk
  static const struct_field_info history_event_collection_warst_doT_Dot_T_unk_fields[] = {
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(CONTAINER, ethics_unk1), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, disputed_ethics), identity_traits<std::vector<df::ethic_type > >::get(), 0, NULL },
    { FLD(CONTAINER, ethics_unk3), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, dispute_severities), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, worst_severity), TID(int32_t) },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_8), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_9), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity history_event_collection_warst::T_unk::_identity(sizeof(history_event_collection_warst::T_unk), &allocator_fn<history_event_collection_warst::T_unk>, &history_event_collection_warst::_identity, "T_unk",NULL,history_event_collection_warst_doT_Dot_T_unk_fields);
  #define CUR_STRUCT history_event_collection_warst
  static const struct_field_info history_event_collection_warst_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(CONTAINER, attacker_civ), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, defender_civ), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, unk), &history_event_collection_warst::T_unk::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_collection_warst::_identity(sizeof(history_event_collection_warst), &allocator_fn<history_event_collection_warst>, "history_event_collection_warst",NULL,&history_event_collection::_identity,history_event_collection_warst_fields);
  #define CUR_STRUCT history_event_context
  static const struct_field_info history_event_context_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, histfig_id_talker), TID(int32_t) },
    { FLD(PRIMITIVE, histfig_id_listener), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity history_event_context::_identity(sizeof(history_event_context), &allocator_fn<history_event_context>, NULL, "history_event_context",NULL,history_event_context_fields);
  #define CUR_STRUCT history_event_create_entity_positionst
  static const struct_field_info history_event_create_entity_positionst_fields[] = {
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, position), TID(int32_t) },
    { FLD(PRIMITIVE, reason), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_create_entity_positionst::_identity(sizeof(history_event_create_entity_positionst), &allocator_fn<history_event_create_entity_positionst>, "history_event_create_entity_positionst",NULL,&history_event::_identity,history_event_create_entity_positionst_fields);
  #define CUR_STRUCT history_event_created_buildingst
  static const struct_field_info history_event_created_buildingst_fields[] = {
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, structure), TID(int32_t) },
    { FLD(PRIMITIVE, builder_hf), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_created_buildingst::_identity(sizeof(history_event_created_buildingst), &allocator_fn<history_event_created_buildingst>, "history_event_created_buildingst",NULL,&history_event::_identity,history_event_created_buildingst_fields);
  #define CUR_STRUCT history_event_created_sitest
  static const struct_field_info history_event_created_sitest_fields[] = {
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, builder_hf), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_created_sitest::_identity(sizeof(history_event_created_sitest), &allocator_fn<history_event_created_sitest>, "history_event_created_sitest",NULL,&history_event::_identity,history_event_created_sitest_fields);
  #define CUR_STRUCT history_event_created_world_constructionst
  static const struct_field_info history_event_created_world_constructionst_fields[] = {
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, construction), TID(int32_t) },
    { FLD(PRIMITIVE, master_construction), TID(int32_t) },
    { FLD(PRIMITIVE, site1), TID(int32_t) },
    { FLD(PRIMITIVE, site2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_created_world_constructionst::_identity(sizeof(history_event_created_world_constructionst), &allocator_fn<history_event_created_world_constructionst>, "history_event_created_world_constructionst",NULL,&history_event::_identity,history_event_created_world_constructionst_fields);
  #define CUR_STRUCT history_event_creature_devouredst
  static const struct_field_info history_event_creature_devouredst_fields[] = {
    { FLD(PRIMITIVE, victim), TID(int32_t) },
    { FLD(PRIMITIVE, race), TID(int32_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(PRIMITIVE, eater), TID(int32_t) },
    { FLD(PRIMITIVE, entity), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_creature_devouredst::_identity(sizeof(history_event_creature_devouredst), &allocator_fn<history_event_creature_devouredst>, "history_event_creature_devouredst",NULL,&history_event::_identity,history_event_creature_devouredst_fields);
  #define CUR_STRUCT history_event_diplomat_lostst
  static const struct_field_info history_event_diplomat_lostst_fields[] = {
    { FLD(PRIMITIVE, entity), TID(int32_t) },
    { FLD(PRIMITIVE, involved), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_diplomat_lostst::_identity(sizeof(history_event_diplomat_lostst), &allocator_fn<history_event_diplomat_lostst>, "history_event_diplomat_lostst",NULL,&history_event::_identity,history_event_diplomat_lostst_fields);
  #define CUR_STRUCT history_event_entity_actionst
  static const struct_field_info history_event_entity_actionst_fields[] = {
    { FLD(PRIMITIVE, entity), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, structure), TID(int32_t) },
    { FLD(PRIMITIVE, action), TID(entity_action_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_entity_actionst::_identity(sizeof(history_event_entity_actionst), &allocator_fn<history_event_entity_actionst>, "history_event_entity_actionst",NULL,&history_event::_identity,history_event_entity_actionst_fields);
  #define CUR_STRUCT history_event_entity_createdst
  static const struct_field_info history_event_entity_createdst_fields[] = {
    { FLD(PRIMITIVE, entity), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, structure), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_entity_createdst::_identity(sizeof(history_event_entity_createdst), &allocator_fn<history_event_entity_createdst>, "history_event_entity_createdst",NULL,&history_event::_identity,history_event_entity_createdst_fields);
  #define CUR_STRUCT history_event_entity_incorporatedst
  static const struct_field_info history_event_entity_incorporatedst_fields[] = {
    { FLD(PRIMITIVE, migrant_entity), TID(int32_t) },
    { FLD(PRIMITIVE, join_entity), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_entity_incorporatedst::_identity(sizeof(history_event_entity_incorporatedst), &allocator_fn<history_event_entity_incorporatedst>, "history_event_entity_incorporatedst",NULL,&history_event::_identity,history_event_entity_incorporatedst_fields);
  #define CUR_STRUCT history_event_entity_lawst
  static const struct_field_info history_event_entity_lawst_fields[] = {
    { FLD(PRIMITIVE, entity), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, add_flags), TID(int32_t) },
    { FLD(PRIMITIVE, remove_flags), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_entity_lawst::_identity(sizeof(history_event_entity_lawst), &allocator_fn<history_event_entity_lawst>, "history_event_entity_lawst",NULL,&history_event::_identity,history_event_entity_lawst_fields);
  #define CUR_STRUCT history_event_entity_razed_buildingst
  static const struct_field_info history_event_entity_razed_buildingst_fields[] = {
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, structure), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_entity_razed_buildingst::_identity(sizeof(history_event_entity_razed_buildingst), &allocator_fn<history_event_entity_razed_buildingst>, "history_event_entity_razed_buildingst",NULL,&history_event::_identity,history_event_entity_razed_buildingst_fields);
  #define CUR_STRUCT history_event_first_contact_failedst
  static const struct_field_info history_event_first_contact_failedst_fields[] = {
    { FLD(PRIMITIVE, contactor), TID(int32_t) },
    { FLD(PRIMITIVE, rejector), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_first_contact_failedst::_identity(sizeof(history_event_first_contact_failedst), &allocator_fn<history_event_first_contact_failedst>, "history_event_first_contact_failedst",NULL,&history_event::_identity,history_event_first_contact_failedst_fields);
  #define CUR_STRUCT history_event_first_contactst
  static const struct_field_info history_event_first_contactst_fields[] = {
    { FLD(PRIMITIVE, contactor), TID(int32_t) },
    { FLD(PRIMITIVE, contacted), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_first_contactst::_identity(sizeof(history_event_first_contactst), &allocator_fn<history_event_first_contactst>, "history_event_first_contactst",NULL,&history_event::_identity,history_event_first_contactst_fields);
  #define CUR_STRUCT history_event_hf_act_on_buildingst
  static const struct_field_info history_event_hf_act_on_buildingst_fields[] = {
    { FLD(PRIMITIVE, action), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, structure), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hf_act_on_buildingst::_identity(sizeof(history_event_hf_act_on_buildingst), &allocator_fn<history_event_hf_act_on_buildingst>, "history_event_hf_act_on_buildingst",NULL,&history_event::_identity,history_event_hf_act_on_buildingst_fields);
  #define CUR_STRUCT history_event_hf_attacked_sitest
  static const struct_field_info history_event_hf_attacked_sitest_fields[] = {
    { FLD(PRIMITIVE, attacker_hf), TID(int32_t) },
    { FLD(PRIMITIVE, defender_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hf_attacked_sitest::_identity(sizeof(history_event_hf_attacked_sitest), &allocator_fn<history_event_hf_attacked_sitest>, "history_event_hf_attacked_sitest",NULL,&history_event::_identity,history_event_hf_attacked_sitest_fields);
  #define CUR_STRUCT history_event_hf_confrontedst
  static const struct_field_info history_event_hf_confrontedst_fields[] = {
    { FLD(PRIMITIVE, target), TID(int32_t) },
    { FLD(PRIMITIVE, accuser), TID(int32_t) },
    { FLD(CONTAINER, reasons), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hf_confrontedst::_identity(sizeof(history_event_hf_confrontedst), &allocator_fn<history_event_hf_confrontedst>, "history_event_hf_confrontedst",NULL,&history_event::_identity,history_event_hf_confrontedst_fields);
  #define CUR_STRUCT history_event_hf_destroyed_sitest
  static const struct_field_info history_event_hf_destroyed_sitest_fields[] = {
    { FLD(PRIMITIVE, attacker_hf), TID(int32_t) },
    { FLD(PRIMITIVE, defender_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hf_destroyed_sitest::_identity(sizeof(history_event_hf_destroyed_sitest), &allocator_fn<history_event_hf_destroyed_sitest>, "history_event_hf_destroyed_sitest",NULL,&history_event::_identity,history_event_hf_destroyed_sitest_fields);
  #define CUR_STRUCT history_event_hf_does_interactionst
  static const struct_field_info history_event_hf_does_interactionst_fields[] = {
    { FLD(PRIMITIVE, doer), TID(int32_t) },
    { FLD(PRIMITIVE, target), TID(int32_t) },
    { FLD(PRIMITIVE, interaction), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hf_does_interactionst::_identity(sizeof(history_event_hf_does_interactionst), &allocator_fn<history_event_hf_does_interactionst>, "history_event_hf_does_interactionst",NULL,&history_event::_identity,history_event_hf_does_interactionst_fields);
  #define CUR_STRUCT history_event_hf_gains_secret_goalst
  static const struct_field_info history_event_hf_gains_secret_goalst_fields[] = {
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, goal), TID(goal_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hf_gains_secret_goalst::_identity(sizeof(history_event_hf_gains_secret_goalst), &allocator_fn<history_event_hf_gains_secret_goalst>, "history_event_hf_gains_secret_goalst",NULL,&history_event::_identity,history_event_hf_gains_secret_goalst_fields);
  #define CUR_STRUCT history_event_hf_learns_secretst
  static const struct_field_info history_event_hf_learns_secretst_fields[] = {
    { FLD(PRIMITIVE, student), TID(int32_t) },
    { FLD(PRIMITIVE, teacher), TID(int32_t) },
    { FLD(PRIMITIVE, artifact), TID(int32_t) },
    { FLD(PRIMITIVE, interaction), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hf_learns_secretst::_identity(sizeof(history_event_hf_learns_secretst), &allocator_fn<history_event_hf_learns_secretst>, "history_event_hf_learns_secretst",NULL,&history_event::_identity,history_event_hf_learns_secretst_fields);
  #define CUR_STRUCT history_event_hf_razed_buildingst
  static const struct_field_info history_event_hf_razed_buildingst_fields[] = {
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, structure), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hf_razed_buildingst::_identity(sizeof(history_event_hf_razed_buildingst), &allocator_fn<history_event_hf_razed_buildingst>, "history_event_hf_razed_buildingst",NULL,&history_event::_identity,history_event_hf_razed_buildingst_fields);
  #define CUR_STRUCT history_event_hist_figure_abductedst
  static const struct_field_info history_event_hist_figure_abductedst_fields[] = {
    { FLD(PRIMITIVE, target), TID(int32_t) },
    { FLD(PRIMITIVE, snatcher), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hist_figure_abductedst::_identity(sizeof(history_event_hist_figure_abductedst), &allocator_fn<history_event_hist_figure_abductedst>, "history_event_hist_figure_abductedst",NULL,&history_event::_identity,history_event_hist_figure_abductedst_fields);
  #define CUR_STRUCT history_event_hist_figure_diedst
  static const struct_field_info history_event_hist_figure_diedst_fields[] = {
    { FLD(PRIMITIVE, victim_hf), TID(int32_t) },
    { FLD(PRIMITIVE, slayer_hf), TID(int32_t) },
    { FLD(PRIMITIVE, slayer_race), TID(int32_t) },
    { FLD(PRIMITIVE, slayer_caste), TID(int32_t) },
    { FLD(SUBSTRUCT, weapon), &history_hit_item::_identity },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, subregion), TID(int32_t) },
    { FLD(PRIMITIVE, feature_layer), TID(int32_t) },
    { FLD(PRIMITIVE, death_cause), identity_traits<enum_field<df::death_type,int16_t> >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hist_figure_diedst::_identity(sizeof(history_event_hist_figure_diedst), &allocator_fn<history_event_hist_figure_diedst>, "history_event_hist_figure_diedst",NULL,&history_event::_identity,history_event_hist_figure_diedst_fields);
  #define CUR_STRUCT history_event_hist_figure_new_petst
  static const struct_field_info history_event_hist_figure_new_petst_fields[] = {
    { FLD(CONTAINER, group), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pets), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hist_figure_new_petst::_identity(sizeof(history_event_hist_figure_new_petst), &allocator_fn<history_event_hist_figure_new_petst>, "history_event_hist_figure_new_petst",NULL,&history_event::_identity,history_event_hist_figure_new_petst_fields);
  #define CUR_STRUCT history_event_hist_figure_reach_summitst
  static const struct_field_info history_event_hist_figure_reach_summitst_fields[] = {
    { FLD(CONTAINER, group), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hist_figure_reach_summitst::_identity(sizeof(history_event_hist_figure_reach_summitst), &allocator_fn<history_event_hist_figure_reach_summitst>, "history_event_hist_figure_reach_summitst",NULL,&history_event::_identity,history_event_hist_figure_reach_summitst_fields);
  #define CUR_STRUCT history_event_hist_figure_reunionst
  static const struct_field_info history_event_hist_figure_reunionst_fields[] = {
    { FLD(CONTAINER, missing), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, reunited_with), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, assistant), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hist_figure_reunionst::_identity(sizeof(history_event_hist_figure_reunionst), &allocator_fn<history_event_hist_figure_reunionst>, "history_event_hist_figure_reunionst",NULL,&history_event::_identity,history_event_hist_figure_reunionst_fields);
  #define CUR_STRUCT history_event_hist_figure_revivedst
  static const struct_field_info history_event_hist_figure_revivedst_fields[] = {
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(PRIMITIVE, ghost_type), TID(ghost_type) },
    { FLD(PRIMITIVE, flags), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hist_figure_revivedst::_identity(sizeof(history_event_hist_figure_revivedst), &allocator_fn<history_event_hist_figure_revivedst>, "history_event_hist_figure_revivedst",NULL,&history_event::_identity,history_event_hist_figure_revivedst_fields);
  #define CUR_STRUCT history_event_hist_figure_simple_battle_eventst
  static const struct_field_info history_event_hist_figure_simple_battle_eventst_fields[] = {
    { FLD(CONTAINER, group1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, group2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(PRIMITIVE, subtype), identity_traits<enum_field<df::history_event_simple_battle_subtype,int16_t> >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hist_figure_simple_battle_eventst::_identity(sizeof(history_event_hist_figure_simple_battle_eventst), &allocator_fn<history_event_hist_figure_simple_battle_eventst>, "history_event_hist_figure_simple_battle_eventst",NULL,&history_event::_identity,history_event_hist_figure_simple_battle_eventst_fields);
  #define CUR_STRUCT history_event_hist_figure_travelst
  static const struct_field_info history_event_hist_figure_travelst_fields[] = {
    { FLD(CONTAINER, group), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(PRIMITIVE, reason), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hist_figure_travelst::_identity(sizeof(history_event_hist_figure_travelst), &allocator_fn<history_event_hist_figure_travelst>, "history_event_hist_figure_travelst",NULL,&history_event::_identity,history_event_hist_figure_travelst_fields);
  #define CUR_STRUCT history_event_hist_figure_woundedst
  static const struct_field_info history_event_hist_figure_woundedst_fields[] = {
    { FLD(PRIMITIVE, woundee), TID(int32_t) },
    { FLD(PRIMITIVE, wounder), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(PRIMITIVE, woundee_race), TID(int32_t) },
    { FLD(PRIMITIVE, woundee_caste), TID(int16_t) },
    { FLD(PRIMITIVE, body_part), TID(int16_t) },
    { FLD(PRIMITIVE, injury_type), TID(int16_t) },
    { FLD(PRIMITIVE, part_lost), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_hist_figure_woundedst::_identity(sizeof(history_event_hist_figure_woundedst), &allocator_fn<history_event_hist_figure_woundedst>, "history_event_hist_figure_woundedst",NULL,&history_event::_identity,history_event_hist_figure_woundedst_fields);
  #define CUR_STRUCT history_event_insurrection_endedst
  static const struct_field_info history_event_insurrection_endedst_fields[] = {
    { FLD(PRIMITIVE, target_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, outcome), TID(insurrection_outcome) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_insurrection_endedst::_identity(sizeof(history_event_insurrection_endedst), &allocator_fn<history_event_insurrection_endedst>, "history_event_insurrection_endedst",NULL,&history_event::_identity,history_event_insurrection_endedst_fields);
  #define CUR_STRUCT history_event_insurrection_startedst
  static const struct_field_info history_event_insurrection_startedst_fields[] = {
    { FLD(PRIMITIVE, target_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_insurrection_startedst::_identity(sizeof(history_event_insurrection_startedst), &allocator_fn<history_event_insurrection_startedst>, "history_event_insurrection_startedst",NULL,&history_event::_identity,history_event_insurrection_startedst_fields);
  #define CUR_STRUCT history_event_item_stolenst
  static const struct_field_info history_event_item_stolenst_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mattype), TID(int16_t) },
    { FLD(PRIMITIVE, matindex), TID(int32_t) },
    { FLD(PRIMITIVE, item), TID(int32_t) },
    { FLD(PRIMITIVE, entity), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, structure), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_item_stolenst::_identity(sizeof(history_event_item_stolenst), &allocator_fn<history_event_item_stolenst>, "history_event_item_stolenst",NULL,&history_event::_identity,history_event_item_stolenst_fields);
  #define CUR_STRUCT history_event_masterpiece_created_arch_constructst
  static const struct_field_info history_event_masterpiece_created_arch_constructst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, building_type), TID(int16_t) },
    { FLD(PRIMITIVE, building_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, building_custom), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_masterpiece_created_arch_constructst::_identity(sizeof(history_event_masterpiece_created_arch_constructst), &allocator_fn<history_event_masterpiece_created_arch_constructst>, "history_event_masterpiece_created_arch_constructst",NULL,&history_event_masterpiece_createdst::_identity,history_event_masterpiece_created_arch_constructst_fields);
  #define CUR_STRUCT history_event_masterpiece_created_arch_designst
  static const struct_field_info history_event_masterpiece_created_arch_designst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, building_type), TID(int16_t) },
    { FLD(PRIMITIVE, building_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, building_custom), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_masterpiece_created_arch_designst::_identity(sizeof(history_event_masterpiece_created_arch_designst), &allocator_fn<history_event_masterpiece_created_arch_designst>, "history_event_masterpiece_created_arch_designst",NULL,&history_event_masterpiece_createdst::_identity,history_event_masterpiece_created_arch_designst_fields);
  #define CUR_STRUCT history_event_masterpiece_created_dye_itemst
  static const struct_field_info history_event_masterpiece_created_dye_itemst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, dye_mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, dye_mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_masterpiece_created_dye_itemst::_identity(sizeof(history_event_masterpiece_created_dye_itemst), &allocator_fn<history_event_masterpiece_created_dye_itemst>, "history_event_masterpiece_created_dye_itemst",NULL,&history_event_masterpiece_createdst::_identity,history_event_masterpiece_created_dye_itemst_fields);
  #define CUR_STRUCT history_event_masterpiece_created_engravingst
  static const struct_field_info history_event_masterpiece_created_engravingst_fields[] = {
    { FLD(PRIMITIVE, skill_rating), TID(skill_rating) },
    { FLD(PRIMITIVE, art_id), TID(int32_t) },
    { FLD(PRIMITIVE, art_subid), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_masterpiece_created_engravingst::_identity(sizeof(history_event_masterpiece_created_engravingst), &allocator_fn<history_event_masterpiece_created_engravingst>, "history_event_masterpiece_created_engravingst",NULL,&history_event_masterpiece_createdst::_identity,history_event_masterpiece_created_engravingst_fields);
  #define CUR_STRUCT history_event_masterpiece_created_foodst
  static const struct_field_info history_event_masterpiece_created_foodst_fields[] = {
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, item_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_masterpiece_created_foodst::_identity(sizeof(history_event_masterpiece_created_foodst), &allocator_fn<history_event_masterpiece_created_foodst>, "history_event_masterpiece_created_foodst",NULL,&history_event_masterpiece_createdst::_identity,history_event_masterpiece_created_foodst_fields);
  #define CUR_STRUCT history_event_masterpiece_created_item_improvementst
  static const struct_field_info history_event_masterpiece_created_item_improvementst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, improvement_type), identity_traits<enum_field<df::improvement_type,int16_t> >::get() },
    { FLD(PRIMITIVE, improvement_subtype), TID(int32_t) },
    { FLD(PRIMITIVE, imp_mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, imp_mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, art_id), TID(int32_t) },
    { FLD(PRIMITIVE, art_subid), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_masterpiece_created_item_improvementst::_identity(sizeof(history_event_masterpiece_created_item_improvementst), &allocator_fn<history_event_masterpiece_created_item_improvementst>, "history_event_masterpiece_created_item_improvementst",NULL,&history_event_masterpiece_createdst::_identity,history_event_masterpiece_created_item_improvementst_fields);
  #define CUR_STRUCT history_event_masterpiece_created_itemst
  static const struct_field_info history_event_masterpiece_created_itemst_fields[] = {
    { FLD(PRIMITIVE, skill_used), identity_traits<enum_field<df::job_skill,int32_t> >::get() },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int16_t) },
    { FLD(PRIMITIVE, item_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_masterpiece_created_itemst::_identity(sizeof(history_event_masterpiece_created_itemst), &allocator_fn<history_event_masterpiece_created_itemst>, "history_event_masterpiece_created_itemst",NULL,&history_event_masterpiece_createdst::_identity,history_event_masterpiece_created_itemst_fields);
  #define CUR_STRUCT history_event_masterpiece_createdst
  static const struct_field_info history_event_masterpiece_createdst_fields[] = {
    { FLD(PRIMITIVE, maker), TID(int32_t) },
    { FLD(PRIMITIVE, maker_entity), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_masterpiece_createdst::_identity(sizeof(history_event_masterpiece_createdst), &allocator_fn<history_event_masterpiece_createdst>, "history_event_masterpiece_createdst",NULL,&history_event::_identity,history_event_masterpiece_createdst_fields);
  #define CUR_STRUCT history_event_masterpiece_lostst
  static const struct_field_info history_event_masterpiece_lostst_fields[] = {
    { FLD(PRIMITIVE, creation_event), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, method), identity_traits<enum_field<df::masterpiece_loss_type,int16_t> >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_masterpiece_lostst::_identity(sizeof(history_event_masterpiece_lostst), &allocator_fn<history_event_masterpiece_lostst>, "history_event_masterpiece_lostst",NULL,&history_event::_identity,history_event_masterpiece_lostst_fields);
  #define CUR_STRUCT history_event_merchantst
  static const struct_field_info history_event_merchantst_fields[] = {
    { FLD(PRIMITIVE, source), TID(int32_t) },
    { FLD(PRIMITIVE, destination), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(CONTAINER, flags2), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_merchantst::_identity(sizeof(history_event_merchantst), &allocator_fn<history_event_merchantst>, "history_event_merchantst",NULL,&history_event::_identity,history_event_merchantst_fields);
  #define CUR_STRUCT history_event_reclaim_sitest
  static const struct_field_info history_event_reclaim_sitest_fields[] = {
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, flags), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_reclaim_sitest::_identity(sizeof(history_event_reclaim_sitest), &allocator_fn<history_event_reclaim_sitest>, "history_event_reclaim_sitest",NULL,&history_event::_identity,history_event_reclaim_sitest_fields);
  #define CUR_STRUCT history_event_remove_hf_entity_linkst
  static const struct_field_info history_event_remove_hf_entity_linkst_fields[] = {
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, link_type), TID(histfig_entity_link_type) },
    { FLD(PRIMITIVE, position_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_remove_hf_entity_linkst::_identity(sizeof(history_event_remove_hf_entity_linkst), &allocator_fn<history_event_remove_hf_entity_linkst>, "history_event_remove_hf_entity_linkst",NULL,&history_event::_identity,history_event_remove_hf_entity_linkst_fields);
  #define CUR_STRUCT history_event_remove_hf_hf_linkst
  static const struct_field_info history_event_remove_hf_hf_linkst_fields[] = {
    { FLD(PRIMITIVE, hf), TID(int32_t) },
    { FLD(PRIMITIVE, hf_target), TID(int32_t) },
    { FLD(PRIMITIVE, type), TID(histfig_hf_link_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_remove_hf_hf_linkst::_identity(sizeof(history_event_remove_hf_hf_linkst), &allocator_fn<history_event_remove_hf_hf_linkst>, "history_event_remove_hf_hf_linkst",NULL,&history_event::_identity,history_event_remove_hf_hf_linkst_fields);
  #define CUR_STRUCT history_event_remove_hf_site_linkst
  static const struct_field_info history_event_remove_hf_site_linkst_fields[] = {
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, structure), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int32_t) },
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, type), TID(histfig_site_link_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_remove_hf_site_linkst::_identity(sizeof(history_event_remove_hf_site_linkst), &allocator_fn<history_event_remove_hf_site_linkst>, "history_event_remove_hf_site_linkst",NULL,&history_event::_identity,history_event_remove_hf_site_linkst_fields);
  #define CUR_STRUCT history_event_replaced_buildingst
  static const struct_field_info history_event_replaced_buildingst_fields[] = {
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, old_structure), TID(int32_t) },
    { FLD(PRIMITIVE, new_structure), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_replaced_buildingst::_identity(sizeof(history_event_replaced_buildingst), &allocator_fn<history_event_replaced_buildingst>, "history_event_replaced_buildingst",NULL,&history_event::_identity,history_event_replaced_buildingst_fields);
  #define CUR_STRUCT history_event_site_diedst
  static const struct_field_info history_event_site_diedst_fields[] = {
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, flags), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_site_diedst::_identity(sizeof(history_event_site_diedst), &allocator_fn<history_event_site_diedst>, "history_event_site_diedst",NULL,&history_event::_identity,history_event_site_diedst_fields);
  #define CUR_STRUCT history_event_site_disputest
  static const struct_field_info history_event_site_disputest_fields[] = {
    { FLD(PRIMITIVE, dispute_type), TID(site_dispute_type) },
    { FLD(PRIMITIVE, entity_1), TID(int32_t) },
    { FLD(PRIMITIVE, entity_2), TID(int32_t) },
    { FLD(PRIMITIVE, site_1), TID(int32_t) },
    { FLD(PRIMITIVE, site_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_site_disputest::_identity(sizeof(history_event_site_disputest), &allocator_fn<history_event_site_disputest>, "history_event_site_disputest",NULL,&history_event::_identity,history_event_site_disputest_fields);
  #define CUR_STRUCT history_event_site_retiredst
  static const struct_field_info history_event_site_retiredst_fields[] = {
    { FLD(PRIMITIVE, civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, flags), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_site_retiredst::_identity(sizeof(history_event_site_retiredst), &allocator_fn<history_event_site_retiredst>, "history_event_site_retiredst",NULL,&history_event::_identity,history_event_site_retiredst_fields);
  #define CUR_STRUCT history_event_topicagreement_concludedst
  static const struct_field_info history_event_topicagreement_concludedst_fields[] = {
    { FLD(PRIMITIVE, source), TID(int32_t) },
    { FLD(PRIMITIVE, destination), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, topic), TID(meeting_topic) },
    { FLD(PRIMITIVE, result), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_topicagreement_concludedst::_identity(sizeof(history_event_topicagreement_concludedst), &allocator_fn<history_event_topicagreement_concludedst>, "history_event_topicagreement_concludedst",NULL,&history_event::_identity,history_event_topicagreement_concludedst_fields);
  #define CUR_STRUCT history_event_topicagreement_madest
  static const struct_field_info history_event_topicagreement_madest_fields[] = {
    { FLD(PRIMITIVE, topic), TID(meeting_topic) },
    { FLD(PRIMITIVE, source), TID(int32_t) },
    { FLD(PRIMITIVE, destination), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_topicagreement_madest::_identity(sizeof(history_event_topicagreement_madest), &allocator_fn<history_event_topicagreement_madest>, "history_event_topicagreement_madest",NULL,&history_event::_identity,history_event_topicagreement_madest_fields);
  #define CUR_STRUCT history_event_topicagreement_rejectedst
  static const struct_field_info history_event_topicagreement_rejectedst_fields[] = {
    { FLD(PRIMITIVE, topic), TID(meeting_topic) },
    { FLD(PRIMITIVE, source), TID(int32_t) },
    { FLD(PRIMITIVE, destination), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_topicagreement_rejectedst::_identity(sizeof(history_event_topicagreement_rejectedst), &allocator_fn<history_event_topicagreement_rejectedst>, "history_event_topicagreement_rejectedst",NULL,&history_event::_identity,history_event_topicagreement_rejectedst_fields);
  #define CUR_STRUCT history_event_war_attacked_sitest
  static const struct_field_info history_event_war_attacked_sitest_fields[] = {
    { FLD(PRIMITIVE, attacker_civ), TID(int32_t) },
    { FLD(PRIMITIVE, defender_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, attacker_general_hf), TID(int32_t) },
    { FLD(PRIMITIVE, defender_general_hf), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_war_attacked_sitest::_identity(sizeof(history_event_war_attacked_sitest), &allocator_fn<history_event_war_attacked_sitest>, "history_event_war_attacked_sitest",NULL,&history_event::_identity,history_event_war_attacked_sitest_fields);
  #define CUR_STRUCT history_event_war_destroyed_sitest
  static const struct_field_info history_event_war_destroyed_sitest_fields[] = {
    { FLD(PRIMITIVE, attacker_civ), TID(int32_t) },
    { FLD(PRIMITIVE, defender_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_war_destroyed_sitest::_identity(sizeof(history_event_war_destroyed_sitest), &allocator_fn<history_event_war_destroyed_sitest>, "history_event_war_destroyed_sitest",NULL,&history_event::_identity,history_event_war_destroyed_sitest_fields);
  #define CUR_STRUCT history_event_war_field_battlest
  static const struct_field_info history_event_war_field_battlest_fields[] = {
    { FLD(PRIMITIVE, attacker_civ), TID(int32_t) },
    { FLD(PRIMITIVE, defender_civ), TID(int32_t) },
    { FLD(PRIMITIVE, region), TID(int32_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD(PRIMITIVE, attacker_general_hf), TID(int32_t) },
    { FLD(PRIMITIVE, defender_general_hf), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_war_field_battlest::_identity(sizeof(history_event_war_field_battlest), &allocator_fn<history_event_war_field_battlest>, "history_event_war_field_battlest",NULL,&history_event::_identity,history_event_war_field_battlest_fields);
  #define CUR_STRUCT history_event_war_peace_acceptedst
  static const struct_field_info history_event_war_peace_acceptedst_fields[] = {
    { FLD(PRIMITIVE, topic), TID(meeting_topic) },
    { FLD(PRIMITIVE, source), TID(int32_t) },
    { FLD(PRIMITIVE, destination), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_war_peace_acceptedst::_identity(sizeof(history_event_war_peace_acceptedst), &allocator_fn<history_event_war_peace_acceptedst>, "history_event_war_peace_acceptedst",NULL,&history_event::_identity,history_event_war_peace_acceptedst_fields);
  #define CUR_STRUCT history_event_war_peace_rejectedst
  static const struct_field_info history_event_war_peace_rejectedst_fields[] = {
    { FLD(PRIMITIVE, topic), TID(meeting_topic) },
    { FLD(PRIMITIVE, source), TID(int32_t) },
    { FLD(PRIMITIVE, destination), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_war_peace_rejectedst::_identity(sizeof(history_event_war_peace_rejectedst), &allocator_fn<history_event_war_peace_rejectedst>, "history_event_war_peace_rejectedst",NULL,&history_event::_identity,history_event_war_peace_rejectedst_fields);
  #define CUR_STRUCT history_event_war_plundered_sitest
  static const struct_field_info history_event_war_plundered_sitest_fields[] = {
    { FLD(PRIMITIVE, attacker_civ), TID(int32_t) },
    { FLD(PRIMITIVE, defender_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_war_plundered_sitest::_identity(sizeof(history_event_war_plundered_sitest), &allocator_fn<history_event_war_plundered_sitest>, "history_event_war_plundered_sitest",NULL,&history_event::_identity,history_event_war_plundered_sitest_fields);
  #define CUR_STRUCT history_event_war_site_new_leaderst
  static const struct_field_info history_event_war_site_new_leaderst_fields[] = {
    { FLD(PRIMITIVE, attacker_civ), TID(int32_t) },
    { FLD(PRIMITIVE, new_site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, defender_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(CONTAINER, new_leaders), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_war_site_new_leaderst::_identity(sizeof(history_event_war_site_new_leaderst), &allocator_fn<history_event_war_site_new_leaderst>, "history_event_war_site_new_leaderst",NULL,&history_event::_identity,history_event_war_site_new_leaderst_fields);
  #define CUR_STRUCT history_event_war_site_taken_overst
  static const struct_field_info history_event_war_site_taken_overst_fields[] = {
    { FLD(PRIMITIVE, attacker_civ), TID(int32_t) },
    { FLD(PRIMITIVE, new_site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, defender_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_war_site_taken_overst::_identity(sizeof(history_event_war_site_taken_overst), &allocator_fn<history_event_war_site_taken_overst>, "history_event_war_site_taken_overst",NULL,&history_event::_identity,history_event_war_site_taken_overst_fields);
  #define CUR_STRUCT history_event_war_site_tribute_forcedst
  static const struct_field_info history_event_war_site_tribute_forcedst_fields[] = {
    { FLD(PRIMITIVE, attacker_civ), TID(int32_t) },
    { FLD(PRIMITIVE, defender_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site_civ), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity history_event_war_site_tribute_forcedst::_identity(sizeof(history_event_war_site_tribute_forcedst), &allocator_fn<history_event_war_site_tribute_forcedst>, "history_event_war_site_tribute_forcedst",NULL,&history_event::_identity,history_event_war_site_tribute_forcedst_fields);
  #define CUR_STRUCT history_hit_item
  static const struct_field_info history_hit_item_fields[] = {
    { FLD(PRIMITIVE, item), TID(int32_t) },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mattype), TID(int16_t) },
    { FLD(PRIMITIVE, matindex), TID(int32_t) },
    { FLD(PRIMITIVE, shooter_item), TID(int32_t) },
    { FLD(PRIMITIVE, shooter_item_type), TID(item_type) },
    { FLD(PRIMITIVE, shooter_item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, shooter_mattype), TID(int16_t) },
    { FLD(PRIMITIVE, shooter_matindex), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity history_hit_item::_identity(sizeof(history_hit_item), &allocator_fn<history_hit_item>, NULL, "history_hit_item",NULL,history_hit_item_fields);
  #define CUR_STRUCT hospital_supplies
  static const struct_field_info hospital_supplies_fields[] = {
    { FLD(SUBSTRUCT, supplies_needed), TID(hospital_supplies::T_supplies_needed) },
    { FLD(PRIMITIVE, max_splints), TID(int32_t) },
    { FLD(PRIMITIVE, max_thread), TID(int32_t) },
    { FLD(PRIMITIVE, max_cloth), TID(int32_t) },
    { FLD(PRIMITIVE, max_crutches), TID(int32_t) },
    { FLD(PRIMITIVE, max_plaster), TID(int32_t) },
    { FLD(PRIMITIVE, max_buckets), TID(int32_t) },
    { FLD(PRIMITIVE, max_soap), TID(int32_t) },
    { FLD(PRIMITIVE, cur_splints), TID(int32_t) },
    { FLD(PRIMITIVE, cur_thread), TID(int32_t) },
    { FLD(PRIMITIVE, cur_cloth), TID(int32_t) },
    { FLD(PRIMITIVE, cur_crutches), TID(int32_t) },
    { FLD(PRIMITIVE, cur_plaster), TID(int32_t) },
    { FLD(PRIMITIVE, cur_buckets), TID(int32_t) },
    { FLD(PRIMITIVE, cur_soap), TID(int32_t) },
    { FLD(PRIMITIVE, supply_recheck_timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity hospital_supplies::_identity(sizeof(hospital_supplies), &allocator_fn<hospital_supplies>, NULL, "hospital_supplies",NULL,hospital_supplies_fields);
  #define CUR_STRUCT identity
  static const struct_field_info identity_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, race), TID(int32_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(PRIMITIVE, histfig_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4c), TID(int32_t) },
    { FLD(PRIMITIVE, birth_year), TID(int32_t) },
    { FLD(PRIMITIVE, birth_second), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity::_identity(sizeof(identity), &allocator_fn<identity>, NULL, "identity",NULL,identity_fields);
  #define CUR_STRUCT incident
  static const struct_field_info incident_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(CONTAINER, witnesses), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, victim), TID(int32_t) },
    { FLD(PRIMITIVE, victim_hfid), TID(int32_t) },
    { FLD(PRIMITIVE, victim_race), TID(int32_t) },
    { FLD(PRIMITIVE, victim_caste), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1b), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1c), TID(int32_t) },
    { FLD(PRIMITIVE, killer), TID(int32_t) },
    { FLD(PRIMITIVE, killer_hfid), TID(int32_t) },
    { FLD(PRIMITIVE, killer_race), TID(int32_t) },
    { FLD(PRIMITIVE, killer_caste), TID(int32_t) },
    { FLD(PRIMITIVE, entity1), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_2c), TID(int32_t) },
    { FLD(PRIMITIVE, crime_id), TID(int32_t) },
    { FLD(PRIMITIVE, site), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_3a), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_3b), TID(int32_t) },
    { FLD(PRIMITIVE, entity), TID(int32_t) },
    { FLD(PRIMITIVE, event_year), TID(int32_t) },
    { FLD(PRIMITIVE, event_time), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(incident::T_flags) },
    { FLD(PRIMITIVE, death_cause), identity_traits<enum_field<df::death_type,int16_t> >::get() },
    { FLD(PRIMITIVE, unk_6c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_70), TID(int32_t) },
    { FLD(PRIMITIVE, world_x), TID(int32_t) },
    { FLD(PRIMITIVE, world_y), TID(int32_t) },
    { FLD(PRIMITIVE, world_z), TID(int32_t) },
    { FLD(PRIMITIVE, unk_80), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity incident::_identity(sizeof(incident), &allocator_fn<incident>, NULL, "incident",NULL,incident_fields);
  #define CUR_STRUCT init
  static const struct_field_info init_fields[] = {
    { FLD(SUBSTRUCT, display), &init_display::_identity },
    { FLD(SUBSTRUCT, media), &init_media::_identity },
    { FLD(SUBSTRUCT, input), &init_input::_identity },
    { FLD(SUBSTRUCT, font), &init_font::_identity },
    { FLD(SUBSTRUCT, window), &init_window::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity init::_identity(sizeof(init), &allocator_fn<init>, NULL, "init",NULL,init_fields);
  #define CUR_STRUCT init_display
  static const struct_field_info init_display_fields[] = {
    { FLD(CONTAINER, flag), identity_traits<BitArray<df::init_display_flags> >::get(), 0, TID(init_display_flags) },
    { FLD(PRIMITIVE, windowed), TID(init_display::T_windowed) },
    { FLD(PRIMITIVE, grid_x), TID(int32_t) },
    { FLD(PRIMITIVE, grid_y), TID(int32_t) },
    { FLD(PRIMITIVE, desired_fullscreen_width), TID(int32_t) },
    { FLD(PRIMITIVE, desired_fullscreen_height), TID(int32_t) },
    { FLD(PRIMITIVE, desired_windowed_width), TID(int32_t) },
    { FLD(PRIMITIVE, desired_windowed_height), TID(int32_t) },
    { FLD(PRIMITIVE, partial_print_count), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity init_display::_identity(sizeof(init_display), &allocator_fn<init_display>, NULL, "init_display",NULL,init_display_fields);
  #define CUR_STRUCT init_font
  static const struct_field_info init_font_fields[] = {
    { FLD(STATIC_ARRAY, small_font_texpos), identity_traits<int32_t >::get(), 256, NULL },
    { FLD(STATIC_ARRAY, large_font_texpos), identity_traits<int32_t >::get(), 256, NULL },
    { FLD(STATIC_ARRAY, small_font_datapos), identity_traits<int32_t >::get(), 256, NULL },
    { FLD(STATIC_ARRAY, large_font_datapos), identity_traits<int32_t >::get(), 256, NULL },
    { FLD(PRIMITIVE, small_font_adjx), TID(float) },
    { FLD(PRIMITIVE, small_font_adjy), TID(float) },
    { FLD(PRIMITIVE, large_font_adjx), TID(float) },
    { FLD(PRIMITIVE, large_font_adjy), TID(float) },
    { FLD(PRIMITIVE, small_font_dispx), TID(int32_t) },
    { FLD(PRIMITIVE, small_font_dispy), TID(int32_t) },
    { FLD(PRIMITIVE, large_font_dispx), TID(int32_t) },
    { FLD(PRIMITIVE, large_font_dispy), TID(int32_t) },
    { FLD(PRIMITIVE, use_ttf), TID(init_font::T_use_ttf) },
    { FLD(PRIMITIVE, ttf_limit), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity init_font::_identity(sizeof(init_font), &allocator_fn<init_font>, NULL, "init_font",NULL,init_font_fields);
  #define CUR_STRUCT init_input
  static const struct_field_info init_input_fields[] = {
    { FLD(PRIMITIVE, hold_time), TID(int32_t) },
    { FLD(PRIMITIVE, repeat_time), TID(int32_t) },
    { FLD(PRIMITIVE, macro_time), TID(int32_t) },
    { FLD(PRIMITIVE, pause_zoom_no_interface_ms), TID(int32_t) },
    { FLD(CONTAINER, flag), identity_traits<BitArray<df::init_input_flags> >::get(), 0, TID(init_input_flags) },
    { FLD(PRIMITIVE, zoom_speed), TID(int32_t) },
    { FLD(PRIMITIVE, repeat_accel_start), TID(int32_t) },
    { FLD(PRIMITIVE, repeat_accel_limit), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity init_input::_identity(sizeof(init_input), &allocator_fn<init_input>, NULL, "init_input",NULL,init_input_fields);
  #define CUR_STRUCT init_media
  static const struct_field_info init_media_fields[] = {
    { FLD(CONTAINER, flag), identity_traits<BitArray<df::init_media_flags> >::get(), 0, TID(init_media_flags) },
    { FLD(PRIMITIVE, volume), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity init_media::_identity(sizeof(init_media), &allocator_fn<init_media>, NULL, "init_media",NULL,init_media_fields);
  #define CUR_STRUCT init_window
  static const struct_field_info init_window_fields[] = {
    { FLD(CONTAINER, flag), identity_traits<BitArray<df::init_window_flags> >::get(), 0, TID(init_window_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity init_window::_identity(sizeof(init_window), &allocator_fn<init_window>, NULL, "init_window",NULL,init_window_fields);
  #define CUR_STRUCT inorganic_raw::T_metal_ore
  static const struct_field_info inorganic_raw_doT_Dot_T_metal_ore_fields[] = {
    { FLD(STL_VECTOR_PTR, str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, mat_index), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, probability), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity inorganic_raw::T_metal_ore::_identity(sizeof(inorganic_raw::T_metal_ore), &allocator_fn<inorganic_raw::T_metal_ore>, &inorganic_raw::_identity, "T_metal_ore",NULL,inorganic_raw_doT_Dot_T_metal_ore_fields);
  #define CUR_STRUCT inorganic_raw::T_thread_metal
  static const struct_field_info inorganic_raw_doT_Dot_T_thread_metal_fields[] = {
    { FLD(STL_VECTOR_PTR, str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, mat_index), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, probability), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity inorganic_raw::T_thread_metal::_identity(sizeof(inorganic_raw::T_thread_metal), &allocator_fn<inorganic_raw::T_thread_metal>, &inorganic_raw::_identity, "T_thread_metal",NULL,inorganic_raw_doT_Dot_T_thread_metal_fields);
  #define CUR_STRUCT inorganic_raw::T_environment_spec
  static const struct_field_info inorganic_raw_doT_Dot_T_environment_spec_fields[] = {
    { FLD(STL_VECTOR_PTR, str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, mat_index), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, inclusion_type), identity_traits<std::vector<df::inclusion_type > >::get(), 0, NULL },
    { FLD(CONTAINER, probability), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity inorganic_raw::T_environment_spec::_identity(sizeof(inorganic_raw::T_environment_spec), &allocator_fn<inorganic_raw::T_environment_spec>, &inorganic_raw::_identity, "T_environment_spec",NULL,inorganic_raw_doT_Dot_T_environment_spec_fields);
  #define CUR_STRUCT inorganic_raw::T_environment
  static const struct_field_info inorganic_raw_doT_Dot_T_environment_fields[] = {
    { FLD(CONTAINER, location), identity_traits<std::vector<df::environment_type > >::get(), 0, NULL },
    { FLD(CONTAINER, type), identity_traits<std::vector<df::inclusion_type > >::get(), 0, NULL },
    { FLD(CONTAINER, probability), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity inorganic_raw::T_environment::_identity(sizeof(inorganic_raw::T_environment), &allocator_fn<inorganic_raw::T_environment>, &inorganic_raw::_identity, "T_environment",NULL,inorganic_raw_doT_Dot_T_environment_fields);
  #define CUR_STRUCT inorganic_raw
  static const struct_field_info inorganic_raw_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::inorganic_flags> >::get(), 0, TID(inorganic_flags) },
    { FLD(PRIMITIVE, source_hfid), TID(int32_t) },
    { FLD(SUBSTRUCT, metal_ore), &inorganic_raw::T_metal_ore::_identity },
    { FLD(SUBSTRUCT, thread_metal), &inorganic_raw::T_thread_metal::_identity },
    { FLD(CONTAINER, economic_uses), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, environment_spec), &inorganic_raw::T_environment_spec::_identity },
    { FLD(SUBSTRUCT, environment), &inorganic_raw::T_environment::_identity },
    { FLD(PRIMITIVE, unk2), TID(int32_t) },
    { FLD(SUBSTRUCT, material), &material::_identity },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity inorganic_raw::_identity(sizeof(inorganic_raw), &allocator_fn<inorganic_raw>, NULL, "inorganic_raw",NULL,inorganic_raw_fields);
  #define CUR_STRUCT interaction
  static const struct_field_info interaction_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, str), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, sources), identity_traits<df::interaction_source >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, targets), identity_traits<df::interaction_target >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, effects), identity_traits<df::interaction_effect >::get(), 0, NULL },
    { FLD(PRIMITIVE, source_hfid), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity interaction::_identity(sizeof(interaction), &allocator_fn<interaction>, NULL, "interaction",NULL,interaction_fields);
  #define CUR_STRUCT interaction_effect
  static const struct_field_info interaction_effect_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, targets), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, intermittent), TID(int32_t) },
    { FLD(CONTAINER, locations), identity_traits<std::vector<df::interaction_effect_location_hint > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, flags), TID(interaction_effect::T_flags) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, arena_name), identity_traits<std::string >::get() },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, parseRaws) },
    { METHOD(OBJ_METHOD, finalize) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_effect::_identity(sizeof(interaction_effect), &allocator_fn<interaction_effect>, "interaction_effect","interaction_effectst",NULL,interaction_effect_fields);
  #define CUR_STRUCT interaction_effect_add_syndromest
  static const struct_field_info interaction_effect_add_syndromest_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_effect_add_syndromest::_identity(sizeof(interaction_effect_add_syndromest), &allocator_fn<interaction_effect_add_syndromest>, "interaction_effect_add_syndromest",NULL,&interaction_effect::_identity,interaction_effect_add_syndromest_fields);
  #define CUR_STRUCT interaction_effect_animatest
  static const struct_field_info interaction_effect_animatest_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_effect_animatest::_identity(sizeof(interaction_effect_animatest), &allocator_fn<interaction_effect_animatest>, "interaction_effect_animatest",NULL,&interaction_effect::_identity,interaction_effect_animatest_fields);
  #define CUR_STRUCT interaction_effect_cleanst
  static const struct_field_info interaction_effect_cleanst_fields[] = {
    { FLD(PRIMITIVE, grime_level), TID(int32_t) },
    { FLD(SUBSTRUCT, syndrome_tag), TID(syndrome_flags) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_effect_cleanst::_identity(sizeof(interaction_effect_cleanst), &allocator_fn<interaction_effect_cleanst>, "interaction_effect_cleanst",NULL,&interaction_effect::_identity,interaction_effect_cleanst_fields);
  #define CUR_STRUCT interaction_effect_contactst
  static const struct_field_info interaction_effect_contactst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_effect_contactst::_identity(sizeof(interaction_effect_contactst), &allocator_fn<interaction_effect_contactst>, "interaction_effect_contactst",NULL,&interaction_effect::_identity,interaction_effect_contactst_fields);
  #define CUR_STRUCT interaction_effect_hidest
  static const struct_field_info interaction_effect_hidest_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_effect_hidest::_identity(sizeof(interaction_effect_hidest), &allocator_fn<interaction_effect_hidest>, "interaction_effect_hidest",NULL,&interaction_effect::_identity,interaction_effect_hidest_fields);
  #define CUR_STRUCT interaction_effect_material_emissionst
  static const struct_field_info interaction_effect_material_emissionst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_effect_material_emissionst::_identity(sizeof(interaction_effect_material_emissionst), &allocator_fn<interaction_effect_material_emissionst>, "interaction_effect_material_emissionst",NULL,&interaction_effect::_identity,interaction_effect_material_emissionst_fields);
  #define CUR_STRUCT interaction_effect_resurrectst
  static const struct_field_info interaction_effect_resurrectst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_effect_resurrectst::_identity(sizeof(interaction_effect_resurrectst), &allocator_fn<interaction_effect_resurrectst>, "interaction_effect_resurrectst",NULL,&interaction_effect::_identity,interaction_effect_resurrectst_fields);
  #define CUR_STRUCT interaction_instance
  static const struct_field_info interaction_instance_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity interaction_instance::_identity(sizeof(interaction_instance), &allocator_fn<interaction_instance>, NULL, "interaction_instance",NULL,interaction_instance_fields);
  #define CUR_STRUCT interaction_source
  static const struct_field_info interaction_source_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, frequency), TID(int32_t) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, hist_string_1), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, hist_string_2), identity_traits<std::string >::get() },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, parseRaws) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_source::_identity(sizeof(interaction_source), &allocator_fn<interaction_source>, "interaction_source","interaction_sourcest",NULL,interaction_source_fields);
  #define CUR_STRUCT interaction_source_attackst
  static const struct_field_info interaction_source_attackst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_source_attackst::_identity(sizeof(interaction_source_attackst), &allocator_fn<interaction_source_attackst>, "interaction_source_attackst",NULL,&interaction_source::_identity,interaction_source_attackst_fields);
  #define CUR_STRUCT interaction_source_creature_actionst
  static const struct_field_info interaction_source_creature_actionst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_source_creature_actionst::_identity(sizeof(interaction_source_creature_actionst), &allocator_fn<interaction_source_creature_actionst>, "interaction_source_creature_actionst",NULL,&interaction_source::_identity,interaction_source_creature_actionst_fields);
  #define CUR_STRUCT interaction_source_deityst
  static const struct_field_info interaction_source_deityst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(CONTAINER, usage_hint), identity_traits<std::vector<df::interaction_source_usage_hint > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_source_deityst::_identity(sizeof(interaction_source_deityst), &allocator_fn<interaction_source_deityst>, "interaction_source_deityst",NULL,&interaction_source::_identity,interaction_source_deityst_fields);
  #define CUR_STRUCT interaction_source_disturbancest
  static const struct_field_info interaction_source_disturbancest_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_source_disturbancest::_identity(sizeof(interaction_source_disturbancest), &allocator_fn<interaction_source_disturbancest>, "interaction_source_disturbancest",NULL,&interaction_source::_identity,interaction_source_disturbancest_fields);
  #define CUR_STRUCT interaction_source_ingestionst
  static const struct_field_info interaction_source_ingestionst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_source_ingestionst::_identity(sizeof(interaction_source_ingestionst), &allocator_fn<interaction_source_ingestionst>, "interaction_source_ingestionst",NULL,&interaction_source::_identity,interaction_source_ingestionst_fields);
  #define CUR_STRUCT interaction_source_regionst
  static const struct_field_info interaction_source_regionst_fields[] = {
    { FLD(SUBSTRUCT, region_flags), TID(interaction_source_regionst::T_region_flags) },
    { FLD(STATIC_ARRAY, regions), identity_traits<int8_t >::get(), 10, TID(worldgen_region_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_source_regionst::_identity(sizeof(interaction_source_regionst), &allocator_fn<interaction_source_regionst>, "interaction_source_regionst",NULL,&interaction_source::_identity,interaction_source_regionst_fields);
  #define CUR_STRUCT interaction_source_secretst
  static const struct_field_info interaction_source_secretst_fields[] = {
    { FLD(SUBSTRUCT, learn_flags), TID(interaction_source_secretst::T_learn_flags) },
    { FLD(CONTAINER, spheres), identity_traits<std::vector<df::sphere_type > >::get(), 0, NULL },
    { FLD(CONTAINER, goals), identity_traits<std::vector<df::goal_type > >::get(), 0, NULL },
    { FLD(PRIMITIVE, book_title_filename), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, book_name_filename), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_source_secretst::_identity(sizeof(interaction_source_secretst), &allocator_fn<interaction_source_secretst>, "interaction_source_secretst",NULL,&interaction_source::_identity,interaction_source_secretst_fields);
  virtual_identity interaction_source_underground_specialst::_identity(sizeof(interaction_source_underground_specialst), &allocator_fn<interaction_source_underground_specialst>, "interaction_source_underground_specialst",NULL,&interaction_source::_identity,NULL);
  #define CUR_STRUCT interaction_target
  static const struct_field_info interaction_target_fields[] = {
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, manual_input), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, location), TID(interaction_target_location_type) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, parseRaws) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_target::_identity(sizeof(interaction_target), &allocator_fn<interaction_target>, "interaction_target","interaction_targetst",NULL,interaction_target_fields);
  #define CUR_STRUCT interaction_target_corpsest
  static const struct_field_info interaction_target_corpsest_fields[] = {
    { FLD(SUBSTRUCT, anon_1), &interaction_target_info::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_target_corpsest::_identity(sizeof(interaction_target_corpsest), &allocator_fn<interaction_target_corpsest>, "interaction_target_corpsest",NULL,&interaction_target::_identity,interaction_target_corpsest_fields);
  #define CUR_STRUCT interaction_target_creaturest
  static const struct_field_info interaction_target_creaturest_fields[] = {
    { FLD(SUBSTRUCT, anon_1), &interaction_target_info::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_target_creaturest::_identity(sizeof(interaction_target_creaturest), &allocator_fn<interaction_target_creaturest>, "interaction_target_creaturest",NULL,&interaction_target::_identity,interaction_target_creaturest_fields);
  #define CUR_STRUCT interaction_target_info
  static const struct_field_info interaction_target_info_fields[] = {
    { FLD(STATIC_ARRAY, affected_creature_str), identity_traits<std::vector<std::string* > >::get(), 2, NULL },
    { FLD(CONTAINER, affected_creature), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, affected_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, immune_creature_str), identity_traits<std::vector<std::string* > >::get(), 2, NULL },
    { FLD(CONTAINER, immune_creature), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, immune_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, forbidden_syndrome_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, requires_1), TID(int32_t) },
    { FLD(PRIMITIVE, requires_2), TID(int32_t) },
    { FLD(PRIMITIVE, forbidden_1), TID(int32_t) },
    { FLD(PRIMITIVE, forbidden_2), TID(int32_t) },
    { FLD(SUBSTRUCT, restrictions), TID(interaction_target_info::T_restrictions) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity interaction_target_info::_identity(sizeof(interaction_target_info), &allocator_fn<interaction_target_info>, NULL, "interaction_target_info",NULL,interaction_target_info_fields);
  virtual_identity interaction_target_locationst::_identity(sizeof(interaction_target_locationst), &allocator_fn<interaction_target_locationst>, "interaction_target_locationst",NULL,&interaction_target::_identity,NULL);
  #define CUR_STRUCT interaction_target_materialst
  static const struct_field_info interaction_target_materialst_fields[] = {
    { FLD(STATIC_ARRAY, material_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int16_t) },
    { FLD(PRIMITIVE, breath_attack_type), TID(breath_attack_type) },
    { FLD(SUBSTRUCT, restrictions), TID(interaction_target_materialst::T_restrictions) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interaction_target_materialst::_identity(sizeof(interaction_target_materialst), &allocator_fn<interaction_target_materialst>, "interaction_target_materialst",NULL,&interaction_target::_identity,interaction_target_materialst_fields);
  #define CUR_STRUCT interface_button
  static const struct_field_info interface_button_fields[] = {
    { FLD(PRIMITIVE, hotkey_id), TID(interface_key) },
    { FLD(PRIMITIVE, is_hidden), TID(bool) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { METHOD(OBJ_METHOD, printSlabStatus) },
    { METHOD(OBJ_METHOD, getLabel) },
    { METHOD(OBJ_METHOD, click) },
    { METHOD(OBJ_METHOD, setColor) },
    { METHOD(OBJ_METHOD, makeHidden) },
    { METHOD(OBJ_METHOD, getTrackGlyph) },
    { METHOD(OBJ_METHOD, setTrackGlyphColor) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interface_button::_identity(sizeof(interface_button), &allocator_fn<interface_button>, "interface_button","interface_buttonst",NULL,interface_button_fields);
  #define CUR_STRUCT interface_button_building_category_selectorst
  static const struct_field_info interface_button_building_category_selectorst_fields[] = {
    { FLD(PRIMITIVE, category_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interface_button_building_category_selectorst::_identity(sizeof(interface_button_building_category_selectorst), &allocator_fn<interface_button_building_category_selectorst>, "interface_button_building_category_selectorst",NULL,&interface_button_buildingst::_identity,interface_button_building_category_selectorst_fields);
  #define CUR_STRUCT interface_button_building_material_selectorst
  static const struct_field_info interface_button_building_material_selectorst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(SUBSTRUCT, material_category), TID(job_material_category) },
    { FLD(PRIMITIVE, unk_1c), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interface_button_building_material_selectorst::_identity(sizeof(interface_button_building_material_selectorst), &allocator_fn<interface_button_building_material_selectorst>, "interface_button_building_material_selectorst",NULL,&interface_button_buildingst::_identity,interface_button_building_material_selectorst_fields);
  #define CUR_STRUCT interface_button_building_new_jobst
  static const struct_field_info interface_button_building_new_jobst_fields[] = {
    { FLD(PRIMITIVE, job_type), identity_traits<enum_field<df::job_type,int32_t> >::get() },
    { FLD(PRIMITIVE, reaction_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(SUBSTRUCT, item_category), TID(stockpile_group_set) },
    { FLD(PRIMITIVE, hist_figure_id), TID(int32_t) },
    { FLD(SUBSTRUCT, material_category), TID(job_material_category) },
    { FLD(PRIMITIVE, unk_48), TID(bool) },
    { FLD(PRIMITIVE, is_custom), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interface_button_building_new_jobst::_identity(sizeof(interface_button_building_new_jobst), &allocator_fn<interface_button_building_new_jobst>, "interface_button_building_new_jobst",NULL,&interface_button_buildingst::_identity,interface_button_building_new_jobst_fields);
  #define CUR_STRUCT interface_button_buildingst
  static const struct_field_info interface_button_buildingst_fields[] = {
    { FLD(POINTER, building), identity_traits<df::building >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interface_button_buildingst::_identity(sizeof(interface_button_buildingst), &allocator_fn<interface_button_buildingst>, "interface_button_buildingst",NULL,&interface_button::_identity,interface_button_buildingst_fields);
  #define CUR_STRUCT interface_button_construction_building_selectorst
  static const struct_field_info interface_button_construction_building_selectorst_fields[] = {
    { FLD(PRIMITIVE, building_type), TID(int16_t) },
    { FLD(PRIMITIVE, building_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, custom_type), TID(int32_t) },
    { FLD(PRIMITIVE, existing_count), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interface_button_construction_building_selectorst::_identity(sizeof(interface_button_construction_building_selectorst), &allocator_fn<interface_button_construction_building_selectorst>, "interface_button_construction_building_selectorst",NULL,&interface_button_constructionst::_identity,interface_button_construction_building_selectorst_fields);
  #define CUR_STRUCT interface_button_construction_category_selectorst
  static const struct_field_info interface_button_construction_category_selectorst_fields[] = {
    { FLD(PRIMITIVE, category_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interface_button_construction_category_selectorst::_identity(sizeof(interface_button_construction_category_selectorst), &allocator_fn<interface_button_construction_category_selectorst>, "interface_button_construction_category_selectorst",NULL,&interface_button_constructionst::_identity,interface_button_construction_category_selectorst_fields);
  virtual_identity interface_button_construction_donest::_identity(sizeof(interface_button_construction_donest), &allocator_fn<interface_button_construction_donest>, "interface_button_construction_donest",NULL,&interface_button_constructionst::_identity,NULL);
  #define CUR_STRUCT interface_button_constructionst
  static const struct_field_info interface_button_constructionst_fields[] = {
    { FLD(POINTER, unused_c), NULL, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity interface_button_constructionst::_identity(sizeof(interface_button_constructionst), &allocator_fn<interface_button_constructionst>, "interface_button_constructionst",NULL,&interface_button::_identity,interface_button_constructionst_fields);
  typedef int32_t T_interfacest_fields[200];
  #define CUR_STRUCT interfacest
  static const struct_field_info interfacest_fields[] = {
    { FLD(PRIMITIVE, original_fps), TID(int32_t) },
    { FLD(SUBSTRUCT, view), &viewscreen::_identity },
    { FLD(PRIMITIVE, flag), TID(uint32_t) },
    { FLD(PRIMITIVE, shutdown_interface_tickcount), TID(int32_t) },
    { FLD(PRIMITIVE, shutdown_interface_for_ms), TID(int32_t) },
    { FLD(PRIMITIVE, supermovie_on), TID(int8_t) },
    { FLD(PRIMITIVE, supermovie_pos), TID(int32_t) },
    { FLD(PRIMITIVE, supermovie_delayrate), TID(int32_t) },
    { FLD(PRIMITIVE, supermovie_delaystep), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, supermovie_sound), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, supermovie_sound_time), identity_traits<T_interfacest_fields >::get(), 16, NULL },
    { FLD(PRIMITIVE, currentblocksize), TID(int32_t) },
    { FLD(PRIMITIVE, nextfilepos), TID(int32_t) },
    { FLD(PRIMITIVE, first_movie_write), TID(int8_t) },
    { FLD(PRIMITIVE, movie_file), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity interfacest::_identity(sizeof(interfacest), &allocator_fn<interfacest>, NULL, "interfacest",NULL,interfacest_fields);
  #define CUR_STRUCT invasion_info
  static const struct_field_info invasion_info_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, civ_id), TID(int32_t) },
    { FLD(PRIMITIVE, active_size1), TID(int32_t) },
    { FLD(PRIMITIVE, active_size2), TID(int32_t) },
    { FLD(PRIMITIVE, size), TID(int32_t) },
    { FLD(PRIMITIVE, duration_counter), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(invasion_info::T_flags) },
    { FLD(PRIMITIVE, unk4b), TID(int16_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity invasion_info::_identity(sizeof(invasion_info), &allocator_fn<invasion_info>, NULL, "invasion_info",NULL,invasion_info_fields);
  #define CUR_STRUCT item
  static const struct_field_info item_fields[] = {
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(SUBSTRUCT, flags), TID(item_flags) },
    { FLD(SUBSTRUCT, flags2), TID(item_flags2) },
    { FLD(PRIMITIVE, age), TID(uint32_t) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, specific_refs), identity_traits<df::specific_ref >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, general_refs), identity_traits<df::general_ref >::get(), 0, NULL },
    { FLD(PRIMITIVE, world_data_id), TID(int32_t) },
    { FLD(PRIMITIVE, world_data_subid), TID(int32_t) },
    { FLD(PRIMITIVE, stockpile_countdown), TID(uint8_t) },
    { FLD(PRIMITIVE, stockpile_delay), TID(uint8_t) },
    { FLD(PRIMITIVE, unk2), TID(int16_t) },
    { FLD(PRIMITIVE, base_uniform_score), TID(int32_t) },
    { FLD(PRIMITIVE, walkable_id), TID(int16_t) },
    { FLD(PRIMITIVE, spec_heat), TID(uint16_t) },
    { FLD(PRIMITIVE, ignite_point), TID(uint16_t) },
    { FLD(PRIMITIVE, heatdam_point), TID(uint16_t) },
    { FLD(PRIMITIVE, colddam_point), TID(uint16_t) },
    { FLD(PRIMITIVE, boiling_point), TID(uint16_t) },
    { FLD(PRIMITIVE, melting_point), TID(uint16_t) },
    { FLD(PRIMITIVE, fixed_temp), TID(uint16_t) },
    { FLD(PRIMITIVE, weight), TID(int32_t) },
    { FLD(PRIMITIVE, weight_fraction), TID(int32_t) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, getSubtype) },
    { METHOD(OBJ_METHOD, getMaterial) },
    { METHOD(OBJ_METHOD, getMaterialIndex) },
    { METHOD(OBJ_METHOD, setSubtype) },
    { METHOD(OBJ_METHOD, setMaterial) },
    { METHOD(OBJ_METHOD, setMaterialIndex) },
    { METHOD(OBJ_METHOD, getActualMaterial) },
    { METHOD(OBJ_METHOD, getActualMaterialIndex) },
    { METHOD(OBJ_METHOD, getRace) },
    { METHOD(OBJ_METHOD, getCaste) },
    { METHOD(OBJ_METHOD, getPlantID) },
    { METHOD(OBJ_METHOD, getTotalDimension) },
    { METHOD(OBJ_METHOD, setDimension) },
    { METHOD(OBJ_METHOD, subtractDimension) },
    { METHOD(OBJ_METHOD, isFoodStorage) },
    { METHOD(OBJ_METHOD, isTrackCart) },
    { METHOD(OBJ_METHOD, isWheelbarrow) },
    { METHOD(OBJ_METHOD, getVehicleID) },
    { METHOD(OBJ_METHOD, getStockpile) },
    { METHOD(OBJ_METHOD, containsPlaster) },
    { METHOD(OBJ_METHOD, isPlaster) },
    { METHOD(OBJ_METHOD, getColorOverride) },
    { METHOD(OBJ_METHOD, getHistoryInfo) },
    { METHOD(OBJ_METHOD, hasToolUse) },
    { METHOD(OBJ_METHOD, becomePaste) },
    { METHOD(OBJ_METHOD, becomePressed) },
    { METHOD(OBJ_METHOD, calculateWeight) },
    { METHOD(OBJ_METHOD, isSharpStone) },
    { METHOD(OBJ_METHOD, isCrystalGlassable) },
    { METHOD(OBJ_METHOD, isMetalOre) },
    { METHOD(OBJ_METHOD, clearLastTempUpdateTS) },
    { METHOD(OBJ_METHOD, listNotableKills) },
    { METHOD(OBJ_METHOD, getSpecHeat) },
    { METHOD(OBJ_METHOD, getIgnitePoint) },
    { METHOD(OBJ_METHOD, getHeatdamPoint) },
    { METHOD(OBJ_METHOD, getColddamPoint) },
    { METHOD(OBJ_METHOD, getBoilingPoint) },
    { METHOD(OBJ_METHOD, getMeltingPoint) },
    { METHOD(OBJ_METHOD, getFixedTemp) },
    { METHOD(OBJ_METHOD, getSolidDensity) },
    { METHOD(OBJ_METHOD, materialRots) },
    { METHOD(OBJ_METHOD, getTemperature) },
    { METHOD(OBJ_METHOD, adjustTemperature) },
    { METHOD(OBJ_METHOD, extinguish) },
    { METHOD(OBJ_METHOD, getGloveHandedness) },
    { METHOD(OBJ_METHOD, setGloveHandedness) },
    { METHOD(OBJ_METHOD, isSpike) },
    { METHOD(OBJ_METHOD, isScrew) },
    { METHOD(OBJ_METHOD, isBuildMat) },
    { METHOD(OBJ_METHOD, isTemperatureSafe) },
    { METHOD(OBJ_METHOD, setRandSubtype) },
    { METHOD(OBJ_METHOD, getWeaponSize) },
    { METHOD(OBJ_METHOD, getWear) },
    { METHOD(OBJ_METHOD, setWear) },
    { METHOD(OBJ_METHOD, getMaker) },
    { METHOD(OBJ_METHOD, setMaker) },
    { METHOD(OBJ_METHOD, getCorpseInfo) },
    { METHOD(OBJ_METHOD, getGloveFlags) },
    { METHOD(OBJ_METHOD, getItemShapeDesc) },
    { METHOD(OBJ_METHOD, isMatchingAmmoItem) },
    { METHOD(OBJ_METHOD, setSeedsPlantSkillLevel) },
    { METHOD(OBJ_METHOD, getCorpseSize) },
    { METHOD(OBJ_METHOD, ageItem) },
    { METHOD(OBJ_METHOD, getCritterAirdrownTimer) },
    { METHOD(OBJ_METHOD, setCritterAirdrownTimer) },
    { METHOD(OBJ_METHOD, incrementCritterAirdrownTimer) },
    { METHOD(OBJ_METHOD, getRotTimer) },
    { METHOD(OBJ_METHOD, setRotTimer) },
    { METHOD(OBJ_METHOD, incrementRotTimer) },
    { METHOD(OBJ_METHOD, isBogeymanCorpse) },
    { METHOD(OBJ_METHOD, getAmmoType) },
    { METHOD(OBJ_METHOD, isLiquidPowder) },
    { METHOD(OBJ_METHOD, isLiquid) },
    { METHOD(OBJ_METHOD, getVolume) },
    { METHOD(OBJ_METHOD, addImprovementFromJob) },
    { METHOD(OBJ_METHOD, isWeapon) },
    { METHOD(OBJ_METHOD, isArmorNotClothing) },
    { METHOD(OBJ_METHOD, isMillable) },
    { METHOD(OBJ_METHOD, isProcessableThread) },
    { METHOD(OBJ_METHOD, isProcessableVial) },
    { METHOD(OBJ_METHOD, isProcessableBarrel) },
    { METHOD(OBJ_METHOD, isEdiblePlant) },
    { METHOD(OBJ_METHOD, isEdibleRaw) },
    { METHOD(OBJ_METHOD, isEdibleCarnivore) },
    { METHOD(OBJ_METHOD, isEdibleBonecarn) },
    { METHOD(OBJ_METHOD, moveToGround) },
    { METHOD(OBJ_METHOD, categorize) },
    { METHOD(OBJ_METHOD, uncategorize) },
    { METHOD(OBJ_METHOD, isFurniture) },
    { METHOD(OBJ_METHOD, isPressed) },
    { METHOD(OBJ_METHOD, isAnimal) },
    { METHOD(OBJ_METHOD, assignQuality) },
    { METHOD(OBJ_METHOD, notifyLostMasterwork) },
    { METHOD(OBJ_METHOD, addMagic) },
    { METHOD(OBJ_METHOD, magic_unk1) },
    { METHOD(OBJ_METHOD, magic_unk2) },
    { METHOD(OBJ_METHOD, magic_unk3) },
    { METHOD(OBJ_METHOD, magic_unk4) },
    { METHOD(OBJ_METHOD, setDisplayColor) },
    { METHOD(OBJ_METHOD, isDamagedByHeat) },
    { METHOD(OBJ_METHOD, needTwoHandedWield) },
    { METHOD(OBJ_METHOD, splitStack) },
    { METHOD(OBJ_METHOD, isTameableVermin) },
    { METHOD(OBJ_METHOD, isDye) },
    { METHOD(OBJ_METHOD, isMilkable) },
    { METHOD(OBJ_METHOD, isSandBearing) },
    { METHOD(OBJ_METHOD, isLyeBearing) },
    { METHOD(OBJ_METHOD, isAnimalProduct) },
    { METHOD(OBJ_METHOD, getStorageInfo) },
    { METHOD(OBJ_METHOD, addWear) },
    { METHOD(OBJ_METHOD, incWearTimer) },
    { METHOD(OBJ_METHOD, checkWearDestroy) },
    { METHOD(OBJ_METHOD, addContaminant) },
    { METHOD(OBJ_METHOD, removeContaminantByIdx) },
    { METHOD(OBJ_METHOD, removeContaminant) },
    { METHOD(OBJ_METHOD, tradeUnitContaminants) },
    { METHOD(OBJ_METHOD, tradeItemContaminants) },
    { METHOD(OBJ_METHOD, tradeItemContaminants2) },
    { METHOD(OBJ_METHOD, contaminateWound) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, getWeaponAttacks) },
    { METHOD(OBJ_METHOD, isSplittable) },
    { METHOD(OBJ_METHOD, propagateUnitRefs) },
    { METHOD(OBJ_METHOD, isBag) },
    { METHOD(OBJ_METHOD, isSand) },
    { METHOD(OBJ_METHOD, getStackSize) },
    { METHOD(OBJ_METHOD, addStackSize) },
    { METHOD(OBJ_METHOD, setStackSize) },
    { METHOD(OBJ_METHOD, isAmmoClass) },
    { METHOD(OBJ_METHOD, isAutoClean) },
    { METHOD(OBJ_METHOD, setTemperatureFromMapTile) },
    { METHOD(OBJ_METHOD, setTemperatureFromMap) },
    { METHOD(OBJ_METHOD, setTemperature) },
    { METHOD(OBJ_METHOD, updateTempFromMap) },
    { METHOD(OBJ_METHOD, updateTemperature) },
    { METHOD(OBJ_METHOD, updateFromWeather) },
    { METHOD(OBJ_METHOD, updateContaminants) },
    { METHOD(OBJ_METHOD, checkTemperatureDamage) },
    { METHOD(OBJ_METHOD, checkHeatColdDamage) },
    { METHOD(OBJ_METHOD, checkMeltBoil) },
    { METHOD(OBJ_METHOD, getMeleeSkill) },
    { METHOD(OBJ_METHOD, getRangedSkill) },
    { METHOD(OBJ_METHOD, setQuality) },
    { METHOD(OBJ_METHOD, getQuality) },
    { METHOD(OBJ_METHOD, getOverallQuality) },
    { METHOD(OBJ_METHOD, getImprovementQuality) },
    { METHOD(OBJ_METHOD, getProjectileSize) },
    { METHOD(OBJ_METHOD, isImprovable) },
    { METHOD(OBJ_METHOD, setSharpness) },
    { METHOD(OBJ_METHOD, getSharpness) },
    { METHOD(OBJ_METHOD, isTotemable) },
    { METHOD(OBJ_METHOD, isDyeable) },
    { METHOD(OBJ_METHOD, isNotDyed) },
    { METHOD(OBJ_METHOD, isDyed) },
    { METHOD(OBJ_METHOD, canSewImage) },
    { METHOD(OBJ_METHOD, isProcessableVialAtStill) },
    { METHOD(OBJ_METHOD, isSimilarToItem) },
    { METHOD(OBJ_METHOD, getBlockChance) },
    { METHOD(OBJ_METHOD, getMakerRace) },
    { METHOD(OBJ_METHOD, setMakerRace) },
    { METHOD(OBJ_METHOD, getEffectiveArmorLevel) },
    { METHOD(OBJ_METHOD, isItemOrganicCloth) },
    { METHOD(OBJ_METHOD, isMadeOfOrganicCloth) },
    { METHOD(OBJ_METHOD, coverWithContaminant) },
    { METHOD(OBJ_METHOD, hasImprovements) },
    { METHOD(OBJ_METHOD, isImproved) },
    { METHOD(OBJ_METHOD, getMagic) },
    { METHOD(OBJ_METHOD, getItemDescription) },
    { METHOD(OBJ_METHOD, getItemDescriptionPrefix) },
    { METHOD(OBJ_METHOD, getItemBasicName) },
    { METHOD(OBJ_METHOD, getImprovementsValue) },
    { METHOD(OBJ_METHOD, isExtractBearingFish) },
    { METHOD(OBJ_METHOD, isExtractBearingVermin) },
    { METHOD(OBJ_METHOD, getBaseWeight) },
    { METHOD(OBJ_METHOD, getWeightShiftBits) },
    { METHOD(OBJ_METHOD, isCollected) },
    { METHOD(OBJ_METHOD, isEdibleVermin) },
    { METHOD(OBJ_METHOD, drawSelf) },
    { METHOD(OBJ_METHOD, isRangedWeapon) },
    { METHOD(OBJ_METHOD, isClothing) },
    { METHOD(OBJ_METHOD, isWet) },
    { METHOD(OBJ_METHOD, getCurrencyValue) },
    { METHOD(OBJ_METHOD, isAssignedToStockpile) },
    { METHOD(OBJ_METHOD, isAssignedToThisStockpile) },
    { METHOD(OBJ_METHOD, detachStockpileAssignment) },
    { METHOD(OBJ_METHOD, removeStockpileAssignment) },
    { METHOD(OBJ_METHOD, getStockpile2) },
    { METHOD(OBJ_METHOD, getThreadDyeValue) },
    { METHOD(OBJ_METHOD, getColorAndShape) },
    { METHOD(OBJ_METHOD, isArmor) },
    { METHOD(OBJ_METHOD, calcUniformScore) },
    { METHOD(OBJ_METHOD, calcBaseUniformScore) },
    { METHOD(OBJ_METHOD, getSlabEngravingType) },
    { METHOD(OBJ_METHOD, getAbsorption) },
    { METHOD(OBJ_METHOD, isGemMaterial) },
    { METHOD(OBJ_METHOD, setGemShape) },
    { METHOD(OBJ_METHOD, hasGemShape) },
    { METHOD(OBJ_METHOD, getGemShape) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item::_identity(sizeof(item), &allocator_fn<item>, "item","itemst",NULL,item_fields);
  #define CUR_STRUCT item_actual
  static const struct_field_info item_actual_fields[] = {
    { FLD(PRIMITIVE, stack_size), TID(int32_t) },
    { FLD(POINTER, history_info), identity_traits<df::item_history_info* >::get(), 0, NULL },
    { FLD(POINTER, magic), identity_traits<std::vector<df::item_magicness* > >::get(), 0, NULL },
    { FLD(POINTER, contaminants), identity_traits<std::vector<df::spatter* > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, temperature), &temperaturest::_identity },
    { FLD(PRIMITIVE, wear), TID(int16_t) },
    { FLD(PRIMITIVE, wear_timer), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, temp_updated_frame), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_actual::_identity(sizeof(item_actual), &allocator_fn<item_actual>, "item_actual","item_actualst",&item::_identity,item_actual_fields);
  #define CUR_STRUCT item_ammost
  static const struct_field_info item_ammost_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_ammost >::get(), 0, NULL },
    { FLD(PRIMITIVE, sharpness), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_ammost::_identity(sizeof(item_ammost), &allocator_fn<item_ammost>, "item_ammost",NULL,&item_constructed::_identity,item_ammost_fields);
  virtual_identity item_amuletst::_identity(sizeof(item_amuletst), &allocator_fn<item_amuletst>, "item_amuletst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_animaltrapst::_identity(sizeof(item_animaltrapst), &allocator_fn<item_animaltrapst>, "item_animaltrapst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_anvilst::_identity(sizeof(item_anvilst), &allocator_fn<item_anvilst>, "item_anvilst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_armorst
  static const struct_field_info item_armorst_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_armorst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_armorst::_identity(sizeof(item_armorst), &allocator_fn<item_armorst>, "item_armorst",NULL,&item_constructed::_identity,item_armorst_fields);
  virtual_identity item_armorstandst::_identity(sizeof(item_armorstandst), &allocator_fn<item_armorstandst>, "item_armorstandst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_backpackst::_identity(sizeof(item_backpackst), &allocator_fn<item_backpackst>, "item_backpackst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_ballistaarrowheadst
  static const struct_field_info item_ballistaarrowheadst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, sharpness), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_ballistaarrowheadst::_identity(sizeof(item_ballistaarrowheadst), &allocator_fn<item_ballistaarrowheadst>, "item_ballistaarrowheadst",NULL,&item_actual::_identity,item_ballistaarrowheadst_fields);
  virtual_identity item_ballistapartsst::_identity(sizeof(item_ballistapartsst), &allocator_fn<item_ballistapartsst>, "item_ballistapartsst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_barrelst
  static const struct_field_info item_barrelst_fields[] = {
    { FLD(SUBSTRUCT, stockpile), &item_stockpile_ref::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_barrelst::_identity(sizeof(item_barrelst), &allocator_fn<item_barrelst>, "item_barrelst",NULL,&item_constructed::_identity,item_barrelst_fields);
  #define CUR_STRUCT item_barst
  static const struct_field_info item_barst_fields[] = {
    { FLD(PRIMITIVE, subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, dimension), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_barst::_identity(sizeof(item_barst), &allocator_fn<item_barst>, "item_barst",NULL,&item_actual::_identity,item_barst_fields);
  virtual_identity item_bedst::_identity(sizeof(item_bedst), &allocator_fn<item_bedst>, "item_bedst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_binst
  static const struct_field_info item_binst_fields[] = {
    { FLD(SUBSTRUCT, stockpile), &item_stockpile_ref::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_binst::_identity(sizeof(item_binst), &allocator_fn<item_binst>, "item_binst",NULL,&item_constructed::_identity,item_binst_fields);
  #define CUR_STRUCT item_blocksst
  static const struct_field_info item_blocksst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_blocksst::_identity(sizeof(item_blocksst), &allocator_fn<item_blocksst>, "item_blocksst",NULL,&item_actual::_identity,item_blocksst_fields);
  #define CUR_STRUCT item_body_component::T_body
  static const struct_field_info item_body_component_doT_Dot_T_body_fields[] = {
    { FLD(STL_VECTOR_PTR, wounds), identity_traits<df::unit_wound >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, unk_100), identity_traits<int32_t >::get(), 10, NULL },
    { FLD(PRIMITIVE, unk_c8), TID(int32_t) },
    { FLD(SUBSTRUCT, components), &body_component_info::_identity },
    { FLD(STATIC_ARRAY, physical_attr_value), identity_traits<int32_t >::get(), 6, TID(physical_attribute_type) },
    { FLD(STATIC_ARRAY, physical_attr_unk2), identity_traits<int32_t >::get(), 6, TID(physical_attribute_type) },
    { FLD(SUBSTRUCT, size_info), &body_size_info::_identity },
    { FLD(CONTAINER, body_part_relsize), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, body_modifiers), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_modifiers), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, size_modifier), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity item_body_component::T_body::_identity(sizeof(item_body_component::T_body), &allocator_fn<item_body_component::T_body>, &item_body_component::_identity, "T_body",NULL,item_body_component_doT_Dot_T_body_fields);
  #define CUR_STRUCT item_body_component::T_appearance
  static const struct_field_info item_body_component_doT_Dot_T_appearance_fields[] = {
    { FLD(CONTAINER, colors), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_1e8), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_1f8), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_208), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_218), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity item_body_component::T_appearance::_identity(sizeof(item_body_component::T_appearance), &allocator_fn<item_body_component::T_appearance>, &item_body_component::_identity, "T_appearance",NULL,item_body_component_doT_Dot_T_appearance_fields);
  #define CUR_STRUCT item_body_component::T_bone1
  static const struct_field_info item_body_component_doT_Dot_T_bone1_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity item_body_component::T_bone1::_identity(sizeof(item_body_component::T_bone1), &allocator_fn<item_body_component::T_bone1>, &item_body_component::_identity, "T_bone1",NULL,item_body_component_doT_Dot_T_bone1_fields);
  #define CUR_STRUCT item_body_component::T_bone2
  static const struct_field_info item_body_component_doT_Dot_T_bone2_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity item_body_component::T_bone2::_identity(sizeof(item_body_component::T_bone2), &allocator_fn<item_body_component::T_bone2>, &item_body_component::_identity, "T_bone2",NULL,item_body_component_doT_Dot_T_bone2_fields);
  #define CUR_STRUCT item_body_component
  static const struct_field_info item_body_component_fields[] = {
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(PRIMITIVE, hist_figure_id), TID(int32_t) },
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(PRIMITIVE, sex), TID(int8_t) },
    { FLD(PRIMITIVE, race2), TID(int16_t) },
    { FLD(PRIMITIVE, caste2), TID(int16_t) },
    { FLD(PRIMITIVE, rot_timer), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8c), TID(int8_t) },
    { FLD(SUBSTRUCT, body), &item_body_component::T_body::_identity },
    { FLD(PRIMITIVE, birth_year), TID(int32_t) },
    { FLD(PRIMITIVE, birth_time), TID(int32_t) },
    { FLD(PRIMITIVE, curse_year), TID(int32_t) },
    { FLD(PRIMITIVE, curse_time), TID(int32_t) },
    { FLD(PRIMITIVE, birth_year_bias), TID(int32_t) },
    { FLD(PRIMITIVE, birth_time_bias), TID(int32_t) },
    { FLD(PRIMITIVE, death_year), TID(int32_t) },
    { FLD(PRIMITIVE, death_time), TID(int32_t) },
    { FLD(SUBSTRUCT, appearance), &item_body_component::T_appearance::_identity },
    { FLD(PRIMITIVE, blood_count), TID(int32_t) },
    { FLD(PRIMITIVE, stored_fat), TID(int32_t) },
    { FLD(PRIMITIVE, hist_figure_id2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, unit_id2), TID(int32_t) },
    { FLD(SUBSTRUCT, corpse_flags), TID(item_body_component::T_corpse_flags) },
    { FLD(STATIC_ARRAY, material_amount), identity_traits<int32_t >::get(), 19, TID(corpse_material_type) },
    { FLD(SUBSTRUCT, bone1), &item_body_component::T_bone1::_identity },
    { FLD(SUBSTRUCT, bone2), &item_body_component::T_bone2::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_body_component::_identity(sizeof(item_body_component), &allocator_fn<item_body_component>, "item_body_component","item_body_componentst",&item_actual::_identity,item_body_component_fields);
  #define CUR_STRUCT item_bookst
  static const struct_field_info item_bookst_fields[] = {
    { FLD(PRIMITIVE, title), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_bookst::_identity(sizeof(item_bookst), &allocator_fn<item_bookst>, "item_bookst",NULL,&item_constructed::_identity,item_bookst_fields);
  #define CUR_STRUCT item_boulderst
  static const struct_field_info item_boulderst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_boulderst::_identity(sizeof(item_boulderst), &allocator_fn<item_boulderst>, "item_boulderst",NULL,&item_actual::_identity,item_boulderst_fields);
  virtual_identity item_boxst::_identity(sizeof(item_boxst), &allocator_fn<item_boxst>, "item_boxst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_braceletst::_identity(sizeof(item_braceletst), &allocator_fn<item_braceletst>, "item_braceletst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_bucketst::_identity(sizeof(item_bucketst), &allocator_fn<item_bucketst>, "item_bucketst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_cabinetst::_identity(sizeof(item_cabinetst), &allocator_fn<item_cabinetst>, "item_cabinetst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_cagest::_identity(sizeof(item_cagest), &allocator_fn<item_cagest>, "item_cagest",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_catapultpartsst::_identity(sizeof(item_catapultpartsst), &allocator_fn<item_catapultpartsst>, "item_catapultpartsst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_chainst::_identity(sizeof(item_chainst), &allocator_fn<item_chainst>, "item_chainst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_chairst::_identity(sizeof(item_chairst), &allocator_fn<item_chairst>, "item_chairst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_cheesest
  static const struct_field_info item_cheesest_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, rot_timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_cheesest::_identity(sizeof(item_cheesest), &allocator_fn<item_cheesest>, "item_cheesest",NULL,&item_actual::_identity,item_cheesest_fields);
  #define CUR_STRUCT item_clothst
  static const struct_field_info item_clothst_fields[] = {
    { FLD(PRIMITIVE, dimension), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_clothst::_identity(sizeof(item_clothst), &allocator_fn<item_clothst>, "item_clothst",NULL,&item_constructed::_identity,item_clothst_fields);
  virtual_identity item_coffinst::_identity(sizeof(item_coffinst), &allocator_fn<item_coffinst>, "item_coffinst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_coinst
  static const struct_field_info item_coinst_fields[] = {
    { FLD(PRIMITIVE, coin_batch), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_coinst::_identity(sizeof(item_coinst), &allocator_fn<item_coinst>, "item_coinst",NULL,&item_constructed::_identity,item_coinst_fields);
  #define CUR_STRUCT item_constructed
  static const struct_field_info item_constructed_fields[] = {
    { FLD(STL_VECTOR_PTR, improvements), identity_traits<df::itemimprovement >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_constructed::_identity(sizeof(item_constructed), &allocator_fn<item_constructed>, "item_constructed","item_constructedst",&item_crafted::_identity,item_constructed_fields);
  virtual_identity item_corpsepiecest::_identity(sizeof(item_corpsepiecest), &allocator_fn<item_corpsepiecest>, "item_corpsepiecest",NULL,&item_body_component::_identity,NULL);
  virtual_identity item_corpsest::_identity(sizeof(item_corpsest), &allocator_fn<item_corpsest>, "item_corpsest",NULL,&item_body_component::_identity,NULL);
  #define CUR_STRUCT item_crafted
  static const struct_field_info item_crafted_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, maker_race), TID(int16_t) },
    { FLD(PRIMITIVE, quality), TID(item_quality) },
    { FLD(PRIMITIVE, skill_used), identity_traits<enum_field<df::job_skill,int32_t> >::get() },
    { FLD(PRIMITIVE, maker), TID(int32_t) },
    { FLD(PRIMITIVE, masterpiece_event), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_crafted::_identity(sizeof(item_crafted), &allocator_fn<item_crafted>, "item_crafted","item_craftedst",&item_actual::_identity,item_crafted_fields);
  #define CUR_STRUCT item_critter
  static const struct_field_info item_critter_fields[] = {
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(PRIMITIVE, milk_timer), TID(int32_t) },
    { FLD(PRIMITIVE, airdrown_timer), TID(int32_t) },
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_critter::_identity(sizeof(item_critter), &allocator_fn<item_critter>, "item_critter","item_critterst",&item_actual::_identity,item_critter_fields);
  virtual_identity item_crownst::_identity(sizeof(item_crownst), &allocator_fn<item_crownst>, "item_crownst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_crutchst::_identity(sizeof(item_crutchst), &allocator_fn<item_crutchst>, "item_crutchst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_doorst::_identity(sizeof(item_doorst), &allocator_fn<item_doorst>, "item_doorst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_drinkst::_identity(sizeof(item_drinkst), &allocator_fn<item_drinkst>, "item_drinkst",NULL,&item_liquid::_identity,NULL);
  virtual_identity item_earringst::_identity(sizeof(item_earringst), &allocator_fn<item_earringst>, "item_earringst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_eggst
  static const struct_field_info item_eggst_fields[] = {
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(PRIMITIVE, unk_7c), TID(int32_t) },
    { FLD(SUBSTRUCT, egg_materials), &material_vec_ref::_identity },
    { FLD(SUBSTRUCT, egg_flags), TID(item_eggst::T_egg_flags) },
    { FLD(PRIMITIVE, incubation_counter), TID(int32_t) },
    { FLD(PRIMITIVE, hatchling_civ_id), TID(int32_t) },
    { FLD(PRIMITIVE, hatchling_population_id), TID(int32_t) },
    { FLD(PRIMITIVE, hatchling_unit_unk_c0), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(POINTER, mothers_genes), identity_traits<df::unit_genes >::get(), 0, NULL },
    { FLD(PRIMITIVE, mothers_caste), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(POINTER, fathers_genes), identity_traits<df::unit_genes >::get(), 0, NULL },
    { FLD(PRIMITIVE, fathers_caste), TID(int16_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(SUBSTRUCT, hatchling_flags1), TID(unit_flags1) },
    { FLD(SUBSTRUCT, hatchling_flags2), TID(unit_flags2) },
    { FLD(SUBSTRUCT, hatchling_flags3), TID(unit_flags3) },
    { FLD(PRIMITIVE, hatchling_training_level), TID(animal_training_level) },
    { FLD(SUBSTRUCT, hatchling_animal_population), &world_population_ref::_identity },
    { FLD(PRIMITIVE, hatchling_mother_id), TID(int32_t) },
    { FLD(PRIMITIVE, size), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_eggst::_identity(sizeof(item_eggst), &allocator_fn<item_eggst>, "item_eggst",NULL,&item_actual::_identity,item_eggst_fields);
  #define CUR_STRUCT item_figurinest
  static const struct_field_info item_figurinest_fields[] = {
    { FLD(SUBSTRUCT, image), &art_image_ref::_identity },
    { FLD(PRIMITIVE, description), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_figurinest::_identity(sizeof(item_figurinest), &allocator_fn<item_figurinest>, "item_figurinest",NULL,&item_constructed::_identity,item_figurinest_fields);
  #define CUR_STRUCT item_filter_spec
  static const struct_field_info item_filter_spec_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, material_class), TID(entity_material_category) },
    { FLD(PRIMITIVE, mattype), TID(int16_t) },
    { FLD(PRIMITIVE, matindex), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity item_filter_spec::_identity(sizeof(item_filter_spec), &allocator_fn<item_filter_spec>, NULL, "item_filter_spec",NULL,item_filter_spec_fields);
  #define CUR_STRUCT item_fish_rawst
  static const struct_field_info item_fish_rawst_fields[] = {
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(PRIMITIVE, rot_timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_fish_rawst::_identity(sizeof(item_fish_rawst), &allocator_fn<item_fish_rawst>, "item_fish_rawst",NULL,&item_actual::_identity,item_fish_rawst_fields);
  #define CUR_STRUCT item_fishst
  static const struct_field_info item_fishst_fields[] = {
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(PRIMITIVE, rot_timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_fishst::_identity(sizeof(item_fishst), &allocator_fn<item_fishst>, "item_fishst",NULL,&item_actual::_identity,item_fishst_fields);
  virtual_identity item_flaskst::_identity(sizeof(item_flaskst), &allocator_fn<item_flaskst>, "item_flaskst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_floodgatest::_identity(sizeof(item_floodgatest), &allocator_fn<item_floodgatest>, "item_floodgatest",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_foodst::T_ingredients
  static const struct_field_info item_foodst_doT_Dot_T_ingredients_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, unk_4), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, maker), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int16_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity item_foodst::T_ingredients::_identity(sizeof(item_foodst::T_ingredients), &allocator_fn<item_foodst::T_ingredients>, &item_foodst::_identity, "T_ingredients",NULL,item_foodst_doT_Dot_T_ingredients_fields);
  #define CUR_STRUCT item_foodst
  static const struct_field_info item_foodst_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_foodst >::get(), 0, NULL },
    { FLD(PRIMITIVE, entity), TID(int32_t) },
    { FLD(PRIMITIVE, recipe_id), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, ingredients), &item_foodst::T_ingredients::_identity, 0, NULL },
    { FLD(PRIMITIVE, rot_timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_foodst::_identity(sizeof(item_foodst), &allocator_fn<item_foodst>, "item_foodst",NULL,&item_crafted::_identity,item_foodst_fields);
  #define CUR_STRUCT item_gemst
  static const struct_field_info item_gemst_fields[] = {
    { FLD(PRIMITIVE, shape), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_gemst::_identity(sizeof(item_gemst), &allocator_fn<item_gemst>, "item_gemst",NULL,&item_constructed::_identity,item_gemst_fields);
  #define CUR_STRUCT item_globst
  static const struct_field_info item_globst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, rot_timer), TID(int32_t) },
    { FLD(SUBSTRUCT, mat_state), TID(item_matstate) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_globst::_identity(sizeof(item_globst), &allocator_fn<item_globst>, "item_globst",NULL,&item_actual::_identity,item_globst_fields);
  #define CUR_STRUCT item_glovesst
  static const struct_field_info item_glovesst_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_glovesst >::get(), 0, NULL },
    { FLD(CONTAINER, handedness), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_glovesst::_identity(sizeof(item_glovesst), &allocator_fn<item_glovesst>, "item_glovesst",NULL,&item_constructed::_identity,item_glovesst_fields);
  virtual_identity item_gobletst::_identity(sizeof(item_gobletst), &allocator_fn<item_gobletst>, "item_gobletst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_gratest::_identity(sizeof(item_gratest), &allocator_fn<item_gratest>, "item_gratest",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_hatch_coverst::_identity(sizeof(item_hatch_coverst), &allocator_fn<item_hatch_coverst>, "item_hatch_coverst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_helmst
  static const struct_field_info item_helmst_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_helmst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_helmst::_identity(sizeof(item_helmst), &allocator_fn<item_helmst>, "item_helmst",NULL,&item_constructed::_identity,item_helmst_fields);
  #define CUR_STRUCT item_history_info
  static const struct_field_info item_history_info_fields[] = {
    { FLD(POINTER, kills), identity_traits<df::item_kill_info >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD(PRIMITIVE, unk2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity item_history_info::_identity(sizeof(item_history_info), &allocator_fn<item_history_info>, NULL, "item_history_info",NULL,item_history_info_fields);
  #define CUR_STRUCT item_instrumentst
  static const struct_field_info item_instrumentst_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_instrumentst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_instrumentst::_identity(sizeof(item_instrumentst), &allocator_fn<item_instrumentst>, "item_instrumentst",NULL,&item_constructed::_identity,item_instrumentst_fields);
  #define CUR_STRUCT item_kill_info
  static const struct_field_info item_kill_info_fields[] = {
    { FLD(SUBSTRUCT, targets), &historical_kills::_identity },
    { FLD(CONTAINER, slayers), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, slayer_kill_counts), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity item_kill_info::_identity(sizeof(item_kill_info), &allocator_fn<item_kill_info>, NULL, "item_kill_info",NULL,item_kill_info_fields);
  virtual_identity item_liquid::_identity(sizeof(item_liquid), &allocator_fn<item_liquid>, "item_liquid","item_liquidst",&item_liquipowder::_identity,NULL);
  #define CUR_STRUCT item_liquid_miscst
  static const struct_field_info item_liquid_miscst_fields[] = {
    { FLD(PRIMITIVE, unk_88), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_liquid_miscst::_identity(sizeof(item_liquid_miscst), &allocator_fn<item_liquid_miscst>, "item_liquid_miscst",NULL,&item_liquid::_identity,item_liquid_miscst_fields);
  #define CUR_STRUCT item_liquipowder
  static const struct_field_info item_liquipowder_fields[] = {
    { FLD(SUBSTRUCT, mat_state), TID(item_matstate) },
    { FLD(PRIMITIVE, dimension), TID(int32_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_liquipowder::_identity(sizeof(item_liquipowder), &allocator_fn<item_liquipowder>, "item_liquipowder","item_liquipowderst",&item_actual::_identity,item_liquipowder_fields);
  #define CUR_STRUCT item_magicness
  static const struct_field_info item_magicness_fields[] = {
    { FLD(PRIMITIVE, type), TID(item_magicness_type) },
    { FLD(PRIMITIVE, value), TID(int16_t) },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, flags), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity item_magicness::_identity(sizeof(item_magicness), &allocator_fn<item_magicness>, NULL, "item_magicness",NULL,item_magicness_fields);
  #define CUR_STRUCT item_meatst
  static const struct_field_info item_meatst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, rot_timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_meatst::_identity(sizeof(item_meatst), &allocator_fn<item_meatst>, "item_meatst",NULL,&item_actual::_identity,item_meatst_fields);
  virtual_identity item_millstonest::_identity(sizeof(item_millstonest), &allocator_fn<item_millstonest>, "item_millstonest",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_orthopedic_castst
  static const struct_field_info item_orthopedic_castst_fields[] = {
    { FLD(PRIMITIVE, body_part), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, material), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_orthopedic_castst::_identity(sizeof(item_orthopedic_castst), &allocator_fn<item_orthopedic_castst>, "item_orthopedic_castst",NULL,&item_constructed::_identity,item_orthopedic_castst_fields);
  #define CUR_STRUCT item_pantsst
  static const struct_field_info item_pantsst_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_pantsst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_pantsst::_identity(sizeof(item_pantsst), &allocator_fn<item_pantsst>, "item_pantsst",NULL,&item_constructed::_identity,item_pantsst_fields);
  #define CUR_STRUCT item_petst
  static const struct_field_info item_petst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_petst::_identity(sizeof(item_petst), &allocator_fn<item_petst>, "item_petst",NULL,&item_critter::_identity,item_petst_fields);
  virtual_identity item_pipe_sectionst::_identity(sizeof(item_pipe_sectionst), &allocator_fn<item_pipe_sectionst>, "item_pipe_sectionst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_plant_growthst
  static const struct_field_info item_plant_growthst_fields[] = {
    { FLD(PRIMITIVE, subtype), TID(int16_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, rot_timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_plant_growthst::_identity(sizeof(item_plant_growthst), &allocator_fn<item_plant_growthst>, "item_plant_growthst",NULL,&item_actual::_identity,item_plant_growthst_fields);
  #define CUR_STRUCT item_plantst
  static const struct_field_info item_plantst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, rot_timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_plantst::_identity(sizeof(item_plantst), &allocator_fn<item_plantst>, "item_plantst",NULL,&item_actual::_identity,item_plantst_fields);
  virtual_identity item_powder::_identity(sizeof(item_powder), &allocator_fn<item_powder>, "item_powder","item_powderst",&item_liquipowder::_identity,NULL);
  virtual_identity item_powder_miscst::_identity(sizeof(item_powder_miscst), &allocator_fn<item_powder_miscst>, "item_powder_miscst",NULL,&item_powder::_identity,NULL);
  virtual_identity item_quernst::_identity(sizeof(item_quernst), &allocator_fn<item_quernst>, "item_quernst",NULL,&item_constructed::_identity,NULL);
  virtual_identity item_quiverst::_identity(sizeof(item_quiverst), &allocator_fn<item_quiverst>, "item_quiverst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_remainsst
  static const struct_field_info item_remainsst_fields[] = {
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(PRIMITIVE, rot_timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_remainsst::_identity(sizeof(item_remainsst), &allocator_fn<item_remainsst>, "item_remainsst",NULL,&item_actual::_identity,item_remainsst_fields);
  virtual_identity item_ringst::_identity(sizeof(item_ringst), &allocator_fn<item_ringst>, "item_ringst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_rockst
  static const struct_field_info item_rockst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, sharpness), TID(int32_t) },
    { FLD(PRIMITIVE, unk_84), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_rockst::_identity(sizeof(item_rockst), &allocator_fn<item_rockst>, "item_rockst",NULL,&item_actual::_identity,item_rockst_fields);
  #define CUR_STRUCT item_roughst
  static const struct_field_info item_roughst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_roughst::_identity(sizeof(item_roughst), &allocator_fn<item_roughst>, "item_roughst",NULL,&item_actual::_identity,item_roughst_fields);
  virtual_identity item_scepterst::_identity(sizeof(item_scepterst), &allocator_fn<item_scepterst>, "item_scepterst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_seedsst
  static const struct_field_info item_seedsst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, grow_counter), TID(int32_t) },
    { FLD(PRIMITIVE, planting_skill), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_seedsst::_identity(sizeof(item_seedsst), &allocator_fn<item_seedsst>, "item_seedsst",NULL,&item_actual::_identity,item_seedsst_fields);
  #define CUR_STRUCT item_shieldst
  static const struct_field_info item_shieldst_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_shieldst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_shieldst::_identity(sizeof(item_shieldst), &allocator_fn<item_shieldst>, "item_shieldst",NULL,&item_constructed::_identity,item_shieldst_fields);
  #define CUR_STRUCT item_shoesst
  static const struct_field_info item_shoesst_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_shoesst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_shoesst::_identity(sizeof(item_shoesst), &allocator_fn<item_shoesst>, "item_shoesst",NULL,&item_constructed::_identity,item_shoesst_fields);
  #define CUR_STRUCT item_siegeammost
  static const struct_field_info item_siegeammost_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_siegeammost >::get(), 0, NULL },
    { FLD(PRIMITIVE, sharpness), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_siegeammost::_identity(sizeof(item_siegeammost), &allocator_fn<item_siegeammost>, "item_siegeammost",NULL,&item_constructed::_identity,item_siegeammost_fields);
  #define CUR_STRUCT item_skin_tannedst
  static const struct_field_info item_skin_tannedst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, unk_80), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_skin_tannedst::_identity(sizeof(item_skin_tannedst), &allocator_fn<item_skin_tannedst>, "item_skin_tannedst",NULL,&item_actual::_identity,item_skin_tannedst_fields);
  #define CUR_STRUCT item_slabst
  static const struct_field_info item_slabst_fields[] = {
    { FLD(PRIMITIVE, description), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, topic), TID(int32_t) },
    { FLD(PRIMITIVE, engraving_type), TID(slab_engraving_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_slabst::_identity(sizeof(item_slabst), &allocator_fn<item_slabst>, "item_slabst",NULL,&item_constructed::_identity,item_slabst_fields);
  #define CUR_STRUCT item_smallgemst
  static const struct_field_info item_smallgemst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, shape), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_smallgemst::_identity(sizeof(item_smallgemst), &allocator_fn<item_smallgemst>, "item_smallgemst",NULL,&item_actual::_identity,item_smallgemst_fields);
  virtual_identity item_splintst::_identity(sizeof(item_splintst), &allocator_fn<item_splintst>, "item_splintst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_statuest
  static const struct_field_info item_statuest_fields[] = {
    { FLD(SUBSTRUCT, image), &art_image_ref::_identity },
    { FLD(PRIMITIVE, description), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_statuest::_identity(sizeof(item_statuest), &allocator_fn<item_statuest>, "item_statuest",NULL,&item_constructed::_identity,item_statuest_fields);
  #define CUR_STRUCT item_stockpile_ref
  static const struct_field_info item_stockpile_ref_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, x), TID(int16_t) },
    { FLD(PRIMITIVE, y), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity item_stockpile_ref::_identity(sizeof(item_stockpile_ref), &allocator_fn<item_stockpile_ref>, NULL, "item_stockpile_ref",NULL,item_stockpile_ref_fields);
  virtual_identity item_tablest::_identity(sizeof(item_tablest), &allocator_fn<item_tablest>, "item_tablest",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_threadst
  static const struct_field_info item_threadst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, dye_mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, dye_mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, unk_88), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8c), TID(int32_t) },
    { FLD(PRIMITIVE, dye_quality), TID(int16_t) },
    { FLD(PRIMITIVE, unk_92), TID(int16_t) },
    { FLD(PRIMITIVE, unk_94), TID(int32_t) },
    { FLD(PRIMITIVE, unk_98), TID(int8_t) },
    { FLD(PRIMITIVE, dimension), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_threadst::_identity(sizeof(item_threadst), &allocator_fn<item_threadst>, "item_threadst",NULL,&item_actual::_identity,item_threadst_fields);
  #define CUR_STRUCT item_toolst
  static const struct_field_info item_toolst_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_toolst >::get(), 0, NULL },
    { FLD(PRIMITIVE, sharpness), TID(int32_t) },
    { FLD(SUBSTRUCT, stockpile), &item_stockpile_ref::_identity },
    { FLD(PRIMITIVE, vehicle_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_toolst::_identity(sizeof(item_toolst), &allocator_fn<item_toolst>, "item_toolst",NULL,&item_constructed::_identity,item_toolst_fields);
  #define CUR_STRUCT item_totemst
  static const struct_field_info item_totemst_fields[] = {
    { FLD(PRIMITIVE, unk_a0), TID(int16_t) },
    { FLD(PRIMITIVE, unk_a2), TID(int16_t) },
    { FLD(PRIMITIVE, unk_a4), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_totemst::_identity(sizeof(item_totemst), &allocator_fn<item_totemst>, "item_totemst",NULL,&item_constructed::_identity,item_totemst_fields);
  #define CUR_STRUCT item_toyst
  static const struct_field_info item_toyst_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_toyst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_toyst::_identity(sizeof(item_toyst), &allocator_fn<item_toyst>, "item_toyst",NULL,&item_constructed::_identity,item_toyst_fields);
  virtual_identity item_traction_benchst::_identity(sizeof(item_traction_benchst), &allocator_fn<item_traction_benchst>, "item_traction_benchst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_trapcompst
  static const struct_field_info item_trapcompst_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_trapcompst >::get(), 0, NULL },
    { FLD(PRIMITIVE, sharpness), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_trapcompst::_identity(sizeof(item_trapcompst), &allocator_fn<item_trapcompst>, "item_trapcompst",NULL,&item_constructed::_identity,item_trapcompst_fields);
  virtual_identity item_trappartsst::_identity(sizeof(item_trappartsst), &allocator_fn<item_trappartsst>, "item_trappartsst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT enum_traits<item_type>::attr_entry_type
  static const struct_field_info enum_traits_lT_item_type_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, caption), identity_traits<const char*>::get() },
    { FLD(PRIMITIVE, is_rawable), identity_traits<bool>::get() },
    { FLD(PRIMITIVE, is_stackable), identity_traits<bool>::get() },
    { FLD(PRIMITIVE, is_caste_mat), identity_traits<bool>::get() },
    { FLD(PRIMITIVE, classname), identity_traits<const char*>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<item_type>::attr_entry_type::_identity(sizeof(enum_traits<item_type>::attr_entry_type), NULL, TID(item_type), "_attr_entry_type", NULL, enum_traits_lT_item_type_Gt__doT_Dot_attr_entry_type_fields);
  virtual_identity item_verminst::_identity(sizeof(item_verminst), &allocator_fn<item_verminst>, "item_verminst",NULL,&item_critter::_identity,NULL);
  virtual_identity item_weaponrackst::_identity(sizeof(item_weaponrackst), &allocator_fn<item_weaponrackst>, "item_weaponrackst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_weaponst
  static const struct_field_info item_weaponst_fields[] = {
    { FLD(POINTER, subtype), identity_traits<df::itemdef_weaponst >::get(), 0, NULL },
    { FLD(PRIMITIVE, sharpness), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_weaponst::_identity(sizeof(item_weaponst), &allocator_fn<item_weaponst>, "item_weaponst",NULL,&item_constructed::_identity,item_weaponst_fields);
  virtual_identity item_windowst::_identity(sizeof(item_windowst), &allocator_fn<item_windowst>, "item_windowst",NULL,&item_constructed::_identity,NULL);
  #define CUR_STRUCT item_woodst
  static const struct_field_info item_woodst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity item_woodst::_identity(sizeof(item_woodst), &allocator_fn<item_woodst>, "item_woodst",NULL,&item_actual::_identity,item_woodst_fields);
  #define CUR_STRUCT itemdef
  static const struct_field_info itemdef_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, subtype), TID(int16_t) },
    { FLD(CONTAINER, base_flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(PRIMITIVE, source_hfid), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, raw_strings), identity_traits<std::string >::get(), 0, NULL },
    { METHOD(OBJ_METHOD, parseRaws) },
    { METHOD(OBJ_METHOD, categorize) },
    { METHOD(OBJ_METHOD, finalize) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef::_identity(sizeof(itemdef), &allocator_fn<itemdef>, "itemdef","itemdefst",NULL,itemdef_fields);
  #define CUR_STRUCT itemdef_ammost
  static const struct_field_info itemdef_ammost_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, adjective), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, ammo_class), identity_traits<std::string >::get() },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::ammo_flags> >::get(), 0, TID(ammo_flags) },
    { FLD(PRIMITIVE, size), TID(int32_t) },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, attacks), identity_traits<df::weapon_attack >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_ammost::_identity(sizeof(itemdef_ammost), &allocator_fn<itemdef_ammost>, "itemdef_ammost",NULL,&itemdef::_identity,itemdef_ammost_fields);
  #define CUR_STRUCT itemdef_armorst
  static const struct_field_info itemdef_armorst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_preplural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, material_placeholder), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, adjective), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(PRIMITIVE, armorlevel), TID(int8_t) },
    { FLD(PRIMITIVE, ubstep), TID(int16_t) },
    { FLD(PRIMITIVE, lbstep), TID(int16_t) },
    { FLD(PRIMITIVE, material_size), TID(int32_t) },
    { FLD(SUBSTRUCT, props), &armor_properties::_identity },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::armor_flags> >::get(), 0, TID(armor_flags) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_armorst::_identity(sizeof(itemdef_armorst), &allocator_fn<itemdef_armorst>, "itemdef_armorst",NULL,&itemdef::_identity,itemdef_armorst_fields);
  #define CUR_STRUCT itemdef_foodst
  static const struct_field_info itemdef_foodst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, level), TID(int16_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_foodst::_identity(sizeof(itemdef_foodst), &allocator_fn<itemdef_foodst>, "itemdef_foodst",NULL,&itemdef::_identity,itemdef_foodst_fields);
  #define CUR_STRUCT itemdef_glovesst
  static const struct_field_info itemdef_glovesst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, adjective), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(PRIMITIVE, armorlevel), TID(int8_t) },
    { FLD(PRIMITIVE, upstep), TID(int16_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::gloves_flags> >::get(), 0, TID(gloves_flags) },
    { FLD(PRIMITIVE, material_size), TID(int32_t) },
    { FLD(SUBSTRUCT, props), &armor_properties::_identity },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_glovesst::_identity(sizeof(itemdef_glovesst), &allocator_fn<itemdef_glovesst>, "itemdef_glovesst",NULL,&itemdef::_identity,itemdef_glovesst_fields);
  #define CUR_STRUCT itemdef_helmst
  static const struct_field_info itemdef_helmst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, adjective), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(PRIMITIVE, armorlevel), TID(int8_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::helm_flags> >::get(), 0, TID(helm_flags) },
    { FLD(PRIMITIVE, material_size), TID(int32_t) },
    { FLD(SUBSTRUCT, props), &armor_properties::_identity },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_helmst::_identity(sizeof(itemdef_helmst), &allocator_fn<itemdef_helmst>, "itemdef_helmst",NULL,&itemdef::_identity,itemdef_helmst_fields);
  #define CUR_STRUCT itemdef_instrumentst
  static const struct_field_info itemdef_instrumentst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::instrument_flags> >::get(), 0, TID(instrument_flags) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_instrumentst::_identity(sizeof(itemdef_instrumentst), &allocator_fn<itemdef_instrumentst>, "itemdef_instrumentst",NULL,&itemdef::_identity,itemdef_instrumentst_fields);
  #define CUR_STRUCT itemdef_pantsst
  static const struct_field_info itemdef_pantsst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_preplural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, material_placeholder), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, adjective), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(PRIMITIVE, armorlevel), TID(int8_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::pants_flags> >::get(), 0, TID(pants_flags) },
    { FLD(PRIMITIVE, material_size), TID(int32_t) },
    { FLD(PRIMITIVE, lbstep), TID(int16_t) },
    { FLD(SUBSTRUCT, props), &armor_properties::_identity },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_pantsst::_identity(sizeof(itemdef_pantsst), &allocator_fn<itemdef_pantsst>, "itemdef_pantsst",NULL,&itemdef::_identity,itemdef_pantsst_fields);
  #define CUR_STRUCT itemdef_shieldst
  static const struct_field_info itemdef_shieldst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, adjective), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(PRIMITIVE, blockchance), TID(int32_t) },
    { FLD(PRIMITIVE, armorlevel), TID(int8_t) },
    { FLD(PRIMITIVE, upstep), TID(int16_t) },
    { FLD(PRIMITIVE, material_size), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_shieldst::_identity(sizeof(itemdef_shieldst), &allocator_fn<itemdef_shieldst>, "itemdef_shieldst",NULL,&itemdef::_identity,itemdef_shieldst_fields);
  #define CUR_STRUCT itemdef_shoesst
  static const struct_field_info itemdef_shoesst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, adjective), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(PRIMITIVE, armorlevel), TID(int8_t) },
    { FLD(PRIMITIVE, upstep), TID(int16_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::shoes_flags> >::get(), 0, TID(shoes_flags) },
    { FLD(PRIMITIVE, material_size), TID(int32_t) },
    { FLD(SUBSTRUCT, props), &armor_properties::_identity },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_shoesst::_identity(sizeof(itemdef_shoesst), &allocator_fn<itemdef_shoesst>, "itemdef_shoesst",NULL,&itemdef::_identity,itemdef_shoesst_fields);
  #define CUR_STRUCT itemdef_siegeammost
  static const struct_field_info itemdef_siegeammost_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, ammo_class), identity_traits<std::string >::get() },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_siegeammost::_identity(sizeof(itemdef_siegeammost), &allocator_fn<itemdef_siegeammost>, "itemdef_siegeammost",NULL,&itemdef::_identity,itemdef_siegeammost_fields);
  #define CUR_STRUCT itemdef_toolst
  static const struct_field_info itemdef_toolst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::tool_flags> >::get(), 0, TID(tool_flags) },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(PRIMITIVE, tile), TID(uint8_t) },
    { FLD(CONTAINER, tool_use), identity_traits<std::vector<df::tool_uses > >::get(), 0, NULL },
    { FLD(PRIMITIVE, adjective), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, size), TID(int32_t) },
    { FLD(PRIMITIVE, skill_melee), TID(job_skill) },
    { FLD(PRIMITIVE, skill_ranged), TID(job_skill) },
    { FLD(PRIMITIVE, ranged_ammo), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, two_handed), TID(int32_t) },
    { FLD(PRIMITIVE, minimum_size), TID(int32_t) },
    { FLD(PRIMITIVE, material_size), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, attacks), identity_traits<df::weapon_attack >::get(), 0, NULL },
    { FLD(PRIMITIVE, shoot_force), TID(int32_t) },
    { FLD(PRIMITIVE, shoot_maxvel), TID(int32_t) },
    { FLD(PRIMITIVE, container_capacity), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_toolst::_identity(sizeof(itemdef_toolst), &allocator_fn<itemdef_toolst>, "itemdef_toolst",NULL,&itemdef::_identity,itemdef_toolst_fields);
  #define CUR_STRUCT itemdef_toyst
  static const struct_field_info itemdef_toyst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::toy_flags> >::get(), 0, TID(toy_flags) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_toyst::_identity(sizeof(itemdef_toyst), &allocator_fn<itemdef_toyst>, "itemdef_toyst",NULL,&itemdef::_identity,itemdef_toyst_fields);
  #define CUR_STRUCT itemdef_trapcompst
  static const struct_field_info itemdef_trapcompst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, adjective), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, size), TID(int32_t) },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(PRIMITIVE, hits), TID(int32_t) },
    { FLD(PRIMITIVE, material_size), TID(int32_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::trapcomp_flags> >::get(), 0, TID(trapcomp_flags) },
    { FLD(STL_VECTOR_PTR, attacks), identity_traits<df::weapon_attack >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_trapcompst::_identity(sizeof(itemdef_trapcompst), &allocator_fn<itemdef_trapcompst>, "itemdef_trapcompst",NULL,&itemdef::_identity,itemdef_trapcompst_fields);
  #define CUR_STRUCT itemdef_weaponst
  static const struct_field_info itemdef_weaponst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, adjective), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, size), TID(int32_t) },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(PRIMITIVE, skill_melee), TID(job_skill) },
    { FLD(PRIMITIVE, skill_ranged), TID(job_skill) },
    { FLD(PRIMITIVE, ranged_ammo), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, two_handed), TID(int32_t) },
    { FLD(PRIMITIVE, minimum_size), TID(int32_t) },
    { FLD(PRIMITIVE, material_size), TID(int32_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::weapon_flags> >::get(), 0, TID(weapon_flags) },
    { FLD(STL_VECTOR_PTR, attacks), identity_traits<df::weapon_attack >::get(), 0, NULL },
    { FLD(PRIMITIVE, shoot_force), TID(int32_t) },
    { FLD(PRIMITIVE, shoot_maxvel), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemdef_weaponst::_identity(sizeof(itemdef_weaponst), &allocator_fn<itemdef_weaponst>, "itemdef_weaponst",NULL,&itemdef::_identity,itemdef_weaponst_fields);
  #define CUR_STRUCT itemimprovement
  static const struct_field_info itemimprovement_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, maker), TID(int32_t) },
    { FLD(PRIMITIVE, masterpiece_event), TID(int32_t) },
    { FLD(PRIMITIVE, quality), TID(item_quality) },
    { FLD(PRIMITIVE, skill_rating), TID(skill_rating) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { METHOD(OBJ_METHOD, getImage) },
    { METHOD(OBJ_METHOD, getColorAndShape) },
    { METHOD(OBJ_METHOD, clone) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, getDyeValue) },
    { METHOD(OBJ_METHOD, setShape) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemimprovement::_identity(sizeof(itemimprovement), &allocator_fn<itemimprovement>, "itemimprovement","itemimprovementst",NULL,itemimprovement_fields);
  #define CUR_STRUCT itemimprovement_art_imagest
  static const struct_field_info itemimprovement_art_imagest_fields[] = {
    { FLD(SUBSTRUCT, image), &art_image_ref::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemimprovement_art_imagest::_identity(sizeof(itemimprovement_art_imagest), &allocator_fn<itemimprovement_art_imagest>, "itemimprovement_art_imagest",NULL,&itemimprovement::_identity,itemimprovement_art_imagest_fields);
  #define CUR_STRUCT itemimprovement_bandsst
  static const struct_field_info itemimprovement_bandsst_fields[] = {
    { FLD(PRIMITIVE, shape), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemimprovement_bandsst::_identity(sizeof(itemimprovement_bandsst), &allocator_fn<itemimprovement_bandsst>, "itemimprovement_bandsst",NULL,&itemimprovement::_identity,itemimprovement_bandsst_fields);
  virtual_identity itemimprovement_clothst::_identity(sizeof(itemimprovement_clothst), &allocator_fn<itemimprovement_clothst>, "itemimprovement_clothst",NULL,&itemimprovement::_identity,NULL);
  #define CUR_STRUCT itemimprovement_coveredst
  static const struct_field_info itemimprovement_coveredst_fields[] = {
    { FLD(SUBSTRUCT, cover_flags), TID(itemimprovement_coveredst::T_cover_flags) },
    { FLD(PRIMITIVE, shape), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemimprovement_coveredst::_identity(sizeof(itemimprovement_coveredst), &allocator_fn<itemimprovement_coveredst>, "itemimprovement_coveredst",NULL,&itemimprovement::_identity,itemimprovement_coveredst_fields);
  #define CUR_STRUCT itemimprovement_illustrationst
  static const struct_field_info itemimprovement_illustrationst_fields[] = {
    { FLD(SUBSTRUCT, image), &art_image_ref::_identity },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemimprovement_illustrationst::_identity(sizeof(itemimprovement_illustrationst), &allocator_fn<itemimprovement_illustrationst>, "itemimprovement_illustrationst",NULL,&itemimprovement::_identity,itemimprovement_illustrationst_fields);
  #define CUR_STRUCT itemimprovement_itemspecificst
  static const struct_field_info itemimprovement_itemspecificst_fields[] = {
    { FLD(PRIMITIVE, type), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemimprovement_itemspecificst::_identity(sizeof(itemimprovement_itemspecificst), &allocator_fn<itemimprovement_itemspecificst>, "itemimprovement_itemspecificst",NULL,&itemimprovement::_identity,itemimprovement_itemspecificst_fields);
  #define CUR_STRUCT itemimprovement_pagesst
  static const struct_field_info itemimprovement_pagesst_fields[] = {
    { FLD(PRIMITIVE, count), TID(int32_t) },
    { FLD(CONTAINER, contents), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemimprovement_pagesst::_identity(sizeof(itemimprovement_pagesst), &allocator_fn<itemimprovement_pagesst>, "itemimprovement_pagesst",NULL,&itemimprovement::_identity,itemimprovement_pagesst_fields);
  virtual_identity itemimprovement_rings_hangingst::_identity(sizeof(itemimprovement_rings_hangingst), &allocator_fn<itemimprovement_rings_hangingst>, "itemimprovement_rings_hangingst",NULL,&itemimprovement::_identity,NULL);
  #define CUR_STRUCT itemimprovement_sewn_imagest::T_cloth
  static const struct_field_info itemimprovement_sewn_imagest_doT_Dot_T_cloth_fields[] = {
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, quality), TID(int16_t) },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity itemimprovement_sewn_imagest::T_cloth::_identity(sizeof(itemimprovement_sewn_imagest::T_cloth), &allocator_fn<itemimprovement_sewn_imagest::T_cloth>, &itemimprovement_sewn_imagest::_identity, "T_cloth",NULL,itemimprovement_sewn_imagest_doT_Dot_T_cloth_fields);
  #define CUR_STRUCT itemimprovement_sewn_imagest
  static const struct_field_info itemimprovement_sewn_imagest_fields[] = {
    { FLD(SUBSTRUCT, image), &art_image_ref::_identity },
    { FLD(SUBSTRUCT, cloth), &itemimprovement_sewn_imagest::T_cloth::_identity },
    { FLD(SUBSTRUCT, dye), &dye_info::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemimprovement_sewn_imagest::_identity(sizeof(itemimprovement_sewn_imagest), &allocator_fn<itemimprovement_sewn_imagest>, "itemimprovement_sewn_imagest",NULL,&itemimprovement::_identity,itemimprovement_sewn_imagest_fields);
  virtual_identity itemimprovement_spikesst::_identity(sizeof(itemimprovement_spikesst), &allocator_fn<itemimprovement_spikesst>, "itemimprovement_spikesst",NULL,&itemimprovement::_identity,NULL);
  #define CUR_STRUCT itemimprovement_threadst
  static const struct_field_info itemimprovement_threadst_fields[] = {
    { FLD(SUBSTRUCT, dye), &dye_info::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity itemimprovement_threadst::_identity(sizeof(itemimprovement_threadst), &allocator_fn<itemimprovement_threadst>, "itemimprovement_threadst",NULL,&itemimprovement::_identity,itemimprovement_threadst_fields);
  #define CUR_STRUCT enum_traits<items_other_id>::attr_entry_type
  static const struct_field_info enum_traits_lT_items_other_id_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, item), identity_traits<df::item_type>::get() },
    { FLD(CONTAINER, generic_item), identity_traits<enum_list_attr<df::item_type>>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<items_other_id>::attr_entry_type::_identity(sizeof(enum_traits<items_other_id>::attr_entry_type), NULL, TID(items_other_id), "_attr_entry_type", NULL, enum_traits_lT_items_other_id_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT job
  static const struct_field_info job_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(POINTER, list_link), identity_traits<df::job_list_link >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_v4020_1), TID(int32_t) },
    { FLD(PRIMITIVE, job_type), TID(job_type) },
    { FLD(PRIMITIVE, job_subtype), TID(int32_t) },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(PRIMITIVE, completion_timer), TID(int32_t) },
    { FLD(PRIMITIVE, unk4), TID(uint32_t) },
    { FLD(SUBSTRUCT, flags), TID(job_flags) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, unk5), TID(int16_t) },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(SUBSTRUCT, item_category), TID(stockpile_group_set) },
    { FLD(PRIMITIVE, hist_figure_id), TID(int32_t) },
    { FLD(SUBSTRUCT, material_category), TID(job_material_category) },
    { FLD(PRIMITIVE, reaction_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, expire_timer), TID(int32_t) },
    { FLD(PRIMITIVE, recheck_cntdn), TID(int16_t) },
    { FLD(PRIMITIVE, wait_timer), TID(int16_t) },
    { FLD(PRIMITIVE, unk11), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, items), identity_traits<df::job_item_ref >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, specific_refs), identity_traits<df::specific_ref >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, general_refs), identity_traits<df::general_ref >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, job_items), identity_traits<df::job_item >::get(), 0, NULL },
    { FLD(SUBSTRUCT, guide_path), &coord_path::_identity },
    { FLD(PRIMITIVE, cur_path_index), TID(int32_t) },
    { FLD(SUBSTRUCT, unk_v4020_2), &coord::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity job::_identity(sizeof(job), &allocator_fn<job>, NULL, "job",NULL,job_fields);
  #define CUR_STRUCT job_item
  static const struct_field_info job_item_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(SUBSTRUCT, flags1), TID(job_item_flags1) },
    { FLD(PRIMITIVE, quantity), TID(int32_t) },
    { FLD(PRIMITIVE, vector_id), TID(job_item_vector_id) },
    { FLD(SUBSTRUCT, flags2), TID(job_item_flags2) },
    { FLD(SUBSTRUCT, flags3), TID(job_item_flags3) },
    { FLD(PRIMITIVE, flags4), TID(uint32_t) },
    { FLD(PRIMITIVE, flags5), TID(uint32_t) },
    { FLD(PRIMITIVE, metal_ore), TID(int32_t) },
    { FLD(PRIMITIVE, reaction_class), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, has_material_reaction_product), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, min_dimension), TID(int32_t) },
    { FLD(PRIMITIVE, reagent_index), TID(int32_t) },
    { FLD(CONTAINER, contains), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, reaction_id), TID(int32_t) },
    { FLD(PRIMITIVE, has_tool_use), TID(tool_uses) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity job_item::_identity(sizeof(job_item), &allocator_fn<job_item>, NULL, "job_item",NULL,job_item_fields);
  #define CUR_STRUCT job_item_filter
  static const struct_field_info job_item_filter_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(SUBSTRUCT, flags1), TID(job_item_flags1) },
    { FLD(POINTER, item_vector), identity_traits<std::vector<df::item* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, use_mat_index), TID(bool) },
    { FLD(SUBSTRUCT, flags2), TID(job_item_flags2) },
    { FLD(PRIMITIVE, use_flags2), TID(bool) },
    { FLD(SUBSTRUCT, flags3), TID(job_item_flags3) },
    { FLD(PRIMITIVE, use_flags3), TID(bool) },
    { FLD(PRIMITIVE, flags4), TID(uint32_t) },
    { FLD(PRIMITIVE, use_flags4), TID(bool) },
    { FLD(PRIMITIVE, flags5), TID(uint32_t) },
    { FLD(PRIMITIVE, use_flags5), TID(bool) },
    { FLD(PRIMITIVE, reaction_class), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, has_material_reaction_product), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, metal_ore), TID(int32_t) },
    { FLD(PRIMITIVE, use_metal_ore), TID(bool) },
    { FLD(PRIMITIVE, use_reaction_class), TID(bool) },
    { FLD(PRIMITIVE, use_reaction_product), TID(bool) },
    { FLD(PRIMITIVE, min_dimension), TID(int32_t) },
    { FLD(PRIMITIVE, reaction_id), TID(int32_t) },
    { FLD(CONTAINER, contains), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, use_contains), TID(bool) },
    { FLD(PRIMITIVE, has_tool_use), TID(tool_uses) },
    { FLD(PRIMITIVE, has_melee_skill), TID(job_skill) },
    { FLD(PRIMITIVE, unk_v40_1), TID(int8_t) },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, job), identity_traits<df::job >::get(), 0, NULL },
    { FLD(POINTER, building), identity_traits<df::building >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_74), TID(int32_t) },
    { FLD(CONTAINER, burrows), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, use_burrows), TID(bool) },
    { FLD(POINTER, take_from), identity_traits<std::vector<df::building* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity job_item_filter::_identity(sizeof(job_item_filter), &allocator_fn<job_item_filter>, NULL, "job_item_filter",NULL,job_item_filter_fields);
  #define CUR_STRUCT job_item_ref
  static const struct_field_info job_item_ref_fields[] = {
    { FLD(POINTER, item), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, role), TID(job_item_ref::T_role) },
    { FLD(PRIMITIVE, is_fetching), TID(int32_t) },
    { FLD(PRIMITIVE, job_item_idx), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity job_item_ref::_identity(sizeof(job_item_ref), &allocator_fn<job_item_ref>, NULL, "job_item_ref",NULL,job_item_ref_fields);
  #define CUR_STRUCT enum_traits<job_item_vector_id>::attr_entry_type
  static const struct_field_info enum_traits_lT_job_item_vector_id_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, other), identity_traits<df::items_other_id>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<job_item_vector_id>::attr_entry_type::_identity(sizeof(enum_traits<job_item_vector_id>::attr_entry_type), NULL, TID(job_item_vector_id), "_attr_entry_type", NULL, enum_traits_lT_job_item_vector_id_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT job_list_link
  static const struct_field_info job_list_link_fields[] = {
    { FLD(POINTER, item), identity_traits<df::job >::get(), 0, NULL },
    { FLD(POINTER, prev), identity_traits<df::job_list_link >::get(), 0, NULL },
    { FLD(POINTER, next), identity_traits<df::job_list_link >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity job_list_link::_identity(sizeof(job_list_link), &allocator_fn<job_list_link>, NULL, "job_list_link",NULL,job_list_link_fields);
  #define CUR_STRUCT enum_traits<job_skill>::attr_entry_type
  static const struct_field_info enum_traits_lT_job_skill_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, caption), identity_traits<const char*>::get() },
    { FLD(PRIMITIVE, caption_noun), identity_traits<const char*>::get() },
    { FLD(PRIMITIVE, profession), identity_traits<df::profession>::get() },
    { FLD(PRIMITIVE, labor), identity_traits<df::unit_labor>::get() },
    { FLD(PRIMITIVE, type), identity_traits<df::job_skill_class>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<job_skill>::attr_entry_type::_identity(sizeof(enum_traits<job_skill>::attr_entry_type), NULL, TID(job_skill), "_attr_entry_type", NULL, enum_traits_lT_job_skill_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT enum_traits<job_type>::attr_entry_type
  static const struct_field_info enum_traits_lT_job_type_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, caption), identity_traits<const char*>::get() },
    { FLD(PRIMITIVE, type), identity_traits<df::job_type_class>::get() },
    { FLD(PRIMITIVE, labor), identity_traits<df::unit_labor>::get() },
    { FLD(PRIMITIVE, item), identity_traits<df::item_type>::get() },
    { FLD(CONTAINER, possible_item), identity_traits<enum_list_attr<df::item_type>>::get() },
    { FLD(PRIMITIVE, material), identity_traits<const char*>::get() },
    { FLD(PRIMITIVE, skill), identity_traits<df::job_skill>::get() },
    { FLD(PRIMITIVE, skill_stone), identity_traits<df::job_skill>::get() },
    { FLD(PRIMITIVE, skill_wood), identity_traits<df::job_skill>::get() },
    { FLD(PRIMITIVE, skill_metal), identity_traits<df::job_skill>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<job_type>::attr_entry_type::_identity(sizeof(enum_traits<job_type>::attr_entry_type), NULL, TID(job_type), "_attr_entry_type", NULL, enum_traits_lT_job_type_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT language_name
  static const struct_field_info language_name_fields[] = {
    { FLD(PRIMITIVE, first_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, nickname), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, words), identity_traits<int32_t >::get(), 7, NULL },
    { FLD(STATIC_ARRAY, parts_of_speech), identity_traits<enum_field<df::part_of_speech,int16_t> >::get(), 7, NULL },
    { FLD(PRIMITIVE, language), TID(int32_t) },
    { FLD(PRIMITIVE, unknown), TID(int16_t) },
    { FLD(PRIMITIVE, has_name), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity language_name::_identity(sizeof(language_name), &allocator_fn<language_name>, NULL, "language_name",NULL,language_name_fields);
  #define CUR_STRUCT language_symbol
  static const struct_field_info language_symbol_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(CONTAINER, unknown), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, words), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, flags), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, str), identity_traits<std::string >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity language_symbol::_identity(sizeof(language_symbol), &allocator_fn<language_symbol>, NULL, "language_symbol",NULL,language_symbol_fields);
  #define CUR_STRUCT language_translation
  static const struct_field_info language_translation_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(CONTAINER, unknown1), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unknown2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, words), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, flags), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, str), identity_traits<std::string >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity language_translation::_identity(sizeof(language_translation), &allocator_fn<language_translation>, NULL, "language_translation",NULL,language_translation_fields);
  #define CUR_STRUCT language_word
  static const struct_field_info language_word_fields[] = {
    { FLD(PRIMITIVE, word), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, forms), identity_traits<std::string >::get(), 9, TID(part_of_speech) },
    { FLD(PRIMITIVE, adj_dist), TID(uint8_t) },
    { FLD(SUBSTRUCT, flags), TID(language_word_flags) },
    { FLD(STL_VECTOR_PTR, str), identity_traits<std::string >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity language_word::_identity(sizeof(language_word), &allocator_fn<language_word>, NULL, "language_word",NULL,language_word_fields);
  #define CUR_STRUCT language_word_table
  static const struct_field_info language_word_table_fields[] = {
    { FLD(STATIC_ARRAY, words), identity_traits<std::vector<int32_t > >::get(), 6, NULL },
    { FLD(STATIC_ARRAY, parts), identity_traits<std::vector<df::part_of_speech > >::get(), 6, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity language_word_table::_identity(sizeof(language_word_table), &allocator_fn<language_word_table>, NULL, "language_word_table",NULL,language_word_table_fields);
  #define CUR_STRUCT layer_object
  static const struct_field_info layer_object_fields[] = {
    { FLD(PRIMITIVE, enabled), TID(bool) },
    { FLD(PRIMITIVE, active), TID(bool) },
    { METHOD(OBJ_METHOD, getFirstVisible) },
    { METHOD(OBJ_METHOD, getLastVisible) },
    { METHOD(OBJ_METHOD, getX1) },
    { METHOD(OBJ_METHOD, getY1) },
    { METHOD(OBJ_METHOD, getX2) },
    { METHOD(OBJ_METHOD, getY2) },
    { METHOD(OBJ_METHOD, getListCursor) },
    { METHOD(OBJ_METHOD, setListCursor) },
    { METHOD(OBJ_METHOD, feed) },
    { METHOD(OBJ_METHOD, isSetMouseLRCur) },
    { METHOD(OBJ_METHOD, isSetMouseLCur) },
    { METHOD(OBJ_METHOD, isSetMouseRCur) },
    { METHOD(OBJ_METHOD, getMouseLCur) },
    { METHOD(OBJ_METHOD, getMouseRCur) },
    { METHOD(OBJ_METHOD, getListLength) },
    { METHOD(OBJ_METHOD, setListLength) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity layer_object::_identity(sizeof(layer_object), &allocator_fn<layer_object>, "layer_object","layer_objectst",NULL,layer_object_fields);
  #define CUR_STRUCT layer_object_buttonst
  static const struct_field_info layer_object_buttonst_fields[] = {
    { FLD(PRIMITIVE, x1), TID(int32_t) },
    { FLD(PRIMITIVE, y1), TID(int32_t) },
    { FLD(PRIMITIVE, x2), TID(int32_t) },
    { FLD(PRIMITIVE, y2), TID(int32_t) },
    { FLD(PRIMITIVE, has_mouse_lclick), TID(int32_t) },
    { FLD(PRIMITIVE, has_mouse_rclick), TID(int32_t) },
    { FLD(PRIMITIVE, mouse_lclick_x), TID(int32_t) },
    { FLD(PRIMITIVE, mouse_lclick_y), TID(int32_t) },
    { FLD(PRIMITIVE, mouse_rclick_x), TID(int32_t) },
    { FLD(PRIMITIVE, mouse_rclick_y), TID(int32_t) },
    { FLD(PRIMITIVE, mouse_x), TID(int32_t) },
    { FLD(PRIMITIVE, mouse_y), TID(int32_t) },
    { FLD(PRIMITIVE, mouse_x_old), TID(int32_t) },
    { FLD(PRIMITIVE, mouse_y_old), TID(int32_t) },
    { FLD(PRIMITIVE, handle_mouselbtndown), TID(int8_t) },
    { FLD(PRIMITIVE, handle_mouserbtndown), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity layer_object_buttonst::_identity(sizeof(layer_object_buttonst), &allocator_fn<layer_object_buttonst>, "layer_object_buttonst",NULL,&layer_object::_identity,layer_object_buttonst_fields);
  #define CUR_STRUCT layer_object_listst
  static const struct_field_info layer_object_listst_fields[] = {
    { FLD(PRIMITIVE, cursor), TID(int32_t) },
    { FLD(PRIMITIVE, num_entries), TID(int32_t) },
    { FLD(PRIMITIVE, x1), TID(int32_t) },
    { FLD(PRIMITIVE, y1), TID(int32_t) },
    { FLD(PRIMITIVE, page_size), TID(int32_t) },
    { FLD(PRIMITIVE, x2), TID(int32_t) },
    { FLD(PRIMITIVE, y2), TID(int32_t) },
    { FLD(PRIMITIVE, mouse_l_cur), TID(int32_t) },
    { FLD(PRIMITIVE, mouse_r_cur), TID(int32_t) },
    { FLD(PRIMITIVE, rclick_scrolls), TID(bool) },
    { FLD(PRIMITIVE, flag), TID(int32_t) },
    { FLD(PRIMITIVE, key_lclick), TID(interface_key) },
    { FLD(PRIMITIVE, key_rclick), TID(interface_key) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity layer_object_listst::_identity(sizeof(layer_object_listst), &allocator_fn<layer_object_listst>, "layer_object_listst",NULL,&layer_object::_identity,layer_object_listst_fields);
  #define CUR_STRUCT loadgame_save_info
  static const struct_field_info loadgame_save_info_fields[] = {
    { FLD(STATIC_ARRAY, save_info), identity_traits<int32_t >::get(), 32, NULL },
    { FLD(PRIMITIVE, game_type), identity_traits<enum_field<df::game_type,int16_t> >::get() },
    { FLD(PRIMITIVE, fort_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, world_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, folder_name), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity loadgame_save_info::_identity(sizeof(loadgame_save_info), &allocator_fn<loadgame_save_info>, NULL, "loadgame_save_info",NULL,loadgame_save_info_fields);
  #define CUR_STRUCT local_population
  static const struct_field_info local_population_fields[] = {
    { FLD(PRIMITIVE, type), identity_traits<enum_field<df::world_population_type,int8_t> >::get() },
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(PRIMITIVE, plant), TID(int16_t) },
    { FLD(PRIMITIVE, quantity), TID(int32_t) },
    { FLD(PRIMITIVE, quantity2), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(local_population::T_flags) },
    { FLD(SUBSTRUCT, population), &world_population_ref::_identity },
    { FLD(PRIMITIVE, wp_unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, wp_unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, wp_unk_1c), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity local_population::_identity(sizeof(local_population), &allocator_fn<local_population>, NULL, "local_population",NULL,local_population_fields);
  #define CUR_STRUCT machine::T_components
  static const struct_field_info machine_doT_Dot_T_components_fields[] = {
    { FLD(PRIMITIVE, building_id), TID(int32_t) },
    { FLD(CONTAINER, connections), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity machine::T_components::_identity(sizeof(machine::T_components), &allocator_fn<machine::T_components>, &machine::_identity, "T_components",NULL,machine_doT_Dot_T_components_fields);
  #define CUR_STRUCT machine
  static const struct_field_info machine_fields[] = {
    { FLD(PRIMITIVE, x), TID(int32_t) },
    { FLD(PRIMITIVE, y), TID(int32_t) },
    { FLD(PRIMITIVE, z), TID(int32_t) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, components), &machine::T_components::_identity, 0, NULL },
    { FLD(PRIMITIVE, cur_power), TID(int32_t) },
    { FLD(PRIMITIVE, min_power), TID(int32_t) },
    { FLD(PRIMITIVE, visual_phase), TID(int8_t) },
    { FLD(PRIMITIVE, phase_timer), TID(int16_t) },
    { FLD(SUBSTRUCT, flags), TID(machine::T_flags) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, moveMachine) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity machine::_identity(sizeof(machine), &allocator_fn<machine>, "machine","machinest",NULL,machine_fields);
  #define CUR_STRUCT machine_info
  static const struct_field_info machine_info_fields[] = {
    { FLD(PRIMITIVE, machine_id), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(machine_info::T_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity machine_info::_identity(sizeof(machine_info), &allocator_fn<machine_info>, NULL, "machine_info",NULL,machine_info_fields);
  virtual_identity machine_standardst::_identity(sizeof(machine_standardst), &allocator_fn<machine_standardst>, "machine_standardst",NULL,&machine::_identity,NULL);
  #define CUR_STRUCT machine_tile_set
  static const struct_field_info machine_tile_set_fields[] = {
    { FLD(SUBSTRUCT, tiles), &coord_path::_identity },
    { FLD(CONTAINER, can_connect), identity_traits<std::vector<df::machine_conn_modes > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity machine_tile_set::_identity(sizeof(machine_tile_set), &allocator_fn<machine_tile_set>, NULL, "machine_tile_set",NULL,machine_tile_set_fields);
  #define CUR_STRUCT manager_order
  static const struct_field_info manager_order_fields[] = {
    { FLD(PRIMITIVE, job_type), TID(job_type) },
    { FLD(PRIMITIVE, unk_2), TID(int16_t) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, reaction_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(SUBSTRUCT, item_category), TID(stockpile_group_set) },
    { FLD(PRIMITIVE, hist_figure_id), TID(int32_t) },
    { FLD(SUBSTRUCT, material_category), TID(job_material_category) },
    { FLD(PRIMITIVE, amount_left), TID(int16_t) },
    { FLD(PRIMITIVE, amount_total), TID(int16_t) },
    { FLD(PRIMITIVE, is_validated), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity manager_order::_identity(sizeof(manager_order), &allocator_fn<manager_order>, NULL, "manager_order",NULL,manager_order_fields);
  #define CUR_STRUCT manager_order_template
  static const struct_field_info manager_order_template_fields[] = {
    { FLD(PRIMITIVE, job_type), TID(job_type) },
    { FLD(PRIMITIVE, reaction_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(SUBSTRUCT, item_category), TID(stockpile_group_set) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(SUBSTRUCT, material_category), TID(job_material_category) },
    { FLD(PRIMITIVE, anon_3), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity manager_order_template::_identity(sizeof(manager_order_template), &allocator_fn<manager_order_template>, NULL, "manager_order_template",NULL,manager_order_template_fields);
  #define CUR_STRUCT mandate::T_punishment
  static const struct_field_info mandate_doT_Dot_T_punishment_fields[] = {
    { FLD(PRIMITIVE, hammerstrikes), TID(int32_t) },
    { FLD(PRIMITIVE, prison_time), TID(int32_t) },
    { FLD(PRIMITIVE, give_beating), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity mandate::T_punishment::_identity(sizeof(mandate::T_punishment), &allocator_fn<mandate::T_punishment>, &mandate::_identity, "T_punishment",NULL,mandate_doT_Dot_T_punishment_fields);
  #define CUR_STRUCT mandate
  static const struct_field_info mandate_fields[] = {
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, mode), TID(int16_t) },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, amount_total), TID(int16_t) },
    { FLD(PRIMITIVE, amount_remaining), TID(int16_t) },
    { FLD(PRIMITIVE, timeout_counter), TID(int32_t) },
    { FLD(PRIMITIVE, timeout_limit), TID(int32_t) },
    { FLD(SUBSTRUCT, punishment), &mandate::T_punishment::_identity },
    { FLD(PRIMITIVE, punish_multiple), TID(uint8_t) },
    { FLD(PRIMITIVE, unk4), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity mandate::_identity(sizeof(mandate), &allocator_fn<mandate>, NULL, "mandate",NULL,mandate_fields);
  typedef df::tiletype T_map_block_fields[16];
  typedef df::tile_designation T_map_block_fields_1[16];
  typedef df::tile_occupancy T_map_block_fields_2[16];
  typedef uint8_t T_map_block_fields_3[16];
  typedef int32_t T_map_block_fields_4[16];
  typedef uint16_t T_map_block_fields_5[16];
  typedef uint16_t T_map_block_fields_6[16];
  typedef uint16_t T_map_block_fields_7[16];
  typedef uint16_t T_map_block_fields_8[16];
  typedef uint16_t T_map_block_fields_9[16];
  typedef uint16_t T_map_block_fields_10[16];
  typedef df::tile_liquid_flow T_map_block_fields_11[16];
  #define CUR_STRUCT map_block
  static const struct_field_info map_block_fields[] = {
    { FLD(SUBSTRUCT, flags), TID(block_flags) },
    { FLD(STL_VECTOR_PTR, block_events), identity_traits<df::block_square_event >::get(), 0, NULL },
    { FLD(CONTAINER, block_burrows), identity_traits<df::block_burrow_link >::get(), 0, NULL },
    { FLD(PRIMITIVE, local_feature), TID(int32_t) },
    { FLD(PRIMITIVE, global_feature), TID(int32_t) },
    { FLD(PRIMITIVE, unk2), TID(int32_t) },
    { FLD(PRIMITIVE, layer_depth), TID(int16_t) },
    { FLD(PRIMITIVE, dsgn_check_cooldown), TID(int32_t) },
    { FLD(SUBSTRUCT, default_liquid), TID(tile_designation) },
    { FLD(CONTAINER, items), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, flows), identity_traits<df::flow_info >::get(), 0, NULL },
    { FLD(SUBSTRUCT, flow_pool), &flow_reuse_pool::_identity },
    { FLD(SUBSTRUCT, map_pos), &coord::_identity },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD(STATIC_ARRAY, tiletype), identity_traits<T_map_block_fields >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, designation), identity_traits<T_map_block_fields_1 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, occupancy), identity_traits<T_map_block_fields_2 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, fog_of_war), identity_traits<T_map_block_fields_3 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, path_cost), identity_traits<T_map_block_fields_4 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, path_tag), identity_traits<T_map_block_fields_5 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, walkable), identity_traits<T_map_block_fields_6 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, map_edge_distance), identity_traits<T_map_block_fields_7 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, temperature_1), identity_traits<T_map_block_fields_8 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, temperature_2), identity_traits<T_map_block_fields_9 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, unk13), identity_traits<T_map_block_fields_10 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, liquid_flow), identity_traits<T_map_block_fields_11 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, region_offset), identity_traits<uint8_t >::get(), 9, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity map_block::_identity(sizeof(map_block), &allocator_fn<map_block>, NULL, "map_block",NULL,map_block_fields);
  #define CUR_STRUCT map_block_column::T_unmined_glyphs
  static const struct_field_info map_block_column_doT_Dot_T_unmined_glyphs_fields[] = {
    { FLD(STATIC_ARRAY, x), identity_traits<int16_t >::get(), 4, NULL },
    { FLD(STATIC_ARRAY, y), identity_traits<int16_t >::get(), 4, NULL },
    { FLD(STATIC_ARRAY, tile), identity_traits<uint8_t >::get(), 4, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity map_block_column::T_unmined_glyphs::_identity(sizeof(map_block_column::T_unmined_glyphs), &allocator_fn<map_block_column::T_unmined_glyphs>, &map_block_column::_identity, "T_unmined_glyphs",NULL,map_block_column_doT_Dot_T_unmined_glyphs_fields);
  typedef df::cave_column_link T_map_block_column_fields[16];
  typedef int16_t T_map_block_column_fields_1[16];
  #define CUR_STRUCT map_block_column
  static const struct_field_info map_block_column_fields[] = {
    { FLD(PRIMITIVE, sink_level), TID(int16_t) },
    { FLD(PRIMITIVE, beach_level), TID(int16_t) },
    { FLD(PRIMITIVE, ground_level), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, unmined_glyphs), &map_block_column::T_unmined_glyphs::_identity, 0, NULL },
    { FLD(PRIMITIVE, z_base), TID(int16_t) },
    { FLD(STATIC_ARRAY, cave_columns), identity_traits<T_map_block_column_fields >::get(), 16, NULL },
    { FLD(STL_VECTOR_PTR, column_rectangles), identity_traits<df::cave_column_rectangle >::get(), 0, NULL },
    { FLD(PRIMITIVE, z_shift), TID(int16_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, unk_v40_1), identity_traits<T_map_block_column_fields_1 >::get(), 16, NULL },
    { FLD(SUBSTRUCT, map_pos), &coord2d::_identity },
    { FLD(PRIMITIVE, unk_c3c), TID(int16_t) },
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD(STL_VECTOR_PTR, plants), identity_traits<df::plant >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity map_block_column::_identity(sizeof(map_block_column), &allocator_fn<map_block_column>, NULL, "map_block_column",NULL,map_block_column_fields);
  #define CUR_STRUCT map_renderer::T_anon_4
  static const struct_field_info map_renderer_doT_Dot_T_anon_4_fields[] = {
    { FLD(PRIMITIVE, x), TID(int32_t) },
    { FLD(PRIMITIVE, y), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity map_renderer::T_anon_4::_identity(sizeof(map_renderer::T_anon_4), &allocator_fn<map_renderer::T_anon_4>, &map_renderer::_identity, "T_anon_4",NULL,map_renderer_doT_Dot_T_anon_4_fields);
  typedef uint8_t T_map_renderer_fields[256];
  #define CUR_STRUCT map_renderer
  static const struct_field_info map_renderer_fields[] = {
    { FLD(STATIC_ARRAY, entity), identity_traits<T_map_renderer_fields >::get(), 256, NULL },
    { FLD(STL_VECTOR_PTR, cursor_units), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, cursor_guts), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, multiple_guts), TID(bool) },
    { FLD(POINTER, cursor_corpse), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, cursor_corpse_cnt), TID(int32_t) },
    { FLD(POINTER, cursor_corpsepiece), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, cursor_corpsepiece_cnt), TID(int32_t) },
    { FLD(POINTER, cursor_bones), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, cursor_bones_cnt), TID(int32_t) },
    { FLD(POINTER, cursor_other), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, cursor_other_cnt), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10034), TID(int8_t) },
    { FLD(PRIMITIVE, unk_10035), TID(int8_t) },
    { FLD(PRIMITIVE, cur_tick_count), TID(int32_t) },
    { FLD(PRIMITIVE, tick_phase), TID(int16_t) },
    { FLD(PRIMITIVE, dim_colors), TID(int8_t) },
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(STATIC_ARRAY, anon_2), identity_traits<int32_t >::get(), 500, NULL },
    { FLD(STATIC_ARRAY, anon_3), identity_traits<int8_t >::get(), 500, NULL },
    { FLD(STATIC_ARRAY, anon_4), &map_renderer::T_anon_4::_identity, 500, NULL },
    { FLD(STATIC_ARRAY, anon_5), identity_traits<int32_t >::get(), 500, NULL },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity map_renderer::_identity(sizeof(map_renderer), &allocator_fn<map_renderer>, NULL, "map_renderer",NULL,map_renderer_fields);
  #define CUR_STRUCT map_viewport
  static const struct_field_info map_viewport_fields[] = {
    { FLD(PRIMITIVE, adv_mode), TID(bool) },
    { FLD(PRIMITIVE, unk1), TID(bool) },
    { FLD(PRIMITIVE, map_rotation), TID(uint8_t) },
    { FLD(PRIMITIVE, min_x), TID(int16_t) },
    { FLD(PRIMITIVE, min_y), TID(int16_t) },
    { FLD(PRIMITIVE, max_x), TID(int16_t) },
    { FLD(PRIMITIVE, max_y), TID(int16_t) },
    { FLD(PRIMITIVE, window_x), TID(int16_t) },
    { FLD(PRIMITIVE, window_y), TID(int16_t) },
    { FLD(PRIMITIVE, window_z), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity map_viewport::_identity(sizeof(map_viewport), &allocator_fn<map_viewport>, NULL, "map_viewport",NULL,map_viewport_fields);
  #define CUR_STRUCT material
  static const struct_field_info material_fields[] = {
    { FLD(PRIMITIVE, prefix), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, food_mat_index), identity_traits<int32_t >::get(), 37, TID(organic_mat_category) },
    { FLD(PRIMITIVE, powder_dye_str), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, state_color_str), identity_traits<std::string >::get(), 6, TID(matter_state) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity material::_identity(sizeof(material), &allocator_fn<material>, NULL, "material",&material_common::_identity,material_fields);
  #define CUR_STRUCT material_common::T_heat
  static const struct_field_info material_common_doT_Dot_T_heat_fields[] = {
    { FLD(PRIMITIVE, spec_heat), TID(uint16_t) },
    { FLD(PRIMITIVE, heatdam_point), TID(uint16_t) },
    { FLD(PRIMITIVE, colddam_point), TID(uint16_t) },
    { FLD(PRIMITIVE, ignite_point), TID(uint16_t) },
    { FLD(PRIMITIVE, melting_point), TID(uint16_t) },
    { FLD(PRIMITIVE, boiling_point), TID(uint16_t) },
    { FLD(PRIMITIVE, mat_fixed_temp), TID(uint16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity material_common::T_heat::_identity(sizeof(material_common::T_heat), &allocator_fn<material_common::T_heat>, &material_common::_identity, "T_heat",NULL,material_common_doT_Dot_T_heat_fields);
  #define CUR_STRUCT material_common::T_strength
  static const struct_field_info material_common_doT_Dot_T_strength_fields[] = {
    { FLD(PRIMITIVE, absorption), TID(int32_t) },
    { FLD(STATIC_ARRAY, yield), identity_traits<int32_t >::get(), 6, TID(strain_type) },
    { FLD(STATIC_ARRAY, fracture), identity_traits<int32_t >::get(), 6, TID(strain_type) },
    { FLD(STATIC_ARRAY, strain_at_yield), identity_traits<int32_t >::get(), 6, TID(strain_type) },
    { FLD(PRIMITIVE, max_edge), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity material_common::T_strength::_identity(sizeof(material_common::T_strength), &allocator_fn<material_common::T_strength>, &material_common::_identity, "T_strength",NULL,material_common_doT_Dot_T_strength_fields);
  #define CUR_STRUCT material_common::T_reaction_product
  static const struct_field_info material_common_doT_Dot_T_reaction_product_fields[] = {
    { FLD(STL_VECTOR_PTR, id), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, item_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, item_subtype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, material), &material_vec_ref::_identity },
    { FLD(STATIC_ARRAY, str), identity_traits<std::vector<std::string* > >::get(), 5, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity material_common::T_reaction_product::_identity(sizeof(material_common::T_reaction_product), &allocator_fn<material_common::T_reaction_product>, &material_common::_identity, "T_reaction_product",NULL,material_common_doT_Dot_T_reaction_product_fields);
  #define CUR_STRUCT material_common::T_hardens_with_water
  static const struct_field_info material_common_doT_Dot_T_hardens_with_water_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(STATIC_ARRAY, str), identity_traits<std::string >::get(), 3, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity material_common::T_hardens_with_water::_identity(sizeof(material_common::T_hardens_with_water), &allocator_fn<material_common::T_hardens_with_water>, &material_common::_identity, "T_hardens_with_water",NULL,material_common_doT_Dot_T_hardens_with_water_fields);
  #define CUR_STRUCT material_common
  static const struct_field_info material_common_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, gem_name1), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, gem_name2), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, stone_name), identity_traits<std::string >::get() },
    { FLD(SUBSTRUCT, heat), &material_common::T_heat::_identity },
    { FLD(PRIMITIVE, solid_density), TID(int32_t) },
    { FLD(PRIMITIVE, liquid_density), TID(int32_t) },
    { FLD(PRIMITIVE, molar_mass), TID(int32_t) },
    { FLD(STATIC_ARRAY, state_color), identity_traits<int32_t >::get(), 6, TID(matter_state) },
    { FLD(STATIC_ARRAY, state_name), identity_traits<std::string >::get(), 6, TID(matter_state) },
    { FLD(STATIC_ARRAY, state_adj), identity_traits<std::string >::get(), 6, TID(matter_state) },
    { FLD(SUBSTRUCT, strength), &material_common::T_strength::_identity },
    { FLD(PRIMITIVE, material_value), TID(int32_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::material_flags> >::get(), 0, TID(material_flags) },
    { FLD(PRIMITIVE, extract_storage), TID(item_type) },
    { FLD(PRIMITIVE, butcher_special_type), TID(item_type) },
    { FLD(PRIMITIVE, butcher_special_subtype), TID(int16_t) },
    { FLD(STATIC_ARRAY, meat_name), identity_traits<std::string >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, block_name), identity_traits<std::string >::get(), 2, NULL },
    { FLD(SUBSTRUCT, reaction_product), &material_common::T_reaction_product::_identity },
    { FLD(SUBSTRUCT, hardens_with_water), &material_common::T_hardens_with_water::_identity },
    { FLD(STL_VECTOR_PTR, reaction_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, tile), TID(uint8_t) },
    { FLD(STATIC_ARRAY, basic_color), identity_traits<int16_t >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, build_color), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, tile_color), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(PRIMITIVE, item_symbol), TID(uint8_t) },
    { FLD(PRIMITIVE, powder_dye), TID(int16_t) },
    { FLD(PRIMITIVE, temp_diet_info), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, syndrome), identity_traits<df::syndrome >::get(), 0, NULL },
    { FLD(PRIMITIVE, soap_level), TID(int32_t) },
    { FLD(CONTAINER, unk_41c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity material_common::_identity(sizeof(material_common), &allocator_fn<material_common>, NULL, "material_common",NULL,material_common_fields);
  #define CUR_STRUCT enum_traits<material_flags>::attr_entry_type
  static const struct_field_info enum_traits_lT_material_flags_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, type), identity_traits<df::craft_material_class>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<material_flags>::attr_entry_type::_identity(sizeof(enum_traits<material_flags>::attr_entry_type), NULL, TID(material_flags), "_attr_entry_type", NULL, enum_traits_lT_material_flags_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT material_template
  static const struct_field_info material_template_fields[] = {
    { FLD(PRIMITIVE, powder_dye_str), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, state_color_str), identity_traits<std::string >::get(), 6, TID(matter_state) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity material_template::_identity(sizeof(material_template), &allocator_fn<material_template>, NULL, "material_template",&material_common::_identity,material_template_fields);
  #define CUR_STRUCT material_vec_ref
  static const struct_field_info material_vec_ref_fields[] = {
    { FLD(CONTAINER, mat_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mat_index), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity material_vec_ref::_identity(sizeof(material_vec_ref), &allocator_fn<material_vec_ref>, NULL, "material_vec_ref",NULL,material_vec_ref_fields);
  #define CUR_STRUCT matgloss_list
  static const struct_field_info matgloss_list_fields[] = {
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, generated_inorganics), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, generated_plants), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, generated_items), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, generated_creatures), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, generated_entities), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, generated_interactions), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, generated_languages), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, inorganics), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, plants), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bodies), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bodyglosses), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, creatures), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, items), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, buildings), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, entities), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, words), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, symbols), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, translations), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, colors), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, shapes), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, patterns), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, reactions), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, material_templates), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, tissue_templates), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, body_detail_plans), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, creature_variations), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, interactions), identity_traits<std::string >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity matgloss_list::_identity(sizeof(matgloss_list), &allocator_fn<matgloss_list>, NULL, "matgloss_list",NULL,matgloss_list_fields);
  #define CUR_STRUCT meeting_context
  static const struct_field_info meeting_context_fields[] = {
    { FLD(POINTER, meeting), identity_traits<df::meeting_diplomat_info >::get(), 0, NULL },
    { FLD(POINTER, popup), identity_traits<df::dipscript_popup >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity meeting_context::_identity(sizeof(meeting_context), &allocator_fn<meeting_context>, NULL, "meeting_context",NULL,meeting_context_fields);
  #define CUR_STRUCT meeting_diplomat_info
  static const struct_field_info meeting_diplomat_info_fields[] = {
    { FLD(PRIMITIVE, civ_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk1), TID(int16_t) },
    { FLD(PRIMITIVE, diplomat_id), TID(int32_t) },
    { FLD(PRIMITIVE, associate_id), TID(int32_t) },
    { FLD(CONTAINER, topic_list), identity_traits<std::vector<enum_field<df::meeting_topic,int32_t> > >::get(), 0, NULL },
    { FLD(CONTAINER, topic_parms), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(POINTER, sell_requests), identity_traits<df::entity_sell_requests >::get(), 0, NULL },
    { FLD(POINTER, buy_requests), identity_traits<df::entity_buy_requests >::get(), 0, NULL },
    { FLD(POINTER, dipscript), identity_traits<df::dipscript_info >::get(), 0, NULL },
    { FLD(PRIMITIVE, cur_step), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, active_script_vars), identity_traits<df::active_script_varst >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_50), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_6c), identity_traits<std::string >::get() },
    { FLD(SUBSTRUCT, flags), TID(meeting_diplomat_info::T_flags) },
    { FLD(STL_VECTOR_PTR, events), identity_traits<df::meeting_event >::get(), 0, NULL },
    { FLD(CONTAINER, agreement_entity), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, agreement_topic), identity_traits<std::vector<df::meeting_topic > >::get(), 0, NULL },
    { FLD(CONTAINER, agreement_year), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, agreement_tick), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, agreement_outcome), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, contact_entity), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, contact_year), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, contact_tick), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity meeting_diplomat_info::_identity(sizeof(meeting_diplomat_info), &allocator_fn<meeting_diplomat_info>, NULL, "meeting_diplomat_info",NULL,meeting_diplomat_info_fields);
  #define CUR_STRUCT meeting_event
  static const struct_field_info meeting_event_fields[] = {
    { FLD(PRIMITIVE, type), TID(meeting_event_type) },
    { FLD(PRIMITIVE, topic), TID(meeting_topic) },
    { FLD(PRIMITIVE, topic_parm), TID(int16_t) },
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, quota_total), TID(int32_t) },
    { FLD(PRIMITIVE, quota_remaining), TID(int32_t) },
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, ticks), TID(int32_t) },
    { FLD(POINTER, sell_prices), identity_traits<df::entity_sell_prices >::get(), 0, NULL },
    { FLD(POINTER, buy_prices), identity_traits<df::entity_buy_prices >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity meeting_event::_identity(sizeof(meeting_event), &allocator_fn<meeting_event>, NULL, "meeting_event",NULL,meeting_event_fields);
  #define CUR_STRUCT meeting_variable
  static const struct_field_info meeting_variable_fields[] = {
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(SUBSTRUCT, ref), &specific_ref::_identity },
    { FLD(POINTER, active_var), identity_traits<df::active_script_varst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity meeting_variable::_identity(sizeof(meeting_variable), &allocator_fn<meeting_variable>, NULL, "meeting_variable",NULL,meeting_variable_fields);
  #define CUR_STRUCT enum_traits<misc_trait_type>::attr_entry_type
  static const struct_field_info enum_traits_lT_misc_trait_type_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, tag), identity_traits<const char*>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<misc_trait_type>::attr_entry_type::_identity(sizeof(enum_traits<misc_trait_type>::attr_entry_type), NULL, TID(misc_trait_type), "_attr_entry_type", NULL, enum_traits_lT_misc_trait_type_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT moving_party::T_members
  static const struct_field_info moving_party_doT_Dot_T_members_fields[] = {
    { FLD(PRIMITIVE, nemesis_id), TID(int32_t) },
    { FLD(PRIMITIVE, hunger), TID(int32_t) },
    { FLD(PRIMITIVE, thirst), TID(int32_t) },
    { FLD(PRIMITIVE, sleepiness), TID(int32_t) },
    { FLD(PRIMITIVE, stored_fat), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_20), TID(int32_t) },
    { FLD(PRIMITIVE, unk_24), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity moving_party::T_members::_identity(sizeof(moving_party::T_members), &allocator_fn<moving_party::T_members>, &moving_party::_identity, "T_members",NULL,moving_party_doT_Dot_T_members_fields);
  #define CUR_STRUCT moving_party
  static const struct_field_info moving_party_fields[] = {
    { FLD(SUBSTRUCT, pos), &coord2d::_identity },
    { FLD(PRIMITIVE, unk_4), TID(int16_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, members), &moving_party::T_members::_identity, 0, NULL },
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(CONTAINER, unk_30), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_40), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_70), TID(int16_t) },
    { FLD(PRIMITIVE, unk_72), TID(int16_t) },
    { FLD(PRIMITIVE, unk_74), TID(int16_t) },
    { FLD(PRIMITIVE, unk_7c), TID(int32_t) },
    { FLD(PRIMITIVE, region_id), TID(int32_t) },
    { FLD(PRIMITIVE, beast_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity moving_party::_identity(sizeof(moving_party), &allocator_fn<moving_party>, NULL, "moving_party",NULL,moving_party_fields);
  #define CUR_STRUCT nemesis_record
  static const struct_field_info nemesis_record_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, save_file_id), TID(int32_t) },
    { FLD(PRIMITIVE, member_idx), TID(int16_t) },
    { FLD(POINTER, figure), identity_traits<df::historical_figure >::get(), 0, NULL },
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, group_leader_id), TID(int32_t) },
    { FLD(CONTAINER, companions), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk10), TID(int16_t) },
    { FLD(PRIMITIVE, unk11), TID(int32_t) },
    { FLD(PRIMITIVE, unk12), TID(int32_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::nemesis_flags> >::get(), 0, TID(nemesis_flags) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity nemesis_record::_identity(sizeof(nemesis_record), &allocator_fn<nemesis_record>, NULL, "nemesis_record",NULL,nemesis_record_fields);
  #define CUR_STRUCT ocean_wave
  static const struct_field_info ocean_wave_fields[] = {
    { FLD(PRIMITIVE, x1), TID(int16_t) },
    { FLD(PRIMITIVE, y1), TID(int16_t) },
    { FLD(PRIMITIVE, x2), TID(int16_t) },
    { FLD(PRIMITIVE, y2), TID(int16_t) },
    { FLD(PRIMITIVE, z), TID(int16_t) },
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(PRIMITIVE, anon_2), TID(int8_t) },
    { FLD(PRIMITIVE, anon_3), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ocean_wave::_identity(sizeof(ocean_wave), &allocator_fn<ocean_wave>, NULL, "ocean_wave",NULL,ocean_wave_fields);
  #define CUR_STRUCT party_info
  static const struct_field_info party_info_fields[] = {
    { FLD(STL_VECTOR_PTR, units), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, location), identity_traits<df::building >::get(), 0, NULL },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity party_info::_identity(sizeof(party_info), &allocator_fn<party_info>, NULL, "party_info",NULL,party_info_fields);
  #define CUR_STRUCT plant
  static const struct_field_info plant_fields[] = {
    { FLD(SUBSTRUCT, flags), TID(plant_flags) },
    { FLD(PRIMITIVE, material), TID(int16_t) },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(PRIMITIVE, grow_counter), TID(int32_t) },
    { FLD(SUBSTRUCT, damage_flags), TID(plant::T_damage_flags) },
    { FLD(PRIMITIVE, hitpoints), TID(int32_t) },
    { FLD(PRIMITIVE, update_order), TID(int16_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, srb_id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, contaminants), identity_traits<df::spatter_common >::get(), 0, NULL },
    { FLD(POINTER, tree_info), identity_traits<df::plant_tree_info >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity plant::_identity(sizeof(plant), &allocator_fn<plant>, NULL, "plant",NULL,plant_fields);
  #define CUR_STRUCT plant_growth
  static const struct_field_info plant_growth_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, str_growth_item), identity_traits<std::string >::get(), 5, NULL },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, prints), identity_traits<df::plant_growth_print >::get(), 0, NULL },
    { FLD(PRIMITIVE, timing_1), TID(int32_t) },
    { FLD(PRIMITIVE, timing_2), TID(int32_t) },
    { FLD(SUBSTRUCT, locations), TID(plant_growth::T_locations) },
    { FLD(PRIMITIVE, density), TID(int32_t) },
    { FLD(SUBSTRUCT, behavior), TID(plant_growth::T_behavior) },
    { FLD(PRIMITIVE, trunk_height_perc_1), TID(int32_t) },
    { FLD(PRIMITIVE, trunk_height_perc_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity plant_growth::_identity(sizeof(plant_growth), &allocator_fn<plant_growth>, NULL, "plant_growth",NULL,plant_growth_fields);
  #define CUR_STRUCT plant_growth_print
  static const struct_field_info plant_growth_print_fields[] = {
    { FLD(PRIMITIVE, priority), TID(int32_t) },
    { FLD(PRIMITIVE, tile_growth), TID(uint8_t) },
    { FLD(PRIMITIVE, tile_item), TID(uint8_t) },
    { FLD(STATIC_ARRAY, color), identity_traits<int16_t >::get(), 3, NULL },
    { FLD(PRIMITIVE, timing_start), TID(int32_t) },
    { FLD(PRIMITIVE, timing_end), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity plant_growth_print::_identity(sizeof(plant_growth_print), &allocator_fn<plant_growth_print>, NULL, "plant_growth_print",NULL,plant_growth_print_fields);
  #define CUR_STRUCT plant_raw::T_tiles
  static const struct_field_info plant_raw_doT_Dot_T_tiles_fields[] = {
    { FLD(PRIMITIVE, picked_tile), TID(uint8_t) },
    { FLD(PRIMITIVE, dead_picked_tile), TID(uint8_t) },
    { FLD(PRIMITIVE, shrub_tile), TID(uint8_t) },
    { FLD(PRIMITIVE, dead_shrub_tile), TID(uint8_t) },
    { FLD(PRIMITIVE, tree_tile), TID(uint8_t) },
    { FLD(PRIMITIVE, dead_tree_tile), TID(uint8_t) },
    { FLD(PRIMITIVE, sapling_tile), TID(uint8_t) },
    { FLD(PRIMITIVE, dead_sapling_tile), TID(uint8_t) },
    { FLD(STATIC_ARRAY, grass_tiles), identity_traits<uint8_t >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, alt_grass_tiles), identity_traits<uint8_t >::get(), 12, NULL },
    { FLD(STATIC_ARRAY, tree_tiles), identity_traits<uint8_t >::get(), 104, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity plant_raw::T_tiles::_identity(sizeof(plant_raw::T_tiles), &allocator_fn<plant_raw::T_tiles>, &plant_raw::_identity, "T_tiles",NULL,plant_raw_doT_Dot_T_tiles_fields);
  #define CUR_STRUCT plant_raw::T_colors
  static const struct_field_info plant_raw_doT_Dot_T_colors_fields[] = {
    { FLD(STATIC_ARRAY, picked_color), identity_traits<int8_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, dead_picked_color), identity_traits<int8_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, shrub_color), identity_traits<int8_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, dead_shrub_color), identity_traits<int8_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, seed_color), identity_traits<int8_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, tree_color), identity_traits<int8_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, dead_tree_color), identity_traits<int8_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, sapling_color), identity_traits<int8_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, dead_sapling_color), identity_traits<int8_t >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, grass_colors_0), identity_traits<int8_t >::get(), 20, NULL },
    { FLD(STATIC_ARRAY, grass_colors_1), identity_traits<int8_t >::get(), 20, NULL },
    { FLD(STATIC_ARRAY, grass_colors_2), identity_traits<int8_t >::get(), 20, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity plant_raw::T_colors::_identity(sizeof(plant_raw::T_colors), &allocator_fn<plant_raw::T_colors>, &plant_raw::_identity, "T_colors",NULL,plant_raw_doT_Dot_T_colors_fields);
  #define CUR_STRUCT plant_raw::T_material_defs
  static const struct_field_info plant_raw_doT_Dot_T_material_defs_fields[] = {
    { FLD(PRIMITIVE, type_basic_mat), TID(int16_t) },
    { FLD(PRIMITIVE, type_tree), TID(int16_t) },
    { FLD(PRIMITIVE, type_drink), TID(int16_t) },
    { FLD(PRIMITIVE, type_seed), TID(int16_t) },
    { FLD(PRIMITIVE, type_thread), TID(int16_t) },
    { FLD(PRIMITIVE, type_mill), TID(int16_t) },
    { FLD(PRIMITIVE, type_extract_vial), TID(int16_t) },
    { FLD(PRIMITIVE, type_extract_barrel), TID(int16_t) },
    { FLD(PRIMITIVE, type_extract_still_vial), TID(int16_t) },
    { FLD(PRIMITIVE, idx_basic_mat), TID(int32_t) },
    { FLD(PRIMITIVE, idx_tree), TID(int32_t) },
    { FLD(PRIMITIVE, idx_drink), TID(int32_t) },
    { FLD(PRIMITIVE, idx_seed), TID(int32_t) },
    { FLD(PRIMITIVE, idx_thread), TID(int32_t) },
    { FLD(PRIMITIVE, idx_mill), TID(int32_t) },
    { FLD(PRIMITIVE, idx_extract_vial), TID(int32_t) },
    { FLD(PRIMITIVE, idx_extract_barrel), TID(int32_t) },
    { FLD(PRIMITIVE, idx_extract_still_vial), TID(int32_t) },
    { FLD(STATIC_ARRAY, str_basic_mat), identity_traits<std::string >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, str_tree), identity_traits<std::string >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, str_drink), identity_traits<std::string >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, str_seed), identity_traits<std::string >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, str_thread), identity_traits<std::string >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, str_mill), identity_traits<std::string >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, str_extract_vial), identity_traits<std::string >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, str_extract_barrel), identity_traits<std::string >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, str_extract_still_vial), identity_traits<std::string >::get(), 3, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity plant_raw::T_material_defs::_identity(sizeof(plant_raw::T_material_defs), &allocator_fn<plant_raw::T_material_defs>, &plant_raw::_identity, "T_material_defs",NULL,plant_raw_doT_Dot_T_material_defs_fields);
  #define CUR_STRUCT plant_raw
  static const struct_field_info plant_raw_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::plant_raw_flags> >::get(), 0, TID(plant_raw_flags) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, adj), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, seed_singular), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, seed_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, leaves_singular), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, leaves_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, source_hfid), TID(int32_t) },
    { FLD(PRIMITIVE, unk1), TID(uint8_t) },
    { FLD(PRIMITIVE, unk2), TID(uint8_t) },
    { FLD(SUBSTRUCT, tiles), &plant_raw::T_tiles::_identity },
    { FLD(PRIMITIVE, growdur), TID(int32_t) },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(SUBSTRUCT, colors), &plant_raw::T_colors::_identity },
    { FLD(STATIC_ARRAY, alt_period), identity_traits<int32_t >::get(), 2, NULL },
    { FLD(PRIMITIVE, shrub_drown_level), TID(int8_t) },
    { FLD(PRIMITIVE, tree_drown_level), TID(int8_t) },
    { FLD(PRIMITIVE, sapling_drown_level), TID(int8_t) },
    { FLD(PRIMITIVE, frequency), TID(int16_t) },
    { FLD(PRIMITIVE, clustersize), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, prefstring), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, material), identity_traits<df::material >::get(), 0, NULL },
    { FLD(SUBSTRUCT, material_defs), &plant_raw::T_material_defs::_identity },
    { FLD(PRIMITIVE, underground_depth_min), TID(int32_t) },
    { FLD(PRIMITIVE, underground_depth_max), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, growths), identity_traits<df::plant_growth >::get(), 0, NULL },
    { FLD(PRIMITIVE, root_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, trunk_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, heavy_branch_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, light_branch_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, twig_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, cap_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, trunk_period), TID(int32_t) },
    { FLD(PRIMITIVE, heavy_branch_density), TID(int32_t) },
    { FLD(PRIMITIVE, light_branch_density), TID(int32_t) },
    { FLD(PRIMITIVE, max_trunk_height), TID(int32_t) },
    { FLD(PRIMITIVE, heavy_branch_radius), TID(int32_t) },
    { FLD(PRIMITIVE, light_branch_radius), TID(int32_t) },
    { FLD(PRIMITIVE, trunk_branching), TID(int32_t) },
    { FLD(PRIMITIVE, max_trunk_diameter), TID(int32_t) },
    { FLD(PRIMITIVE, trunk_width_period), TID(int32_t) },
    { FLD(PRIMITIVE, cap_period), TID(int32_t) },
    { FLD(PRIMITIVE, cap_radius), TID(int32_t) },
    { FLD(PRIMITIVE, root_density), TID(int32_t) },
    { FLD(PRIMITIVE, root_radius), TID(int32_t) },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity plant_raw::_identity(sizeof(plant_raw), &allocator_fn<plant_raw>, NULL, "plant_raw",NULL,plant_raw_fields);
  #define CUR_STRUCT plant_tree_info
  static const struct_field_info plant_tree_info_fields[] = {
    { FLD(POINTER, body), identity_traits<df::plant_tree_tile* >::get(), 1, NULL },
    { FLD(POINTER, unk1), identity_traits<int16_t >::get(), 1, NULL },
    { FLD(POINTER, unk2), identity_traits<int16_t >::get(), 1, NULL },
    { FLD(POINTER, unk3), identity_traits<int16_t >::get(), 1, NULL },
    { FLD(POINTER, unk4), identity_traits<int16_t >::get(), 1, NULL },
    { FLD(PRIMITIVE, body_height), TID(int32_t) },
    { FLD(PRIMITIVE, dim_x), TID(int32_t) },
    { FLD(PRIMITIVE, dim_y), TID(int32_t) },
    { FLD(POINTER, roots), identity_traits<df::plant_tree_tile* >::get(), 1, NULL },
    { FLD(PRIMITIVE, roots_depth), TID(int32_t) },
    { FLD(PRIMITIVE, unk6), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity plant_tree_info::_identity(sizeof(plant_tree_info), &allocator_fn<plant_tree_info>, NULL, "plant_tree_info",NULL,plant_tree_info_fields);
  #define CUR_STRUCT popup_message
  static const struct_field_info popup_message_fields[] = {
    { FLD(PRIMITIVE, text), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, color), TID(int16_t) },
    { FLD(PRIMITIVE, bright), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity popup_message::_identity(sizeof(popup_message), &allocator_fn<popup_message>, NULL, "popup_message",NULL,popup_message_fields);
  #define CUR_STRUCT power_info
  static const struct_field_info power_info_fields[] = {
    { FLD(PRIMITIVE, produced), TID(int32_t) },
    { FLD(PRIMITIVE, consumed), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity power_info::_identity(sizeof(power_info), &allocator_fn<power_info>, NULL, "power_info",NULL,power_info_fields);
  #define CUR_STRUCT pressure_plate_info
  static const struct_field_info pressure_plate_info_fields[] = {
    { FLD(PRIMITIVE, unit_min), TID(int32_t) },
    { FLD(PRIMITIVE, unit_max), TID(int32_t) },
    { FLD(PRIMITIVE, water_min), TID(int8_t) },
    { FLD(PRIMITIVE, water_max), TID(int8_t) },
    { FLD(PRIMITIVE, magma_min), TID(int8_t) },
    { FLD(PRIMITIVE, magma_max), TID(int8_t) },
    { FLD(PRIMITIVE, track_min), TID(int32_t) },
    { FLD(PRIMITIVE, track_max), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(pressure_plate_info::T_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity pressure_plate_info::_identity(sizeof(pressure_plate_info), &allocator_fn<pressure_plate_info>, NULL, "pressure_plate_info",NULL,pressure_plate_info_fields);
  #define CUR_STRUCT enum_traits<profession>::attr_entry_type
  static const struct_field_info enum_traits_lT_profession_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, caption), identity_traits<const char*>::get() },
    { FLD(PRIMITIVE, military), identity_traits<bool>::get() },
    { FLD(PRIMITIVE, parent), identity_traits<df::profession>::get() },
    { FLD(PRIMITIVE, can_assign_labor), identity_traits<bool>::get() },
    { FLD(PRIMITIVE, color), identity_traits<int8_t>::get() },
    { FLD(PRIMITIVE, moodable), identity_traits<bool>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<profession>::attr_entry_type::_identity(sizeof(enum_traits<profession>::attr_entry_type), NULL, TID(profession), "_attr_entry_type", NULL, enum_traits_lT_profession_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT proj_itemst
  static const struct_field_info proj_itemst_fields[] = {
    { FLD(POINTER, item), identity_traits<df::item >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity proj_itemst::_identity(sizeof(proj_itemst), &allocator_fn<proj_itemst>, "proj_itemst",NULL,&projectile::_identity,proj_itemst_fields);
  #define CUR_STRUCT proj_list_link
  static const struct_field_info proj_list_link_fields[] = {
    { FLD(POINTER, item), identity_traits<df::projectile >::get(), 0, NULL },
    { FLD(POINTER, prev), identity_traits<df::proj_list_link >::get(), 0, NULL },
    { FLD(POINTER, next), identity_traits<df::proj_list_link >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity proj_list_link::_identity(sizeof(proj_list_link), &allocator_fn<proj_list_link>, NULL, "proj_list_link",NULL,proj_list_link_fields);
  #define CUR_STRUCT proj_magicst
  static const struct_field_info proj_magicst_fields[] = {
    { FLD(POINTER, unk), NULL, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity proj_magicst::_identity(sizeof(proj_magicst), &allocator_fn<proj_magicst>, "proj_magicst",NULL,&projectile::_identity,proj_magicst_fields);
  #define CUR_STRUCT proj_unitst
  static const struct_field_info proj_unitst_fields[] = {
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity proj_unitst::_identity(sizeof(proj_unitst), &allocator_fn<proj_unitst>, "proj_unitst",NULL,&projectile::_identity,proj_unitst_fields);
  #define CUR_STRUCT projectile
  static const struct_field_info projectile_fields[] = {
    { FLD(POINTER, link), identity_traits<df::proj_list_link >::get(), 0, NULL },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(POINTER, firer), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(SUBSTRUCT, origin_pos), &coord::_identity },
    { FLD(SUBSTRUCT, target_pos), &coord::_identity },
    { FLD(SUBSTRUCT, cur_pos), &coord::_identity },
    { FLD(SUBSTRUCT, prev_pos), &coord::_identity },
    { FLD(PRIMITIVE, distance_flown), TID(int32_t) },
    { FLD(PRIMITIVE, fall_threshold), TID(int32_t) },
    { FLD(PRIMITIVE, min_hit_distance), TID(int32_t) },
    { FLD(PRIMITIVE, min_ground_distance), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(projectile_flags) },
    { FLD(PRIMITIVE, fall_counter), TID(int16_t) },
    { FLD(PRIMITIVE, fall_delay), TID(int16_t) },
    { FLD(PRIMITIVE, hit_rating), TID(int32_t) },
    { FLD(PRIMITIVE, unk21), TID(int32_t) },
    { FLD(PRIMITIVE, unk22), TID(int32_t) },
    { FLD(PRIMITIVE, bow_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_item_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, pos_x), TID(int32_t) },
    { FLD(PRIMITIVE, pos_y), TID(int32_t) },
    { FLD(PRIMITIVE, pos_z), TID(int32_t) },
    { FLD(PRIMITIVE, speed_x), TID(int32_t) },
    { FLD(PRIMITIVE, speed_y), TID(int32_t) },
    { FLD(PRIMITIVE, speed_z), TID(int32_t) },
    { FLD(PRIMITIVE, accel_x), TID(int32_t) },
    { FLD(PRIMITIVE, accel_y), TID(int32_t) },
    { FLD(PRIMITIVE, accel_z), TID(int32_t) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, checkImpact) },
    { METHOD(OBJ_METHOD, checkMovement) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, isObjectLost) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity projectile::_identity(sizeof(projectile), &allocator_fn<projectile>, "projectile","projst",NULL,projectile_fields);
  #define CUR_STRUCT punishment
  static const struct_field_info punishment_fields[] = {
    { FLD(POINTER, criminal), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, officer), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, beating), TID(int16_t) },
    { FLD(PRIMITIVE, hammer_strikes), TID(int16_t) },
    { FLD(PRIMITIVE, prison_counter), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int16_t) },
    { FLD(POINTER, chain), identity_traits<df::building >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, victims), identity_traits<df::unit >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity punishment::_identity(sizeof(punishment), &allocator_fn<punishment>, NULL, "punishment",NULL,punishment_fields);
  #define CUR_STRUCT reaction::T_building
  static const struct_field_info reaction_doT_Dot_T_building_fields[] = {
    { FLD(STATIC_ARRAY, str), identity_traits<std::vector<std::string* > >::get(), 2, NULL },
    { FLD(CONTAINER, type), identity_traits<std::vector<df::building_type > >::get(), 0, NULL },
    { FLD(CONTAINER, subtype), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, custom), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, hotkey), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity reaction::T_building::_identity(sizeof(reaction::T_building), &allocator_fn<reaction::T_building>, &reaction::_identity, "T_building",NULL,reaction_doT_Dot_T_building_fields);
  #define CUR_STRUCT reaction
  static const struct_field_info reaction_fields[] = {
    { FLD(PRIMITIVE, code), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::reaction_flags> >::get(), 0, TID(reaction_flags) },
    { FLD(STL_VECTOR_PTR, reagents), identity_traits<df::reaction_reagent >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, products), identity_traits<df::reaction_product >::get(), 0, NULL },
    { FLD(PRIMITIVE, skill), TID(job_skill) },
    { FLD(SUBSTRUCT, building), &reaction::T_building::_identity },
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity reaction::_identity(sizeof(reaction), &allocator_fn<reaction>, NULL, "reaction",NULL,reaction_fields);
  #define CUR_STRUCT reaction_product
  static const struct_field_info reaction_product_fields[] = {
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, resolveTokens) },
    { METHOD(OBJ_METHOD, produce) },
    { METHOD(OBJ_METHOD, getDescription) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity reaction_product::_identity(sizeof(reaction_product), &allocator_fn<reaction_product>, "reaction_product","reaction_productst",NULL,reaction_product_fields);
  #define CUR_STRUCT reaction_product_item_improvementst::T_get_material
  static const struct_field_info reaction_product_item_improvementst_doT_Dot_T_get_material_fields[] = {
    { FLD(PRIMITIVE, reagent_code), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, product_code), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity reaction_product_item_improvementst::T_get_material::_identity(sizeof(reaction_product_item_improvementst::T_get_material), &allocator_fn<reaction_product_item_improvementst::T_get_material>, &reaction_product_item_improvementst::_identity, "T_get_material",NULL,reaction_product_item_improvementst_doT_Dot_T_get_material_fields);
  #define CUR_STRUCT reaction_product_item_improvementst
  static const struct_field_info reaction_product_item_improvementst_fields[] = {
    { FLD(PRIMITIVE, anon_1), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, target_reagent), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, improvement_type), TID(improvement_type) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, probability), TID(int16_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::reaction_product_improvement_flags> >::get(), 0, TID(reaction_product_improvement_flags) },
    { FLD(SUBSTRUCT, get_material), &reaction_product_item_improvementst::T_get_material::_identity },
    { FLD(STATIC_ARRAY, material_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity reaction_product_item_improvementst::_identity(sizeof(reaction_product_item_improvementst), &allocator_fn<reaction_product_item_improvementst>, "reaction_product_item_improvementst",NULL,&reaction_product::_identity,reaction_product_item_improvementst_fields);
  #define CUR_STRUCT reaction_product_itemst::T_get_material
  static const struct_field_info reaction_product_itemst_doT_Dot_T_get_material_fields[] = {
    { FLD(PRIMITIVE, reagent_code), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, product_code), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity reaction_product_itemst::T_get_material::_identity(sizeof(reaction_product_itemst::T_get_material), &allocator_fn<reaction_product_itemst::T_get_material>, &reaction_product_itemst::_identity, "T_get_material",NULL,reaction_product_itemst_doT_Dot_T_get_material_fields);
  #define CUR_STRUCT reaction_product_itemst
  static const struct_field_info reaction_product_itemst_fields[] = {
    { FLD(PRIMITIVE, product_to_container), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, probability), TID(int16_t) },
    { FLD(PRIMITIVE, count), TID(int16_t) },
    { FLD(PRIMITIVE, product_dimension), TID(int32_t) },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::reaction_product_item_flags> >::get(), 0, TID(reaction_product_item_flags) },
    { FLD(SUBSTRUCT, get_material), &reaction_product_itemst::T_get_material::_identity },
    { FLD(STATIC_ARRAY, item_str), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, material_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity reaction_product_itemst::_identity(sizeof(reaction_product_itemst), &allocator_fn<reaction_product_itemst>, "reaction_product_itemst",NULL,&reaction_product::_identity,reaction_product_itemst_fields);
  #define CUR_STRUCT reaction_reagent
  static const struct_field_info reaction_reagent_fields[] = {
    { FLD(PRIMITIVE, code), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, quantity), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(reaction_reagent_flags) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, resolveTokens) },
    { METHOD(OBJ_METHOD, matchesRoot) },
    { METHOD(OBJ_METHOD, matchesChild) },
    { METHOD(OBJ_METHOD, getDescription) },
    { METHOD(OBJ_METHOD, isLyeBearing) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity reaction_reagent::_identity(sizeof(reaction_reagent), &allocator_fn<reaction_reagent>, "reaction_reagent","reaction_reagentst",NULL,reaction_reagent_fields);
  #define CUR_STRUCT reaction_reagent_itemst
  static const struct_field_info reaction_reagent_itemst_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int16_t) },
    { FLD(PRIMITIVE, reaction_class), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, has_material_reaction_product), identity_traits<std::string >::get() },
    { FLD(SUBSTRUCT, flags1), TID(job_item_flags1) },
    { FLD(SUBSTRUCT, flags2), TID(job_item_flags2) },
    { FLD(SUBSTRUCT, flags3), TID(job_item_flags3) },
    { FLD(PRIMITIVE, flags4), TID(uint32_t) },
    { FLD(PRIMITIVE, flags5), TID(uint32_t) },
    { FLD(PRIMITIVE, metal_ore), TID(int32_t) },
    { FLD(PRIMITIVE, min_dimension), TID(int32_t) },
    { FLD(CONTAINER, contains), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, has_tool_use), TID(tool_uses) },
    { FLD(STATIC_ARRAY, item_str), identity_traits<std::string >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, material_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD(PRIMITIVE, metal_ore_str), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, contains_str), identity_traits<std::string >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity reaction_reagent_itemst::_identity(sizeof(reaction_reagent_itemst), &allocator_fn<reaction_reagent_itemst>, "reaction_reagent_itemst",NULL,&reaction_reagent::_identity,reaction_reagent_itemst_fields);
  #define CUR_STRUCT region_map_entry
  static const struct_field_info region_map_entry_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, finder_rank), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, sites), identity_traits<df::world_site >::get(), 0, NULL },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::region_map_entry_flags> >::get(), 0, TID(region_map_entry_flags) },
    { FLD(PRIMITIVE, elevation), TID(int16_t) },
    { FLD(PRIMITIVE, rainfall), TID(int16_t) },
    { FLD(PRIMITIVE, vegetation), TID(int16_t) },
    { FLD(PRIMITIVE, temperature), TID(int16_t) },
    { FLD(PRIMITIVE, evilness), TID(int16_t) },
    { FLD(PRIMITIVE, drainage), TID(int16_t) },
    { FLD(PRIMITIVE, volcanism), TID(int16_t) },
    { FLD(PRIMITIVE, savagery), TID(int16_t) },
    { FLD(PRIMITIVE, unk_30), TID(int16_t) },
    { FLD(PRIMITIVE, unk_32), TID(int16_t) },
    { FLD(PRIMITIVE, unk_34), TID(int16_t) },
    { FLD(SUBSTRUCT, clouds), TID(region_map_entry::T_clouds) },
    { FLD(SUBSTRUCT, wind), TID(region_map_entry::T_wind) },
    { FLD(PRIMITIVE, unk_3a), TID(int16_t) },
    { FLD(PRIMITIVE, salinity), TID(int16_t) },
    { FLD(SUBSTRUCT, unk_3e), &coord::_identity },
    { FLD(SUBSTRUCT, unk_44), &coord::_identity },
    { FLD(SUBSTRUCT, unk_4a), &coord::_identity },
    { FLD(PRIMITIVE, region_id), TID(int32_t) },
    { FLD(PRIMITIVE, landmass_id), TID(int32_t) },
    { FLD(PRIMITIVE, geo_index), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity region_map_entry::_identity(sizeof(region_map_entry), &allocator_fn<region_map_entry>, NULL, "region_map_entry",NULL,region_map_entry_fields);
  #define CUR_STRUCT renderer
  static const struct_field_info renderer_fields[] = {
    { FLD(POINTER, screen), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos), identity_traits<int32_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos_addcolor), identity_traits<int8_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos_grayscale), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos_cf), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos_cbr), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(POINTER, screen_old), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos_old), identity_traits<int32_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos_addcolor_old), identity_traits<int8_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos_grayscale_old), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos_cf_old), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD(POINTER, screentexpos_cbr_old), identity_traits<uint8_t >::get(), 1, NULL },
    { METHOD(OBJ_METHOD, update_tile) },
    { METHOD(OBJ_METHOD, update_all) },
    { METHOD(OBJ_METHOD, render) },
    { METHOD(OBJ_METHOD, set_fullscreen) },
    { METHOD(OBJ_METHOD, zoom) },
    { METHOD(OBJ_METHOD, resize) },
    { METHOD(OBJ_METHOD, grid_resize) },
    { METHOD(OBJ_METHOD, get_mouse_coords) },
    { METHOD(OBJ_METHOD, uses_opengl) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity renderer::_identity(sizeof(renderer), &allocator_fn<renderer>, "renderer",NULL,NULL,renderer_fields);
  #define CUR_STRUCT report
  static const struct_field_info report_fields[] = {
    { FLD(PRIMITIVE, type), TID(announcement_type) },
    { FLD(PRIMITIVE, text), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, color), TID(int16_t) },
    { FLD(PRIMITIVE, bright), TID(bool) },
    { FLD(PRIMITIVE, duration), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(report::T_flags) },
    { FLD(PRIMITIVE, repeat_count), TID(int32_t) },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, time), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_2), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_3), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity report::_identity(sizeof(report), &allocator_fn<report>, NULL, "report",NULL,report_fields);
  #define CUR_STRUCT resource_allotment_data::T_unk_654
  static const struct_field_info resource_allotment_data_doT_Dot_T_unk_654_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(CONTAINER, unk_4), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_14), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_24), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity resource_allotment_data::T_unk_654::_identity(sizeof(resource_allotment_data::T_unk_654), &allocator_fn<resource_allotment_data::T_unk_654>, &resource_allotment_data::_identity, "T_unk_654",NULL,resource_allotment_data_doT_Dot_T_unk_654_fields);
  #define CUR_STRUCT resource_allotment_data
  static const struct_field_info resource_allotment_data_fields[] = {
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(STATIC_ARRAY, resource_allotments), identity_traits<std::vector<df::resource_allotment_specifier* > >::get(), 100, NULL },
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD(PRIMITIVE, unk2), TID(int32_t) },
    { FLD(PRIMITIVE, unk3), TID(int32_t) },
    { FLD(PRIMITIVE, unk_650), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_654), &resource_allotment_data::T_unk_654::_identity, 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity resource_allotment_data::_identity(sizeof(resource_allotment_data), &allocator_fn<resource_allotment_data>, NULL, "resource_allotment_data",NULL,resource_allotment_data_fields);
  #define CUR_STRUCT resource_allotment_specifier
  static const struct_field_info resource_allotment_specifier_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier::_identity(sizeof(resource_allotment_specifier), &allocator_fn<resource_allotment_specifier>, "resource_allotment_specifier","resource_allotment_specifierst",NULL,resource_allotment_specifier_fields);
  #define CUR_STRUCT resource_allotment_specifier_ammost
  static const struct_field_info resource_allotment_specifier_ammost_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_ammost::_identity(sizeof(resource_allotment_specifier_ammost), &allocator_fn<resource_allotment_specifier_ammost>, "resource_allotment_specifier_ammost",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_ammost_fields);
  #define CUR_STRUCT resource_allotment_specifier_anvilst
  static const struct_field_info resource_allotment_specifier_anvilst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_anvilst::_identity(sizeof(resource_allotment_specifier_anvilst), &allocator_fn<resource_allotment_specifier_anvilst>, "resource_allotment_specifier_anvilst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_anvilst_fields);
  #define CUR_STRUCT resource_allotment_specifier_armor_bodyst
  static const struct_field_info resource_allotment_specifier_armor_bodyst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_armor_bodyst::_identity(sizeof(resource_allotment_specifier_armor_bodyst), &allocator_fn<resource_allotment_specifier_armor_bodyst>, "resource_allotment_specifier_armor_bodyst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_armor_bodyst_fields);
  #define CUR_STRUCT resource_allotment_specifier_armor_bootsst
  static const struct_field_info resource_allotment_specifier_armor_bootsst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_armor_bootsst::_identity(sizeof(resource_allotment_specifier_armor_bootsst), &allocator_fn<resource_allotment_specifier_armor_bootsst>, "resource_allotment_specifier_armor_bootsst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_armor_bootsst_fields);
  #define CUR_STRUCT resource_allotment_specifier_armor_glovesst
  static const struct_field_info resource_allotment_specifier_armor_glovesst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_armor_glovesst::_identity(sizeof(resource_allotment_specifier_armor_glovesst), &allocator_fn<resource_allotment_specifier_armor_glovesst>, "resource_allotment_specifier_armor_glovesst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_armor_glovesst_fields);
  #define CUR_STRUCT resource_allotment_specifier_armor_helmst
  static const struct_field_info resource_allotment_specifier_armor_helmst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_armor_helmst::_identity(sizeof(resource_allotment_specifier_armor_helmst), &allocator_fn<resource_allotment_specifier_armor_helmst>, "resource_allotment_specifier_armor_helmst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_armor_helmst_fields);
  #define CUR_STRUCT resource_allotment_specifier_armor_pantsst
  static const struct_field_info resource_allotment_specifier_armor_pantsst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_armor_pantsst::_identity(sizeof(resource_allotment_specifier_armor_pantsst), &allocator_fn<resource_allotment_specifier_armor_pantsst>, "resource_allotment_specifier_armor_pantsst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_armor_pantsst_fields);
  #define CUR_STRUCT resource_allotment_specifier_backpackst
  static const struct_field_info resource_allotment_specifier_backpackst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_backpackst::_identity(sizeof(resource_allotment_specifier_backpackst), &allocator_fn<resource_allotment_specifier_backpackst>, "resource_allotment_specifier_backpackst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_backpackst_fields);
  #define CUR_STRUCT resource_allotment_specifier_bagst
  static const struct_field_info resource_allotment_specifier_bagst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_bagst::_identity(sizeof(resource_allotment_specifier_bagst), &allocator_fn<resource_allotment_specifier_bagst>, "resource_allotment_specifier_bagst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_bagst_fields);
  #define CUR_STRUCT resource_allotment_specifier_bedst
  static const struct_field_info resource_allotment_specifier_bedst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_bedst::_identity(sizeof(resource_allotment_specifier_bedst), &allocator_fn<resource_allotment_specifier_bedst>, "resource_allotment_specifier_bedst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_bedst_fields);
  #define CUR_STRUCT resource_allotment_specifier_bonest
  static const struct_field_info resource_allotment_specifier_bonest_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_bonest::_identity(sizeof(resource_allotment_specifier_bonest), &allocator_fn<resource_allotment_specifier_bonest>, "resource_allotment_specifier_bonest",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_bonest_fields);
  #define CUR_STRUCT resource_allotment_specifier_boxst
  static const struct_field_info resource_allotment_specifier_boxst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_boxst::_identity(sizeof(resource_allotment_specifier_boxst), &allocator_fn<resource_allotment_specifier_boxst>, "resource_allotment_specifier_boxst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_boxst_fields);
  #define CUR_STRUCT resource_allotment_specifier_cabinetst
  static const struct_field_info resource_allotment_specifier_cabinetst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_cabinetst::_identity(sizeof(resource_allotment_specifier_cabinetst), &allocator_fn<resource_allotment_specifier_cabinetst>, "resource_allotment_specifier_cabinetst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_cabinetst_fields);
  #define CUR_STRUCT resource_allotment_specifier_chairst
  static const struct_field_info resource_allotment_specifier_chairst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_chairst::_identity(sizeof(resource_allotment_specifier_chairst), &allocator_fn<resource_allotment_specifier_chairst>, "resource_allotment_specifier_chairst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_chairst_fields);
  #define CUR_STRUCT resource_allotment_specifier_cheesest
  static const struct_field_info resource_allotment_specifier_cheesest_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_cheesest::_identity(sizeof(resource_allotment_specifier_cheesest), &allocator_fn<resource_allotment_specifier_cheesest>, "resource_allotment_specifier_cheesest",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_cheesest_fields);
  #define CUR_STRUCT resource_allotment_specifier_clothing_bodyst
  static const struct_field_info resource_allotment_specifier_clothing_bodyst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_clothing_bodyst::_identity(sizeof(resource_allotment_specifier_clothing_bodyst), &allocator_fn<resource_allotment_specifier_clothing_bodyst>, "resource_allotment_specifier_clothing_bodyst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_clothing_bodyst_fields);
  #define CUR_STRUCT resource_allotment_specifier_clothing_bootsst
  static const struct_field_info resource_allotment_specifier_clothing_bootsst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_clothing_bootsst::_identity(sizeof(resource_allotment_specifier_clothing_bootsst), &allocator_fn<resource_allotment_specifier_clothing_bootsst>, "resource_allotment_specifier_clothing_bootsst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_clothing_bootsst_fields);
  #define CUR_STRUCT resource_allotment_specifier_clothing_glovesst
  static const struct_field_info resource_allotment_specifier_clothing_glovesst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_clothing_glovesst::_identity(sizeof(resource_allotment_specifier_clothing_glovesst), &allocator_fn<resource_allotment_specifier_clothing_glovesst>, "resource_allotment_specifier_clothing_glovesst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_clothing_glovesst_fields);
  #define CUR_STRUCT resource_allotment_specifier_clothing_helmst
  static const struct_field_info resource_allotment_specifier_clothing_helmst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_clothing_helmst::_identity(sizeof(resource_allotment_specifier_clothing_helmst), &allocator_fn<resource_allotment_specifier_clothing_helmst>, "resource_allotment_specifier_clothing_helmst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_clothing_helmst_fields);
  #define CUR_STRUCT resource_allotment_specifier_clothing_pantsst
  static const struct_field_info resource_allotment_specifier_clothing_pantsst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_clothing_pantsst::_identity(sizeof(resource_allotment_specifier_clothing_pantsst), &allocator_fn<resource_allotment_specifier_clothing_pantsst>, "resource_allotment_specifier_clothing_pantsst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_clothing_pantsst_fields);
  #define CUR_STRUCT resource_allotment_specifier_clothst
  static const struct_field_info resource_allotment_specifier_clothst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_clothst::_identity(sizeof(resource_allotment_specifier_clothst), &allocator_fn<resource_allotment_specifier_clothst>, "resource_allotment_specifier_clothst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_clothst_fields);
  #define CUR_STRUCT resource_allotment_specifier_craftsst
  static const struct_field_info resource_allotment_specifier_craftsst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_craftsst::_identity(sizeof(resource_allotment_specifier_craftsst), &allocator_fn<resource_allotment_specifier_craftsst>, "resource_allotment_specifier_craftsst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_craftsst_fields);
  #define CUR_STRUCT resource_allotment_specifier_cropst
  static const struct_field_info resource_allotment_specifier_cropst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_01), TID(int32_t) },
    { FLD(STATIC_ARRAY, anon_3), identity_traits<int32_t >::get(), 5, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_cropst::_identity(sizeof(resource_allotment_specifier_cropst), &allocator_fn<resource_allotment_specifier_cropst>, "resource_allotment_specifier_cropst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_cropst_fields);
  #define CUR_STRUCT resource_allotment_specifier_extractst
  static const struct_field_info resource_allotment_specifier_extractst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, mat_type2), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_extractst::_identity(sizeof(resource_allotment_specifier_extractst), &allocator_fn<resource_allotment_specifier_extractst>, "resource_allotment_specifier_extractst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_extractst_fields);
  #define CUR_STRUCT resource_allotment_specifier_flaskst
  static const struct_field_info resource_allotment_specifier_flaskst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_flaskst::_identity(sizeof(resource_allotment_specifier_flaskst), &allocator_fn<resource_allotment_specifier_flaskst>, "resource_allotment_specifier_flaskst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_flaskst_fields);
  #define CUR_STRUCT resource_allotment_specifier_gemsst
  static const struct_field_info resource_allotment_specifier_gemsst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_gemsst::_identity(sizeof(resource_allotment_specifier_gemsst), &allocator_fn<resource_allotment_specifier_gemsst>, "resource_allotment_specifier_gemsst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_gemsst_fields);
  #define CUR_STRUCT resource_allotment_specifier_hornst
  static const struct_field_info resource_allotment_specifier_hornst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_hornst::_identity(sizeof(resource_allotment_specifier_hornst), &allocator_fn<resource_allotment_specifier_hornst>, "resource_allotment_specifier_hornst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_hornst_fields);
  #define CUR_STRUCT resource_allotment_specifier_leatherst
  static const struct_field_info resource_allotment_specifier_leatherst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD(PRIMITIVE, anon_9), TID(int32_t) },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_leatherst::_identity(sizeof(resource_allotment_specifier_leatherst), &allocator_fn<resource_allotment_specifier_leatherst>, "resource_allotment_specifier_leatherst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_leatherst_fields);
  #define CUR_STRUCT resource_allotment_specifier_meatst
  static const struct_field_info resource_allotment_specifier_meatst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_meatst::_identity(sizeof(resource_allotment_specifier_meatst), &allocator_fn<resource_allotment_specifier_meatst>, "resource_allotment_specifier_meatst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_meatst_fields);
  #define CUR_STRUCT resource_allotment_specifier_metalst
  static const struct_field_info resource_allotment_specifier_metalst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(STATIC_ARRAY, anon_2), identity_traits<int32_t >::get(), 12, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_metalst::_identity(sizeof(resource_allotment_specifier_metalst), &allocator_fn<resource_allotment_specifier_metalst>, "resource_allotment_specifier_metalst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_metalst_fields);
  #define CUR_STRUCT resource_allotment_specifier_pearlst
  static const struct_field_info resource_allotment_specifier_pearlst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_pearlst::_identity(sizeof(resource_allotment_specifier_pearlst), &allocator_fn<resource_allotment_specifier_pearlst>, "resource_allotment_specifier_pearlst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_pearlst_fields);
  #define CUR_STRUCT resource_allotment_specifier_powderst
  static const struct_field_info resource_allotment_specifier_powderst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_powderst::_identity(sizeof(resource_allotment_specifier_powderst), &allocator_fn<resource_allotment_specifier_powderst>, "resource_allotment_specifier_powderst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_powderst_fields);
  #define CUR_STRUCT resource_allotment_specifier_quiverst
  static const struct_field_info resource_allotment_specifier_quiverst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_quiverst::_identity(sizeof(resource_allotment_specifier_quiverst), &allocator_fn<resource_allotment_specifier_quiverst>, "resource_allotment_specifier_quiverst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_quiverst_fields);
  #define CUR_STRUCT resource_allotment_specifier_shellst
  static const struct_field_info resource_allotment_specifier_shellst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_shellst::_identity(sizeof(resource_allotment_specifier_shellst), &allocator_fn<resource_allotment_specifier_shellst>, "resource_allotment_specifier_shellst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_shellst_fields);
  #define CUR_STRUCT resource_allotment_specifier_skinst
  static const struct_field_info resource_allotment_specifier_skinst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, mat_type2), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_skinst::_identity(sizeof(resource_allotment_specifier_skinst), &allocator_fn<resource_allotment_specifier_skinst>, "resource_allotment_specifier_skinst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_skinst_fields);
  #define CUR_STRUCT resource_allotment_specifier_soapst
  static const struct_field_info resource_allotment_specifier_soapst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_soapst::_identity(sizeof(resource_allotment_specifier_soapst), &allocator_fn<resource_allotment_specifier_soapst>, "resource_allotment_specifier_soapst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_soapst_fields);
  #define CUR_STRUCT resource_allotment_specifier_stonest
  static const struct_field_info resource_allotment_specifier_stonest_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(STATIC_ARRAY, anon_3), identity_traits<int32_t >::get(), 5, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_stonest::_identity(sizeof(resource_allotment_specifier_stonest), &allocator_fn<resource_allotment_specifier_stonest>, "resource_allotment_specifier_stonest",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_stonest_fields);
  #define CUR_STRUCT resource_allotment_specifier_tablest
  static const struct_field_info resource_allotment_specifier_tablest_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_tablest::_identity(sizeof(resource_allotment_specifier_tablest), &allocator_fn<resource_allotment_specifier_tablest>, "resource_allotment_specifier_tablest",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_tablest_fields);
  #define CUR_STRUCT resource_allotment_specifier_tallowst
  static const struct_field_info resource_allotment_specifier_tallowst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_tallowst::_identity(sizeof(resource_allotment_specifier_tallowst), &allocator_fn<resource_allotment_specifier_tallowst>, "resource_allotment_specifier_tallowst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_tallowst_fields);
  #define CUR_STRUCT resource_allotment_specifier_threadst
  static const struct_field_info resource_allotment_specifier_threadst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_threadst::_identity(sizeof(resource_allotment_specifier_threadst), &allocator_fn<resource_allotment_specifier_threadst>, "resource_allotment_specifier_threadst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_threadst_fields);
  #define CUR_STRUCT resource_allotment_specifier_toothst
  static const struct_field_info resource_allotment_specifier_toothst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_toothst::_identity(sizeof(resource_allotment_specifier_toothst), &allocator_fn<resource_allotment_specifier_toothst>, "resource_allotment_specifier_toothst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_toothst_fields);
  #define CUR_STRUCT resource_allotment_specifier_weapon_meleest
  static const struct_field_info resource_allotment_specifier_weapon_meleest_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_weapon_meleest::_identity(sizeof(resource_allotment_specifier_weapon_meleest), &allocator_fn<resource_allotment_specifier_weapon_meleest>, "resource_allotment_specifier_weapon_meleest",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_weapon_meleest_fields);
  #define CUR_STRUCT resource_allotment_specifier_weapon_rangedst
  static const struct_field_info resource_allotment_specifier_weapon_rangedst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_weapon_rangedst::_identity(sizeof(resource_allotment_specifier_weapon_rangedst), &allocator_fn<resource_allotment_specifier_weapon_rangedst>, "resource_allotment_specifier_weapon_rangedst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_weapon_rangedst_fields);
  #define CUR_STRUCT resource_allotment_specifier_woodst
  static const struct_field_info resource_allotment_specifier_woodst_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity resource_allotment_specifier_woodst::_identity(sizeof(resource_allotment_specifier_woodst), &allocator_fn<resource_allotment_specifier_woodst>, "resource_allotment_specifier_woodst",NULL,&resource_allotment_specifier::_identity,resource_allotment_specifier_woodst_fields);
  #define CUR_STRUCT room_rent_info
  static const struct_field_info room_rent_info_fields[] = {
    { FLD(STL_VECTOR_PTR, elements), identity_traits<df::building >::get(), 0, NULL },
    { FLD(PRIMITIVE, rent_value), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(room_rent_info::T_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity room_rent_info::_identity(sizeof(room_rent_info), &allocator_fn<room_rent_info>, NULL, "room_rent_info",NULL,room_rent_info_fields);
  #define CUR_STRUCT route_stockpile_link
  static const struct_field_info route_stockpile_link_fields[] = {
    { FLD(PRIMITIVE, building_id), TID(int32_t) },
    { FLD(SUBSTRUCT, mode), TID(route_stockpile_link::T_mode) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity route_stockpile_link::_identity(sizeof(route_stockpile_link), &allocator_fn<route_stockpile_link>, NULL, "route_stockpile_link",NULL,route_stockpile_link_fields);
  #define CUR_STRUCT schedule_info
  static const struct_field_info schedule_info_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, slots), identity_traits<df::schedule_slot >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity schedule_info::_identity(sizeof(schedule_info), &allocator_fn<schedule_info>, NULL, "schedule_info",NULL,schedule_info_fields);
  #define CUR_STRUCT schedule_slot
  static const struct_field_info schedule_slot_fields[] = {
    { FLD(PRIMITIVE, type), TID(int16_t) },
    { FLD(PRIMITIVE, start_time), TID(int16_t) },
    { FLD(PRIMITIVE, end_time), TID(int16_t) },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, processed), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity schedule_slot::_identity(sizeof(schedule_slot), &allocator_fn<schedule_slot>, NULL, "schedule_slot",NULL,schedule_slot_fields);
  #define CUR_STRUCT script_step_conditionalst::T_condition
  static const struct_field_info script_step_conditionalst_doT_Dot_T_condition_fields[] = {
    { FLD(PRIMITIVE, var1_type), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, var1_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, comparison), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, var2_type), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, var2_name), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity script_step_conditionalst::T_condition::_identity(sizeof(script_step_conditionalst::T_condition), &allocator_fn<script_step_conditionalst::T_condition>, &script_step_conditionalst::_identity, "T_condition",NULL,script_step_conditionalst_doT_Dot_T_condition_fields);
  #define CUR_STRUCT script_step_conditionalst
  static const struct_field_info script_step_conditionalst_fields[] = {
    { FLD(SUBSTRUCT, condition), &script_step_conditionalst::T_condition::_identity },
    { FLD(PRIMITIVE, conditional_next_step_idx), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity script_step_conditionalst::_identity(sizeof(script_step_conditionalst), &allocator_fn<script_step_conditionalst>, "script_step_conditionalst",NULL,&script_stepst::_identity,script_step_conditionalst_fields);
  virtual_identity script_step_constructtopiclistst::_identity(sizeof(script_step_constructtopiclistst), &allocator_fn<script_step_constructtopiclistst>, "script_step_constructtopiclistst",NULL,&script_stepst::_identity,NULL);
  #define CUR_STRUCT script_step_dipeventst
  static const struct_field_info script_step_dipeventst_fields[] = {
    { FLD(PRIMITIVE, parm1), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, parm2), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, parm3), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, parm4), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, parm5), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity script_step_dipeventst::_identity(sizeof(script_step_dipeventst), &allocator_fn<script_step_dipeventst>, "script_step_dipeventst",NULL,&script_step_eventst::_identity,script_step_dipeventst_fields);
  #define CUR_STRUCT script_step_diphistoryst
  static const struct_field_info script_step_diphistoryst_fields[] = {
    { FLD(PRIMITIVE, event), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity script_step_diphistoryst::_identity(sizeof(script_step_diphistoryst), &allocator_fn<script_step_diphistoryst>, "script_step_diphistoryst",NULL,&script_stepst::_identity,script_step_diphistoryst_fields);
  #define CUR_STRUCT script_step_discussst
  static const struct_field_info script_step_discussst_fields[] = {
    { FLD(PRIMITIVE, event), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity script_step_discussst::_identity(sizeof(script_step_discussst), &allocator_fn<script_step_discussst>, "script_step_discussst",NULL,&script_stepst::_identity,script_step_discussst_fields);
  virtual_identity script_step_eventst::_identity(sizeof(script_step_eventst), &allocator_fn<script_step_eventst>, "script_step_eventst",NULL,&script_stepst::_identity,NULL);
  #define CUR_STRUCT script_step_invasionst
  static const struct_field_info script_step_invasionst_fields[] = {
    { FLD(PRIMITIVE, parm), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity script_step_invasionst::_identity(sizeof(script_step_invasionst), &allocator_fn<script_step_invasionst>, "script_step_invasionst",NULL,&script_step_eventst::_identity,script_step_invasionst_fields);
  #define CUR_STRUCT script_step_setvarst
  static const struct_field_info script_step_setvarst_fields[] = {
    { FLD(PRIMITIVE, dest_type), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, dest_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, src_type), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, src_name), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity script_step_setvarst::_identity(sizeof(script_step_setvarst), &allocator_fn<script_step_setvarst>, "script_step_setvarst",NULL,&script_stepst::_identity,script_step_setvarst_fields);
  #define CUR_STRUCT script_step_simpleactionst
  static const struct_field_info script_step_simpleactionst_fields[] = {
    { FLD(PRIMITIVE, type), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, subtype), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity script_step_simpleactionst::_identity(sizeof(script_step_simpleactionst), &allocator_fn<script_step_simpleactionst>, "script_step_simpleactionst",NULL,&script_stepst::_identity,script_step_simpleactionst_fields);
  #define CUR_STRUCT script_step_textviewerst
  static const struct_field_info script_step_textviewerst_fields[] = {
    { FLD(PRIMITIVE, filename), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, outvar_name), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity script_step_textviewerst::_identity(sizeof(script_step_textviewerst), &allocator_fn<script_step_textviewerst>, "script_step_textviewerst",NULL,&script_stepst::_identity,script_step_textviewerst_fields);
  virtual_identity script_step_topicdiscussionst::_identity(sizeof(script_step_topicdiscussionst), &allocator_fn<script_step_topicdiscussionst>, "script_step_topicdiscussionst",NULL,&script_stepst::_identity,NULL);
  #define CUR_STRUCT script_stepst
  static const struct_field_info script_stepst_fields[] = {
    { FLD(PRIMITIVE, next_step_idx), TID(int32_t) },
    { METHOD(OBJ_METHOD, setNextStep) },
    { METHOD(OBJ_METHOD, execute) },
    { METHOD(OBJ_METHOD, skip) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity script_stepst::_identity(sizeof(script_stepst), &allocator_fn<script_stepst>, "script_stepst",NULL,NULL,script_stepst_fields);
  virtual_identity script_var_longst::_identity(sizeof(script_var_longst), &allocator_fn<script_var_longst>, "script_var_longst",NULL,&script_varst::_identity,NULL);
  virtual_identity script_var_unitst::_identity(sizeof(script_var_unitst), &allocator_fn<script_var_unitst>, "script_var_unitst",NULL,&script_varst::_identity,NULL);
  #define CUR_STRUCT script_varst
  static const struct_field_info script_varst_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { METHOD(OBJ_METHOD, instantiate) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity script_varst::_identity(sizeof(script_varst), &allocator_fn<script_varst>, "script_varst",NULL,NULL,script_varst_fields);
  #define CUR_STRUCT site_building_item
  static const struct_field_info site_building_item_fields[] = {
    { FLD(PRIMITIVE, race), TID(int32_t) },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity site_building_item::_identity(sizeof(site_building_item), &allocator_fn<site_building_item>, NULL, "site_building_item",NULL,site_building_item_fields);
  #define CUR_STRUCT site_realization_building::T_unk_4c
  static const struct_field_info site_realization_building_doT_Dot_T_unk_4c_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, owner), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity site_realization_building::T_unk_4c::_identity(sizeof(site_realization_building::T_unk_4c), &allocator_fn<site_realization_building::T_unk_4c>, &site_realization_building::_identity, "T_unk_4c",NULL,site_realization_building_doT_Dot_T_unk_4c_fields);
  #define CUR_STRUCT site_realization_building
  static const struct_field_info site_realization_building_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, type), TID(site_realization_building_type) },
    { FLD(PRIMITIVE, min_x), TID(int32_t) },
    { FLD(PRIMITIVE, min_y), TID(int32_t) },
    { FLD(PRIMITIVE, max_x), TID(int32_t) },
    { FLD(PRIMITIVE, max_y), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, inhabitants), identity_traits<df::world_site_inhabitant >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_2c), TID(int32_t) },
    { FLD(SUBSTRUCT, item), &site_building_item::_identity },
    { FLD(PRIMITIVE, abstract_building_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_44), TID(int32_t) },
    { FLD(POINTER, building_info), identity_traits<df::site_realization_building_infost >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_4c), &site_realization_building::T_unk_4c::_identity, 0, NULL },
    { FLD(PRIMITIVE, unk_5c), TID(int32_t) },
    { FLD(CONTAINER, unk_60), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_v40_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity site_realization_building::_identity(sizeof(site_realization_building), &allocator_fn<site_realization_building>, NULL, "site_realization_building",NULL,site_realization_building_fields);
  virtual_identity site_realization_building_info_castle_courtyardst::_identity(sizeof(site_realization_building_info_castle_courtyardst), &allocator_fn<site_realization_building_info_castle_courtyardst>, "site_realization_building_info_castle_courtyardst",NULL,&site_realization_building_infost::_identity,NULL);
  #define CUR_STRUCT site_realization_building_info_castle_towerst
  static const struct_field_info site_realization_building_info_castle_towerst_fields[] = {
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(SUBSTRUCT, item1), &site_building_item::_identity },
    { FLD(SUBSTRUCT, item2), &site_building_item::_identity },
    { FLD(PRIMITIVE, unk_3c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_40), TID(int32_t) },
    { FLD(PRIMITIVE, unk_44), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity site_realization_building_info_castle_towerst::_identity(sizeof(site_realization_building_info_castle_towerst), &allocator_fn<site_realization_building_info_castle_towerst>, "site_realization_building_info_castle_towerst",NULL,&site_realization_building_infost::_identity,site_realization_building_info_castle_towerst_fields);
  #define CUR_STRUCT site_realization_building_info_castle_wallst
  static const struct_field_info site_realization_building_info_castle_wallst_fields[] = {
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_20), TID(int32_t) },
    { FLD(SUBSTRUCT, item1), &site_building_item::_identity },
    { FLD(SUBSTRUCT, item2), &site_building_item::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity site_realization_building_info_castle_wallst::_identity(sizeof(site_realization_building_info_castle_wallst), &allocator_fn<site_realization_building_info_castle_wallst>, "site_realization_building_info_castle_wallst",NULL,&site_realization_building_infost::_identity,site_realization_building_info_castle_wallst_fields);
  #define CUR_STRUCT site_realization_building_info_hillock_housest
  static const struct_field_info site_realization_building_info_hillock_housest_fields[] = {
    { FLD(PRIMITIVE, type), TID(hillock_house_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity site_realization_building_info_hillock_housest::_identity(sizeof(site_realization_building_info_hillock_housest), &allocator_fn<site_realization_building_info_hillock_housest>, "site_realization_building_info_hillock_housest",NULL,&site_realization_building_infost::_identity,site_realization_building_info_hillock_housest_fields);
  #define CUR_STRUCT site_realization_building_info_market_squarest
  static const struct_field_info site_realization_building_info_market_squarest_fields[] = {
    { FLD(PRIMITIVE, type), TID(site_shop_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity site_realization_building_info_market_squarest::_identity(sizeof(site_realization_building_info_market_squarest), &allocator_fn<site_realization_building_info_market_squarest>, "site_realization_building_info_market_squarest",NULL,&site_realization_building_infost::_identity,site_realization_building_info_market_squarest_fields);
  #define CUR_STRUCT site_realization_building_info_shop_housest
  static const struct_field_info site_realization_building_info_shop_housest_fields[] = {
    { FLD(PRIMITIVE, type), TID(site_shop_type) },
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity site_realization_building_info_shop_housest::_identity(sizeof(site_realization_building_info_shop_housest), &allocator_fn<site_realization_building_info_shop_housest>, "site_realization_building_info_shop_housest",NULL,&site_realization_building_infost::_identity,site_realization_building_info_shop_housest_fields);
  #define CUR_STRUCT site_realization_building_info_tree_housest
  static const struct_field_info site_realization_building_info_tree_housest_fields[] = {
    { FLD(PRIMITIVE, type), TID(tree_house_type) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity site_realization_building_info_tree_housest::_identity(sizeof(site_realization_building_info_tree_housest), &allocator_fn<site_realization_building_info_tree_housest>, "site_realization_building_info_tree_housest",NULL,&site_realization_building_infost::_identity,site_realization_building_info_tree_housest_fields);
  #define CUR_STRUCT site_realization_building_info_trenchesst::T_unk_8
  static const struct_field_info site_realization_building_info_trenchesst_doT_Dot_T_unk_8_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity site_realization_building_info_trenchesst::T_unk_8::_identity(sizeof(site_realization_building_info_trenchesst::T_unk_8), &allocator_fn<site_realization_building_info_trenchesst::T_unk_8>, &site_realization_building_info_trenchesst::_identity, "T_unk_8",NULL,site_realization_building_info_trenchesst_doT_Dot_T_unk_8_fields);
  #define CUR_STRUCT site_realization_building_info_trenchesst
  static const struct_field_info site_realization_building_info_trenchesst_fields[] = {
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(STATIC_ARRAY, unk_8), &site_realization_building_info_trenchesst::T_unk_8::_identity, 4, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity site_realization_building_info_trenchesst::_identity(sizeof(site_realization_building_info_trenchesst), &allocator_fn<site_realization_building_info_trenchesst>, "site_realization_building_info_trenchesst",NULL,&site_realization_building_infost::_identity,site_realization_building_info_trenchesst_fields);
  #define CUR_STRUCT site_realization_building_infost
  static const struct_field_info site_realization_building_infost_fields[] = {
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity site_realization_building_infost::_identity(sizeof(site_realization_building_infost), &allocator_fn<site_realization_building_infost>, "site_realization_building_infost",NULL,NULL,site_realization_building_infost_fields);
  #define CUR_STRUCT site_realization_crossroads
  static const struct_field_info site_realization_crossroads_fields[] = {
    { FLD(STATIC_ARRAY, road_min_y), identity_traits<int32_t >::get(), 48, NULL },
    { FLD(STATIC_ARRAY, road_max_y), identity_traits<int32_t >::get(), 48, NULL },
    { FLD(STATIC_ARRAY, road_min_x), identity_traits<int32_t >::get(), 48, NULL },
    { FLD(STATIC_ARRAY, road_max_x), identity_traits<int32_t >::get(), 48, NULL },
    { FLD(PRIMITIVE, idx_x), TID(int32_t) },
    { FLD(PRIMITIVE, idx_y), TID(int32_t) },
    { FLD(PRIMITIVE, tile_width), TID(int32_t) },
    { FLD(PRIMITIVE, tile_height), TID(int32_t) },
    { FLD(PRIMITIVE, unk_310), TID(int32_t) },
    { FLD(PRIMITIVE, unk_314), TID(int32_t) },
    { FLD(PRIMITIVE, unk_318), TID(int32_t) },
    { FLD(PRIMITIVE, unk_31c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_320), TID(int32_t) },
    { FLD(PRIMITIVE, unk_324), TID(int32_t) },
    { FLD(PRIMITIVE, unk_328), TID(int32_t) },
    { FLD(PRIMITIVE, unk_32c), TID(int32_t) },
    { FLD(PRIMITIVE, center_x_tile), TID(int32_t) },
    { FLD(PRIMITIVE, center_y_tile), TID(int32_t) },
    { FLD(POINTER, up), identity_traits<df::site_realization_crossroads >::get(), 0, NULL },
    { FLD(POINTER, down), identity_traits<df::site_realization_crossroads >::get(), 0, NULL },
    { FLD(POINTER, right), identity_traits<df::site_realization_crossroads >::get(), 0, NULL },
    { FLD(POINTER, left), identity_traits<df::site_realization_crossroads >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_348), TID(int8_t) },
    { FLD(PRIMITIVE, unk_349), TID(int8_t) },
    { FLD(PRIMITIVE, unk_34c), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(PRIMITIVE, anon_2), TID(int8_t) },
    { FLD(PRIMITIVE, anon_3), TID(int8_t) },
    { FLD(PRIMITIVE, anon_4), TID(int8_t) },
    { FLD(PRIMITIVE, anon_5), TID(int8_t) },
    { FLD(PRIMITIVE, anon_6), TID(int8_t) },
    { FLD(STATIC_ARRAY, unk_356), identity_traits<df::coord >::get(), 32, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity site_realization_crossroads::_identity(sizeof(site_realization_crossroads), &allocator_fn<site_realization_crossroads>, NULL, "site_realization_crossroads",NULL,site_realization_crossroads_fields);
  #define CUR_STRUCT enum_traits<skill_rating>::attr_entry_type
  static const struct_field_info enum_traits_lT_skill_rating_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, xp_threshold), identity_traits<uint32_t>::get() },
    { FLD(PRIMITIVE, caption), identity_traits<const char*>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<skill_rating>::attr_entry_type::_identity(sizeof(enum_traits<skill_rating>::attr_entry_type), NULL, TID(skill_rating), "_attr_entry_type", NULL, enum_traits_lT_skill_rating_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT spatter
  static const struct_field_info spatter_fields[] = {
    { FLD(PRIMITIVE, body_part_id), TID(int16_t) },
    { FLD(SUBSTRUCT, flags), TID(spatter::T_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity spatter::_identity(sizeof(spatter), &allocator_fn<spatter>, NULL, "spatter",&spatter_common::_identity,spatter_fields);
  #define CUR_STRUCT spatter_common
  static const struct_field_info spatter_common_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, mat_state), TID(matter_state) },
    { FLD(SUBSTRUCT, temperature), &temperaturest::_identity },
    { FLD(PRIMITIVE, size), TID(int32_t) },
    { FLD(SUBSTRUCT, base_flags), TID(spatter_common::T_base_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity spatter_common::_identity(sizeof(spatter_common), &allocator_fn<spatter_common>, NULL, "spatter_common",NULL,spatter_common_fields);
  #define CUR_STRUCT special_mat_table
  static const struct_field_info special_mat_table_fields[] = {
    { FLD(STATIC_ARRAY, organic_types), identity_traits<std::vector<int16_t > >::get(), 37, TID(organic_mat_category) },
    { FLD(STATIC_ARRAY, organic_indexes), identity_traits<std::vector<int32_t > >::get(), 37, TID(organic_mat_category) },
    { FLD(STATIC_ARRAY, organic_unknown), identity_traits<std::vector<int32_t > >::get(), 37, TID(organic_mat_category) },
    { FLD(STATIC_ARRAY, builtin), identity_traits<df::material* >::get(), 659, TID(builtin_mats) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity special_mat_table::_identity(sizeof(special_mat_table), &allocator_fn<special_mat_table>, NULL, "special_mat_table",NULL,special_mat_table_fields);
  #define CUR_STRUCT specific_ref::T_arg2
  static const struct_field_info specific_ref_doT_Dot_T_arg2_fields[] = {
    { FLD(POINTER, wrestle), identity_traits<df::unit_item_wrestle >::get(), 2, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<specific_ref::T_arg2>::identity(sizeof(specific_ref::T_arg2), &allocator_fn<specific_ref::T_arg2>, &specific_ref::_identity, "T_arg2", NULL, specific_ref_doT_Dot_T_arg2_fields);
  #define CUR_STRUCT specific_ref
  static const struct_field_info specific_ref_fields[] = {
    { FLD(PRIMITIVE, type), TID(specific_ref_type) },
    { FLD(POINTER, object), NULL, 2, NULL },
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 2, NULL },
    { FLD(POINTER, activity), identity_traits<df::activity_info >::get(), 2, NULL },
    { FLD(POINTER, screen), identity_traits<df::viewscreen >::get(), 2, NULL },
    { FLD(POINTER, vermin), identity_traits<df::vermin >::get(), 2, NULL },
    { FLD(POINTER, effect), identity_traits<df::effect_info >::get(), 2, NULL },
    { FLD(POINTER, job), identity_traits<df::job >::get(), 2, NULL },
    { FLD(SUBSTRUCT, arg2), TID(specific_ref::T_arg2) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity specific_ref::_identity(sizeof(specific_ref), &allocator_fn<specific_ref>, NULL, "specific_ref",NULL,specific_ref_fields);
  #define CUR_STRUCT squad::T_rooms
  static const struct_field_info squad_doT_Dot_T_rooms_fields[] = {
    { FLD(PRIMITIVE, building_id), TID(int32_t) },
    { FLD(SUBSTRUCT, mode), TID(squad_use_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity squad::T_rooms::_identity(sizeof(squad::T_rooms), &allocator_fn<squad::T_rooms>, &squad::_identity, "T_rooms",NULL,squad_doT_Dot_T_rooms_fields);
  #define CUR_STRUCT squad
  static const struct_field_info squad_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, alias), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, positions), identity_traits<df::squad_position >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, orders), identity_traits<df::squad_order >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, schedule), identity_traits<df::squad::T_schedule >::get(), 0, NULL },
    { FLD(PRIMITIVE, cur_alert_idx), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, rooms), &squad::T_rooms::_identity, 0, NULL },
    { FLD(CONTAINER, rack_combat), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, rack_training), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, uniform_priority), TID(int32_t) },
    { FLD(PRIMITIVE, activity), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, ammunition), identity_traits<df::squad_ammo_spec >::get(), 0, NULL },
    { FLD(CONTAINER, train_weapon_free), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, train_weapon_inuse), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, ammo_items), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, ammo_units), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, carry_food), TID(int16_t) },
    { FLD(PRIMITIVE, carry_water), TID(int16_t) },
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, leader_position), TID(int32_t) },
    { FLD(PRIMITIVE, leader_assignment), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity squad::_identity(sizeof(squad), &allocator_fn<squad>, NULL, "squad",NULL,squad_fields);
  #define CUR_STRUCT squad_ammo_spec
  static const struct_field_info squad_ammo_spec_fields[] = {
    { FLD(SUBSTRUCT, item_filter), &item_filter_spec::_identity },
    { FLD(PRIMITIVE, amount), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(squad_ammo_spec::T_flags) },
    { FLD(CONTAINER, assigned), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity squad_ammo_spec::_identity(sizeof(squad_ammo_spec), &allocator_fn<squad_ammo_spec>, NULL, "squad_ammo_spec",NULL,squad_ammo_spec_fields);
  #define CUR_STRUCT squad_order
  static const struct_field_info squad_order_fields[] = {
    { FLD(PRIMITIVE, unk_v40_1), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_2), TID(int32_t) },
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, year_tick), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_3), TID(int32_t) },
    { METHOD(OBJ_METHOD, clone) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, isPatrol) },
    { METHOD(OBJ_METHOD, offsetPosition) },
    { METHOD(OBJ_METHOD, process) },
    { METHOD(OBJ_METHOD, reasonCannot) },
    { METHOD(OBJ_METHOD, decUniformLock) },
    { METHOD(OBJ_METHOD, isFulfilled) },
    { METHOD(OBJ_METHOD, getTargetUnits) },
    { METHOD(OBJ_METHOD, getUniformType) },
    { METHOD(OBJ_METHOD, getDescription) },
    { METHOD(OBJ_METHOD, isInactive) },
    { METHOD(OBJ_METHOD, isCombat) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity squad_order::_identity(sizeof(squad_order), &allocator_fn<squad_order>, "squad_order","squad_orderst",NULL,squad_order_fields);
  #define CUR_STRUCT squad_order_cause_trouble_for_entityst
  static const struct_field_info squad_order_cause_trouble_for_entityst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity squad_order_cause_trouble_for_entityst::_identity(sizeof(squad_order_cause_trouble_for_entityst), &allocator_fn<squad_order_cause_trouble_for_entityst>, "squad_order_cause_trouble_for_entityst",NULL,&squad_order::_identity,squad_order_cause_trouble_for_entityst_fields);
  #define CUR_STRUCT squad_order_defend_burrowsst
  static const struct_field_info squad_order_defend_burrowsst_fields[] = {
    { FLD(CONTAINER, burrows), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity squad_order_defend_burrowsst::_identity(sizeof(squad_order_defend_burrowsst), &allocator_fn<squad_order_defend_burrowsst>, "squad_order_defend_burrowsst",NULL,&squad_order::_identity,squad_order_defend_burrowsst_fields);
  #define CUR_STRUCT squad_order_drive_entity_off_sitest
  static const struct_field_info squad_order_drive_entity_off_sitest_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity squad_order_drive_entity_off_sitest::_identity(sizeof(squad_order_drive_entity_off_sitest), &allocator_fn<squad_order_drive_entity_off_sitest>, "squad_order_drive_entity_off_sitest",NULL,&squad_order::_identity,squad_order_drive_entity_off_sitest_fields);
  #define CUR_STRUCT squad_order_kill_listst
  static const struct_field_info squad_order_kill_listst_fields[] = {
    { FLD(CONTAINER, units), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, histfigs), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, title), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity squad_order_kill_listst::_identity(sizeof(squad_order_kill_listst), &allocator_fn<squad_order_kill_listst>, "squad_order_kill_listst",NULL,&squad_order::_identity,squad_order_kill_listst_fields);
  #define CUR_STRUCT squad_order_movest
  static const struct_field_info squad_order_movest_fields[] = {
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(PRIMITIVE, point_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity squad_order_movest::_identity(sizeof(squad_order_movest), &allocator_fn<squad_order_movest>, "squad_order_movest",NULL,&squad_order::_identity,squad_order_movest_fields);
  #define CUR_STRUCT squad_order_patrol_routest
  static const struct_field_info squad_order_patrol_routest_fields[] = {
    { FLD(PRIMITIVE, route_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity squad_order_patrol_routest::_identity(sizeof(squad_order_patrol_routest), &allocator_fn<squad_order_patrol_routest>, "squad_order_patrol_routest",NULL,&squad_order::_identity,squad_order_patrol_routest_fields);
  virtual_identity squad_order_trainst::_identity(sizeof(squad_order_trainst), &allocator_fn<squad_order_trainst>, "squad_order_trainst",NULL,&squad_order::_identity,NULL);
  #define CUR_STRUCT squad_position
  static const struct_field_info squad_position_fields[] = {
    { FLD(PRIMITIVE, occupant), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, orders), identity_traits<df::squad_order >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, preferences), identity_traits<std::vector<int32_t > >::get(), 4, TID(barrack_preference_category) },
    { FLD(STATIC_ARRAY, uniform), identity_traits<std::vector<df::squad_uniform_spec* > >::get(), 7, TID(uniform_category) },
    { FLD(PRIMITIVE, unk_c4), identity_traits<std::string >::get() },
    { FLD(SUBSTRUCT, flags), TID(uniform_flags) },
    { FLD(CONTAINER, assigned_items), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, quiver), TID(int32_t) },
    { FLD(PRIMITIVE, backpack), TID(int32_t) },
    { FLD(PRIMITIVE, flask), TID(int32_t) },
    { FLD(STATIC_ARRAY, activities), identity_traits<int32_t >::get(), 3, TID(squad_event_type) },
    { FLD(STATIC_ARRAY, events), identity_traits<int32_t >::get(), 3, TID(squad_event_type) },
    { FLD(PRIMITIVE, unk_118), TID(int32_t) },
    { FLD(PRIMITIVE, unk_11c), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity squad_position::_identity(sizeof(squad_position), &allocator_fn<squad_position>, NULL, "squad_position",NULL,squad_position_fields);
  #define CUR_STRUCT squad_schedule_entry
  static const struct_field_info squad_schedule_entry_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, sleep_mode), TID(int16_t) },
    { FLD(PRIMITIVE, uniform_mode), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, orders), identity_traits<df::squad_schedule_order >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, order_assignments), identity_traits<int32_t >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity squad_schedule_entry::_identity(sizeof(squad_schedule_entry), &allocator_fn<squad_schedule_entry>, NULL, "squad_schedule_entry",NULL,squad_schedule_entry_fields);
  #define CUR_STRUCT squad_schedule_order
  static const struct_field_info squad_schedule_order_fields[] = {
    { FLD(POINTER, order), identity_traits<df::squad_order >::get(), 0, NULL },
    { FLD(PRIMITIVE, min_count), TID(int32_t) },
    { FLD(CONTAINER, positions), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity squad_schedule_order::_identity(sizeof(squad_schedule_order), &allocator_fn<squad_schedule_order>, NULL, "squad_schedule_order",NULL,squad_schedule_order_fields);
  #define CUR_STRUCT squad_uniform_spec
  static const struct_field_info squad_uniform_spec_fields[] = {
    { FLD(PRIMITIVE, item), TID(int32_t) },
    { FLD(SUBSTRUCT, item_filter), &item_filter_spec::_identity },
    { FLD(PRIMITIVE, color), TID(int32_t) },
    { FLD(CONTAINER, assigned), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, indiv_choice), TID(uniform_indiv_choice) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity squad_uniform_spec::_identity(sizeof(squad_uniform_spec), &allocator_fn<squad_uniform_spec>, NULL, "squad_uniform_spec",NULL,squad_uniform_spec_fields);
  #define CUR_STRUCT stockpile_links
  static const struct_field_info stockpile_links_fields[] = {
    { FLD(STL_VECTOR_PTR, give_to_pile), identity_traits<df::building >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, take_from_pile), identity_traits<df::building >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, give_to_workshop), identity_traits<df::building >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, take_from_workshop), identity_traits<df::building >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_links::_identity(sizeof(stockpile_links), &allocator_fn<stockpile_links>, NULL, "stockpile_links",NULL,stockpile_links_fields);
  #define CUR_STRUCT enum_traits<stockpile_list>::attr_entry_type
  static const struct_field_info enum_traits_lT_stockpile_list_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, is_category), identity_traits<bool>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<stockpile_list>::attr_entry_type::_identity(sizeof(enum_traits<stockpile_list>::attr_entry_type), NULL, TID(stockpile_list), "_attr_entry_type", NULL, enum_traits_lT_stockpile_list_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT stockpile_settings::T_animals
  static const struct_field_info stockpile_settings_doT_Dot_T_animals_fields[] = {
    { FLD(PRIMITIVE, empty_cages), TID(bool) },
    { FLD(PRIMITIVE, empty_traps), TID(bool) },
    { FLD(CONTAINER, enabled), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_animals::_identity(sizeof(stockpile_settings::T_animals), &allocator_fn<stockpile_settings::T_animals>, &stockpile_settings::_identity, "T_animals",NULL,stockpile_settings_doT_Dot_T_animals_fields);
  #define CUR_STRUCT stockpile_settings::T_food
  static const struct_field_info stockpile_settings_doT_Dot_T_food_fields[] = {
    { FLD(CONTAINER, meat), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, fish), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, unprepared_fish), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, egg), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, plants), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, drink_plant), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, drink_animal), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, cheese_plant), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, cheese_animal), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, seeds), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, leaves), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, powder_plant), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, powder_creature), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, glob), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, glob_paste), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, glob_pressed), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, liquid_plant), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, liquid_animal), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, liquid_misc), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(PRIMITIVE, prepared_meals), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_food::_identity(sizeof(stockpile_settings::T_food), &allocator_fn<stockpile_settings::T_food>, &stockpile_settings::_identity, "T_food",NULL,stockpile_settings_doT_Dot_T_food_fields);
  #define CUR_STRUCT stockpile_settings::T_furniture
  static const struct_field_info stockpile_settings_doT_Dot_T_furniture_fields[] = {
    { FLD(CONTAINER, type), identity_traits<std::vector<char > >::get(), 0, TID(furniture_type) },
    { FLD(CONTAINER, other_mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, quality_core), identity_traits<bool >::get(), 7, TID(item_quality) },
    { FLD(STATIC_ARRAY, quality_total), identity_traits<bool >::get(), 7, TID(item_quality) },
    { FLD(PRIMITIVE, sand_bags), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_furniture::_identity(sizeof(stockpile_settings::T_furniture), &allocator_fn<stockpile_settings::T_furniture>, &stockpile_settings::_identity, "T_furniture",NULL,stockpile_settings_doT_Dot_T_furniture_fields);
  #define CUR_STRUCT stockpile_settings::T_refuse
  static const struct_field_info stockpile_settings_doT_Dot_T_refuse_fields[] = {
    { FLD(CONTAINER, type), identity_traits<std::vector<char > >::get(), 0, TID(item_type) },
    { FLD(CONTAINER, corpses), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, body_parts), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, skulls), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, bones), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, hair), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, shells), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, teeth), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, horns), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(PRIMITIVE, fresh_raw_hide), TID(bool) },
    { FLD(PRIMITIVE, rotten_raw_hide), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_refuse::_identity(sizeof(stockpile_settings::T_refuse), &allocator_fn<stockpile_settings::T_refuse>, &stockpile_settings::_identity, "T_refuse",NULL,stockpile_settings_doT_Dot_T_refuse_fields);
  #define CUR_STRUCT stockpile_settings::T_stone
  static const struct_field_info stockpile_settings_doT_Dot_T_stone_fields[] = {
    { FLD(CONTAINER, mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_stone::_identity(sizeof(stockpile_settings::T_stone), &allocator_fn<stockpile_settings::T_stone>, &stockpile_settings::_identity, "T_stone",NULL,stockpile_settings_doT_Dot_T_stone_fields);
  #define CUR_STRUCT stockpile_settings::T_ore
  static const struct_field_info stockpile_settings_doT_Dot_T_ore_fields[] = {
    { FLD(CONTAINER, mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_ore::_identity(sizeof(stockpile_settings::T_ore), &allocator_fn<stockpile_settings::T_ore>, &stockpile_settings::_identity, "T_ore",NULL,stockpile_settings_doT_Dot_T_ore_fields);
  #define CUR_STRUCT stockpile_settings::T_ammo
  static const struct_field_info stockpile_settings_doT_Dot_T_ammo_fields[] = {
    { FLD(CONTAINER, type), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, other_mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, quality_core), identity_traits<bool >::get(), 7, TID(item_quality) },
    { FLD(STATIC_ARRAY, quality_total), identity_traits<bool >::get(), 7, TID(item_quality) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_ammo::_identity(sizeof(stockpile_settings::T_ammo), &allocator_fn<stockpile_settings::T_ammo>, &stockpile_settings::_identity, "T_ammo",NULL,stockpile_settings_doT_Dot_T_ammo_fields);
  #define CUR_STRUCT stockpile_settings::T_coins
  static const struct_field_info stockpile_settings_doT_Dot_T_coins_fields[] = {
    { FLD(CONTAINER, mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_coins::_identity(sizeof(stockpile_settings::T_coins), &allocator_fn<stockpile_settings::T_coins>, &stockpile_settings::_identity, "T_coins",NULL,stockpile_settings_doT_Dot_T_coins_fields);
  #define CUR_STRUCT stockpile_settings::T_bars_blocks
  static const struct_field_info stockpile_settings_doT_Dot_T_bars_blocks_fields[] = {
    { FLD(CONTAINER, bars_other_mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, blocks_other_mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, bars_mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, blocks_mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_bars_blocks::_identity(sizeof(stockpile_settings::T_bars_blocks), &allocator_fn<stockpile_settings::T_bars_blocks>, &stockpile_settings::_identity, "T_bars_blocks",NULL,stockpile_settings_doT_Dot_T_bars_blocks_fields);
  #define CUR_STRUCT stockpile_settings::T_gems
  static const struct_field_info stockpile_settings_doT_Dot_T_gems_fields[] = {
    { FLD(CONTAINER, rough_other_mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, cut_other_mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, rough_mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, cut_mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_gems::_identity(sizeof(stockpile_settings::T_gems), &allocator_fn<stockpile_settings::T_gems>, &stockpile_settings::_identity, "T_gems",NULL,stockpile_settings_doT_Dot_T_gems_fields);
  #define CUR_STRUCT stockpile_settings::T_finished_goods
  static const struct_field_info stockpile_settings_doT_Dot_T_finished_goods_fields[] = {
    { FLD(CONTAINER, type), identity_traits<std::vector<char > >::get(), 0, TID(item_type) },
    { FLD(CONTAINER, other_mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, quality_core), identity_traits<bool >::get(), 7, TID(item_quality) },
    { FLD(STATIC_ARRAY, quality_total), identity_traits<bool >::get(), 7, TID(item_quality) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_finished_goods::_identity(sizeof(stockpile_settings::T_finished_goods), &allocator_fn<stockpile_settings::T_finished_goods>, &stockpile_settings::_identity, "T_finished_goods",NULL,stockpile_settings_doT_Dot_T_finished_goods_fields);
  #define CUR_STRUCT stockpile_settings::T_leather
  static const struct_field_info stockpile_settings_doT_Dot_T_leather_fields[] = {
    { FLD(CONTAINER, mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_leather::_identity(sizeof(stockpile_settings::T_leather), &allocator_fn<stockpile_settings::T_leather>, &stockpile_settings::_identity, "T_leather",NULL,stockpile_settings_doT_Dot_T_leather_fields);
  #define CUR_STRUCT stockpile_settings::T_cloth
  static const struct_field_info stockpile_settings_doT_Dot_T_cloth_fields[] = {
    { FLD(CONTAINER, thread_silk), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, thread_plant), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, thread_yarn), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, thread_metal), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, cloth_silk), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, cloth_plant), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, cloth_yarn), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, cloth_metal), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_cloth::_identity(sizeof(stockpile_settings::T_cloth), &allocator_fn<stockpile_settings::T_cloth>, &stockpile_settings::_identity, "T_cloth",NULL,stockpile_settings_doT_Dot_T_cloth_fields);
  #define CUR_STRUCT stockpile_settings::T_wood
  static const struct_field_info stockpile_settings_doT_Dot_T_wood_fields[] = {
    { FLD(CONTAINER, mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_wood::_identity(sizeof(stockpile_settings::T_wood), &allocator_fn<stockpile_settings::T_wood>, &stockpile_settings::_identity, "T_wood",NULL,stockpile_settings_doT_Dot_T_wood_fields);
  #define CUR_STRUCT stockpile_settings::T_weapons
  static const struct_field_info stockpile_settings_doT_Dot_T_weapons_fields[] = {
    { FLD(CONTAINER, weapon_type), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, trapcomp_type), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, other_mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, quality_core), identity_traits<bool >::get(), 7, TID(item_quality) },
    { FLD(STATIC_ARRAY, quality_total), identity_traits<bool >::get(), 7, TID(item_quality) },
    { FLD(PRIMITIVE, usable), TID(bool) },
    { FLD(PRIMITIVE, unusable), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_weapons::_identity(sizeof(stockpile_settings::T_weapons), &allocator_fn<stockpile_settings::T_weapons>, &stockpile_settings::_identity, "T_weapons",NULL,stockpile_settings_doT_Dot_T_weapons_fields);
  #define CUR_STRUCT stockpile_settings::T_armor
  static const struct_field_info stockpile_settings_doT_Dot_T_armor_fields[] = {
    { FLD(CONTAINER, body), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, head), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, feet), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, hands), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, legs), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, shield), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, other_mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, mats), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, quality_core), identity_traits<bool >::get(), 7, TID(item_quality) },
    { FLD(STATIC_ARRAY, quality_total), identity_traits<bool >::get(), 7, TID(item_quality) },
    { FLD(PRIMITIVE, usable), TID(bool) },
    { FLD(PRIMITIVE, unusable), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::T_armor::_identity(sizeof(stockpile_settings::T_armor), &allocator_fn<stockpile_settings::T_armor>, &stockpile_settings::_identity, "T_armor",NULL,stockpile_settings_doT_Dot_T_armor_fields);
  #define CUR_STRUCT stockpile_settings
  static const struct_field_info stockpile_settings_fields[] = {
    { FLD(SUBSTRUCT, flags), TID(stockpile_group_set) },
    { FLD(SUBSTRUCT, animals), &stockpile_settings::T_animals::_identity },
    { FLD(SUBSTRUCT, food), &stockpile_settings::T_food::_identity },
    { FLD(SUBSTRUCT, furniture), &stockpile_settings::T_furniture::_identity },
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD(SUBSTRUCT, refuse), &stockpile_settings::T_refuse::_identity },
    { FLD(SUBSTRUCT, stone), &stockpile_settings::T_stone::_identity },
    { FLD(SUBSTRUCT, ore), &stockpile_settings::T_ore::_identity },
    { FLD(SUBSTRUCT, ammo), &stockpile_settings::T_ammo::_identity },
    { FLD(SUBSTRUCT, coins), &stockpile_settings::T_coins::_identity },
    { FLD(SUBSTRUCT, bars_blocks), &stockpile_settings::T_bars_blocks::_identity },
    { FLD(SUBSTRUCT, gems), &stockpile_settings::T_gems::_identity },
    { FLD(SUBSTRUCT, finished_goods), &stockpile_settings::T_finished_goods::_identity },
    { FLD(SUBSTRUCT, leather), &stockpile_settings::T_leather::_identity },
    { FLD(SUBSTRUCT, cloth), &stockpile_settings::T_cloth::_identity },
    { FLD(SUBSTRUCT, wood), &stockpile_settings::T_wood::_identity },
    { FLD(SUBSTRUCT, weapons), &stockpile_settings::T_weapons::_identity },
    { FLD(SUBSTRUCT, armor), &stockpile_settings::T_armor::_identity },
    { FLD(PRIMITIVE, allow_organic), TID(bool) },
    { FLD(PRIMITIVE, allow_inorganic), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stockpile_settings::_identity(sizeof(stockpile_settings), &allocator_fn<stockpile_settings>, NULL, "stockpile_settings",NULL,stockpile_settings_fields);
  #define CUR_STRUCT stop_depart_condition
  static const struct_field_info stop_depart_condition_fields[] = {
    { FLD(PRIMITIVE, timeout), TID(int32_t) },
    { FLD(PRIMITIVE, direction), TID(stop_depart_condition::T_direction) },
    { FLD(PRIMITIVE, mode), TID(stop_depart_condition::T_mode) },
    { FLD(PRIMITIVE, load_percent), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(stop_depart_condition::T_flags) },
    { FLD(SUBSTRUCT, guide_path), &coord_path::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity stop_depart_condition::_identity(sizeof(stop_depart_condition), &allocator_fn<stop_depart_condition>, NULL, "stop_depart_condition",NULL,stop_depart_condition_fields);
  #define CUR_STRUCT syndrome
  static const struct_field_info syndrome_fields[] = {
    { FLD(PRIMITIVE, syn_name), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, ce), identity_traits<df::creature_interaction_effect >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, syn_affected_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, syn_affected_creature), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, syn_affected_caste), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, syn_immune_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, syn_immune_creature), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, syn_immune_caste), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, syn_class), identity_traits<std::string >::get(), 0, NULL },
    { FLD(SUBSTRUCT, flags), TID(syndrome_flags) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity syndrome::_identity(sizeof(syndrome), &allocator_fn<syndrome>, NULL, "syndrome",NULL,syndrome_fields);
  #define CUR_STRUCT talk_choice
  static const struct_field_info talk_choice_fields[] = {
    { FLD(PRIMITIVE, type), TID(talk_choice_type) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity talk_choice::_identity(sizeof(talk_choice), &allocator_fn<talk_choice>, NULL, "talk_choice",NULL,talk_choice_fields);
  #define CUR_STRUCT temperaturest
  static const struct_field_info temperaturest_fields[] = {
    { FLD(PRIMITIVE, whole), TID(uint16_t) },
    { FLD(PRIMITIVE, fraction), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity temperaturest::_identity(sizeof(temperaturest), &allocator_fn<temperaturest>, NULL, "temperaturest",NULL,temperaturest_fields);
  #define CUR_STRUCT texture_handler
  static const struct_field_info texture_handler_fields[] = {
    { FLD(STL_VECTOR_PTR, page), identity_traits<df::tile_page >::get(), 0, NULL },
    { FLD(CONTAINER, texpos), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, datapos), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity texture_handler::_identity(sizeof(texture_handler), &allocator_fn<texture_handler>, NULL, "texture_handler",NULL,texture_handler_fields);
  #define CUR_STRUCT tile_bitmask
  static const struct_field_info tile_bitmask_fields[] = {
    { FLD(STATIC_ARRAY, bits), identity_traits<uint16_t >::get(), 16, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity tile_bitmask::_identity(sizeof(tile_bitmask), &allocator_fn<tile_bitmask>, NULL, "tile_bitmask",NULL,tile_bitmask_fields);
  #define CUR_STRUCT tile_page
  static const struct_field_info tile_page_fields[] = {
    { FLD(PRIMITIVE, token), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, filename), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, tile_dim_x), TID(int16_t) },
    { FLD(PRIMITIVE, tile_dim_y), TID(int16_t) },
    { FLD(PRIMITIVE, page_dim_x), TID(int16_t) },
    { FLD(PRIMITIVE, page_dim_y), TID(int16_t) },
    { FLD(CONTAINER, texpos), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, datapos), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, texpos_gs), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, datapos_gs), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, loaded), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity tile_page::_identity(sizeof(tile_page), &allocator_fn<tile_page>, NULL, "tile_page",NULL,tile_page_fields);
  #define CUR_STRUCT enum_traits<tiletype>::attr_entry_type
  static const struct_field_info enum_traits_lT_tiletype_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, caption), identity_traits<const char*>::get() },
    { FLD(PRIMITIVE, shape), identity_traits<df::tiletype_shape>::get() },
    { FLD(PRIMITIVE, material), identity_traits<df::tiletype_material>::get() },
    { FLD(PRIMITIVE, variant), identity_traits<df::tiletype_variant>::get() },
    { FLD(PRIMITIVE, special), identity_traits<df::tiletype_special>::get() },
    { FLD(PRIMITIVE, direction), identity_traits<const char*>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<tiletype>::attr_entry_type::_identity(sizeof(enum_traits<tiletype>::attr_entry_type), NULL, TID(tiletype), "_attr_entry_type", NULL, enum_traits_lT_tiletype_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT enum_traits<tiletype_material>::attr_entry_type
  static const struct_field_info enum_traits_lT_tiletype_material_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, caption), identity_traits<const char*>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<tiletype_material>::attr_entry_type::_identity(sizeof(enum_traits<tiletype_material>::attr_entry_type), NULL, TID(tiletype_material), "_attr_entry_type", NULL, enum_traits_lT_tiletype_material_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT enum_traits<tiletype_shape>::attr_entry_type
  static const struct_field_info enum_traits_lT_tiletype_shape_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, caption), identity_traits<const char*>::get() },
    { FLD(PRIMITIVE, basic_shape), identity_traits<df::tiletype_shape_basic>::get() },
    { FLD(PRIMITIVE, passable_low), identity_traits<bool>::get() },
    { FLD(PRIMITIVE, passable_high), identity_traits<bool>::get() },
    { FLD(PRIMITIVE, passable_flow), identity_traits<bool>::get() },
    { FLD(PRIMITIVE, passable_flow_down), identity_traits<bool>::get() },
    { FLD(PRIMITIVE, walkable), identity_traits<bool>::get() },
    { FLD(PRIMITIVE, walkable_up), identity_traits<bool>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<tiletype_shape>::attr_entry_type::_identity(sizeof(enum_traits<tiletype_shape>::attr_entry_type), NULL, TID(tiletype_shape), "_attr_entry_type", NULL, enum_traits_lT_tiletype_shape_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT enum_traits<tiletype_special>::attr_entry_type
  static const struct_field_info enum_traits_lT_tiletype_special_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, caption), identity_traits<const char*>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<tiletype_special>::attr_entry_type::_identity(sizeof(enum_traits<tiletype_special>::attr_entry_type), NULL, TID(tiletype_special), "_attr_entry_type", NULL, enum_traits_lT_tiletype_special_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT timed_event
  static const struct_field_info timed_event_fields[] = {
    { FLD(PRIMITIVE, type), TID(timed_event_type) },
    { FLD(PRIMITIVE, season), TID(int8_t) },
    { FLD(PRIMITIVE, season_ticks), TID(int16_t) },
    { FLD(POINTER, entity), identity_traits<df::historical_entity >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int16_t) },
    { FLD(PRIMITIVE, anon_4), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity timed_event::_identity(sizeof(timed_event), &allocator_fn<timed_event>, NULL, "timed_event",NULL,timed_event_fields);
  #define CUR_STRUCT tissue
  static const struct_field_info tissue_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::tissue_flags> >::get(), 0, TID(tissue_flags) },
    { FLD(PRIMITIVE, tissue_name_singular), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, tissue_name_plural), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, tissue_material_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, relative_thickness), TID(int32_t) },
    { FLD(PRIMITIVE, healing_rate), TID(int32_t) },
    { FLD(PRIMITIVE, vascular), TID(int32_t) },
    { FLD(PRIMITIVE, pain_receptors), TID(int32_t) },
    { FLD(PRIMITIVE, tissue_shape), TID(int16_t) },
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD(PRIMITIVE, insulation), TID(int16_t) },
    { FLD(PRIMITIVE, subordinate_to_tissue), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, parent_tissue), TID(int32_t) },
    { FLD(PRIMITIVE, tissue_mat_state), TID(matter_state) },
    { FLD(PRIMITIVE, heatdam_point), TID(uint16_t) },
    { FLD(PRIMITIVE, colddam_point), TID(uint16_t) },
    { FLD(PRIMITIVE, ignite_point), TID(uint16_t) },
    { FLD(PRIMITIVE, melting_point), TID(uint16_t) },
    { FLD(PRIMITIVE, boiling_point), TID(uint16_t) },
    { FLD(PRIMITIVE, spec_heat), TID(uint16_t) },
    { FLD(PRIMITIVE, tissue_shape_str), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity tissue::_identity(sizeof(tissue), &allocator_fn<tissue>, NULL, "tissue",NULL,tissue_fields);
  #define CUR_STRUCT tissue_style_raw
  static const struct_field_info tissue_style_raw_fields[] = {
    { FLD(PRIMITIVE, token), identity_traits<std::string >::get() },
    { FLD(CONTAINER, part_idx), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, layer_idx), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, styles), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, list_idx), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, noun), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, word_type), identity_traits<enum_field<df::part_of_speech,int16_t> >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity tissue_style_raw::_identity(sizeof(tissue_style_raw), &allocator_fn<tissue_style_raw>, NULL, "tissue_style_raw",NULL,tissue_style_raw_fields);
  #define CUR_STRUCT tissue_template
  static const struct_field_info tissue_template_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::tissue_flags> >::get(), 0, TID(tissue_flags) },
    { FLD(PRIMITIVE, tissue_name_singular), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, tissue_name_plural), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, tissue_material_str), identity_traits<std::string >::get(), 3, NULL },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, relative_thickness), TID(int32_t) },
    { FLD(PRIMITIVE, healing_rate), TID(int32_t) },
    { FLD(PRIMITIVE, vascular), TID(int32_t) },
    { FLD(PRIMITIVE, pain_receptors), TID(int32_t) },
    { FLD(PRIMITIVE, tissue_shape), TID(int16_t) },
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD(PRIMITIVE, insulation), TID(int16_t) },
    { FLD(PRIMITIVE, subordinate_to_tissue), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, tissue_mat_state), TID(matter_state) },
    { FLD(PRIMITIVE, tissue_shape_str), identity_traits<std::string >::get() },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity tissue_template::_identity(sizeof(tissue_template), &allocator_fn<tissue_template>, NULL, "tissue_template",NULL,tissue_template_fields);
  #define CUR_STRUCT training_assignment
  static const struct_field_info training_assignment_fields[] = {
    { FLD(PRIMITIVE, animal_id), TID(int32_t) },
    { FLD(PRIMITIVE, trainer_id), TID(int32_t) },
    { FLD(PRIMITIVE, auto_mode), TID(training_assignment::T_auto_mode) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity training_assignment::_identity(sizeof(training_assignment), &allocator_fn<training_assignment>, NULL, "training_assignment",NULL,training_assignment_fields);
  #define CUR_STRUCT ui::T_tax_collection
  static const struct_field_info ui_doT_Dot_T_tax_collection_fields[] = {
    { FLD(PRIMITIVE, state), TID(int16_t) },
    { FLD(PRIMITIVE, check_timer), TID(int32_t) },
    { FLD(CONTAINER, rooms), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, reach_room_timer), TID(int32_t) },
    { FLD(PRIMITIVE, tc_protect_timer), TID(int32_t) },
    { FLD(PRIMITIVE, guard1_reach_tc_timer), TID(int32_t) },
    { FLD(PRIMITIVE, guard2_reach_tc_timer), TID(int32_t) },
    { FLD(PRIMITIVE, collected), TID(int16_t) },
    { FLD(PRIMITIVE, quota), TID(int16_t) },
    { FLD(SUBSTRUCT, collector_pos), &coord::_identity },
    { FLD(STATIC_ARRAY, guard_pos_x), identity_traits<int16_t >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, guard_pos_y), identity_traits<int16_t >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, guard_pos_z), identity_traits<int16_t >::get(), 2, NULL },
    { FLD(POINTER, collector), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, guard1), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, guard2), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, guard_lack_complained), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_tax_collection::_identity(sizeof(ui::T_tax_collection), &allocator_fn<ui::T_tax_collection>, &ui::_identity, "T_tax_collection",NULL,ui_doT_Dot_T_tax_collection_fields);
  #define CUR_STRUCT ui::T_becoming_capital
  static const struct_field_info ui_doT_Dot_T_becoming_capital_fields[] = {
    { FLD(PRIMITIVE, desired_architecture), TID(int32_t) },
    { FLD(PRIMITIVE, desired_offerings), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_becoming_capital::_identity(sizeof(ui::T_becoming_capital), &allocator_fn<ui::T_becoming_capital>, &ui::_identity, "T_becoming_capital",NULL,ui_doT_Dot_T_becoming_capital_fields);
  #define CUR_STRUCT ui::T_invasions
  static const struct_field_info ui_doT_Dot_T_invasions_fields[] = {
    { FLD(STL_VECTOR_PTR, list), identity_traits<df::invasion_info >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_invasions::_identity(sizeof(ui::T_invasions), &allocator_fn<ui::T_invasions>, &ui::_identity, "T_invasions",NULL,ui_doT_Dot_T_invasions_fields);
  #define CUR_STRUCT ui::T_kitchen
  static const struct_field_info ui_doT_Dot_T_kitchen_fields[] = {
    { FLD(CONTAINER, item_types), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, item_subtypes), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mat_types), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mat_indices), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, exc_types), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_kitchen::_identity(sizeof(ui::T_kitchen), &allocator_fn<ui::T_kitchen>, &ui::_identity, "T_kitchen",NULL,ui_doT_Dot_T_kitchen_fields);
  #define CUR_STRUCT ui::T_economy_prices::T_price_adjustment
  static const struct_field_info ui_doT_Dot_T_economy_prices_doT_Dot_T_price_adjustment_fields[] = {
    { FLD(CONTAINER, general_items), identity_traits<std::vector<int32_t > >::get(), 0, TID(item_type) },
    { FLD(CONTAINER, weapons), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, armor), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, handwear), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, footwear), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, headwear), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, legwear), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, prepared_food), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, wood), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, thread_cloth), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, bone), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, tooth), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, horn), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pearl), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, shell), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, leather), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, silk), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, yarn), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, inorganic), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, meat), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, fish), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, plants), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, drinks), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, extract_animal), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, extract_plant), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mill_animal), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mill_plant), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, cheese_animal), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, cheese_plant), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, pets), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_economy_prices::T_price_adjustment::_identity(sizeof(ui::T_economy_prices::T_price_adjustment), &allocator_fn<ui::T_economy_prices::T_price_adjustment>, &ui::T_economy_prices::_identity, "T_price_adjustment",NULL,ui_doT_Dot_T_economy_prices_doT_Dot_T_price_adjustment_fields);
  #define CUR_STRUCT ui::T_economy_prices::T_price_setter
  static const struct_field_info ui_doT_Dot_T_economy_prices_doT_Dot_T_price_setter_fields[] = {
    { FLD(STL_VECTOR_PTR, general_items), identity_traits<df::unit >::get(), 0, TID(item_type) },
    { FLD(STL_VECTOR_PTR, weapons), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, armor), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, handwear), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, footwear), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, headwear), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, legwear), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, prepared_food), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, wood), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, thread_cloth), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bone), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, tooth), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, horn), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, pearl), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, shell), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, leather), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, silk), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, yarn), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, inorganic), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, meat), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, fish), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, plants), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, drinks), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, extract_animal), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, extract_plant), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, mill_animal), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, mill_plant), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, cheese_animal), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, cheese_plant), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, pets), identity_traits<df::unit >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_economy_prices::T_price_setter::_identity(sizeof(ui::T_economy_prices::T_price_setter), &allocator_fn<ui::T_economy_prices::T_price_setter>, &ui::T_economy_prices::_identity, "T_price_setter",NULL,ui_doT_Dot_T_economy_prices_doT_Dot_T_price_setter_fields);
  #define CUR_STRUCT ui::T_economy_prices
  static const struct_field_info ui_doT_Dot_T_economy_prices_fields[] = {
    { FLD(SUBSTRUCT, price_adjustment), &ui::T_economy_prices::T_price_adjustment::_identity },
    { FLD(SUBSTRUCT, price_setter), &ui::T_economy_prices::T_price_setter::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_economy_prices::_identity(sizeof(ui::T_economy_prices), &allocator_fn<ui::T_economy_prices>, &ui::_identity, "T_economy_prices",NULL,ui_doT_Dot_T_economy_prices_fields);
  #define CUR_STRUCT ui::T_stockpile
  static const struct_field_info ui_doT_Dot_T_stockpile_fields[] = {
    { FLD(PRIMITIVE, reserved_bins), TID(int32_t) },
    { FLD(PRIMITIVE, reserved_barrels), TID(int32_t) },
    { FLD(SUBSTRUCT, custom_settings), &stockpile_settings::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_stockpile::_identity(sizeof(ui::T_stockpile), &allocator_fn<ui::T_stockpile>, &ui::_identity, "T_stockpile",NULL,ui_doT_Dot_T_stockpile_fields);
  #define CUR_STRUCT ui::T_unk2a8c
  static const struct_field_info ui_doT_Dot_T_unk2a8c_fields[] = {
    { FLD(PRIMITIVE, unk1), TID(int16_t) },
    { FLD(PRIMITIVE, unk2), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_unk2a8c::_identity(sizeof(ui::T_unk2a8c), &allocator_fn<ui::T_unk2a8c>, &ui::_identity, "T_unk2a8c",NULL,ui_doT_Dot_T_unk2a8c_fields);
  #define CUR_STRUCT ui::T_map_edge
  static const struct_field_info ui_doT_Dot_T_map_edge_fields[] = {
    { FLD(STATIC_ARRAY, layer_x), identity_traits<std::vector<int16_t > >::get(), 5, NULL },
    { FLD(CONTAINER, surface_x), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, layer_y), identity_traits<std::vector<int16_t > >::get(), 5, NULL },
    { FLD(CONTAINER, surface_y), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, layer_z), identity_traits<std::vector<int16_t > >::get(), 5, NULL },
    { FLD(CONTAINER, surface_z), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_map_edge::_identity(sizeof(ui::T_map_edge), &allocator_fn<ui::T_map_edge>, &ui::_identity, "T_map_edge",NULL,ui_doT_Dot_T_map_edge_fields);
  #define CUR_STRUCT ui::T_waypoints::T_points
  static const struct_field_info ui_doT_Dot_T_waypoints_doT_Dot_T_points_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, tile), TID(uint8_t) },
    { FLD(PRIMITIVE, fg_color), TID(int16_t) },
    { FLD(PRIMITIVE, bg_color), TID(int16_t) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, comment), identity_traits<std::string >::get() },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_waypoints::T_points::_identity(sizeof(ui::T_waypoints::T_points), &allocator_fn<ui::T_waypoints::T_points>, &ui::T_waypoints::_identity, "T_points",NULL,ui_doT_Dot_T_waypoints_doT_Dot_T_points_fields);
  #define CUR_STRUCT ui::T_waypoints::T_routes
  static const struct_field_info ui_doT_Dot_T_waypoints_doT_Dot_T_routes_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(CONTAINER, points), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_waypoints::T_routes::_identity(sizeof(ui::T_waypoints::T_routes), &allocator_fn<ui::T_waypoints::T_routes>, &ui::T_waypoints::_identity, "T_routes",NULL,ui_doT_Dot_T_waypoints_doT_Dot_T_routes_fields);
  #define CUR_STRUCT ui::T_waypoints
  static const struct_field_info ui_doT_Dot_T_waypoints_fields[] = {
    { FLD(STL_VECTOR_PTR, points), &ui::T_waypoints::T_points::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, routes), &ui::T_waypoints::T_routes::_identity, 0, NULL },
    { FLD(PRIMITIVE, sym_selector), TID(int16_t) },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, cur_point_index), TID(int32_t) },
    { FLD(PRIMITIVE, in_edit_name_mode), TID(bool) },
    { FLD(PRIMITIVE, anon_2), TID(int8_t) },
    { FLD(PRIMITIVE, sym_tile), TID(uint8_t) },
    { FLD(PRIMITIVE, sym_fg_color), TID(int16_t) },
    { FLD(PRIMITIVE, sym_bg_color), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, unk5c04), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_point_id), TID(int32_t) },
    { FLD(PRIMITIVE, next_route_id), TID(int32_t) },
    { FLD(PRIMITIVE, sel_route_idx), TID(int32_t) },
    { FLD(PRIMITIVE, sel_route_waypt_idx), TID(int32_t) },
    { FLD(PRIMITIVE, in_edit_waypts_mode), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_waypoints::_identity(sizeof(ui::T_waypoints), &allocator_fn<ui::T_waypoints>, &ui::_identity, "T_waypoints",NULL,ui_doT_Dot_T_waypoints_fields);
  #define CUR_STRUCT ui::T_burrows
  static const struct_field_info ui_doT_Dot_T_burrows_fields[] = {
    { FLD(STL_VECTOR_PTR, list), identity_traits<df::burrow >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_id), TID(int32_t) },
    { FLD(PRIMITIVE, sel_index), TID(int32_t) },
    { FLD(PRIMITIVE, sel_id), TID(int32_t) },
    { FLD(PRIMITIVE, in_confirm_delete), TID(bool) },
    { FLD(PRIMITIVE, in_add_units_mode), TID(bool) },
    { FLD(STL_VECTOR_PTR, list_units), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(CONTAINER, sel_units), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD(PRIMITIVE, unit_cursor_pos), TID(int32_t) },
    { FLD(PRIMITIVE, in_define_mode), TID(bool) },
    { FLD(SUBSTRUCT, rect_start), &coord::_identity },
    { FLD(PRIMITIVE, brush_mode), TID(int16_t) },
    { FLD(PRIMITIVE, in_edit_name_mode), TID(bool) },
    { FLD(PRIMITIVE, sym_selector), TID(int16_t) },
    { FLD(PRIMITIVE, sym_tile), TID(int16_t) },
    { FLD(PRIMITIVE, sym_fg_color), TID(int16_t) },
    { FLD(PRIMITIVE, sym_bg_color), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_burrows::_identity(sizeof(ui::T_burrows), &allocator_fn<ui::T_burrows>, &ui::_identity, "T_burrows",NULL,ui_doT_Dot_T_burrows_fields);
  #define CUR_STRUCT ui::T_alerts::T_list
  static const struct_field_info ui_doT_Dot_T_alerts_doT_Dot_T_list_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(CONTAINER, burrows), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_alerts::T_list::_identity(sizeof(ui::T_alerts::T_list), &allocator_fn<ui::T_alerts::T_list>, &ui::T_alerts::_identity, "T_list",NULL,ui_doT_Dot_T_alerts_doT_Dot_T_list_fields);
  #define CUR_STRUCT ui::T_alerts
  static const struct_field_info ui_doT_Dot_T_alerts_fields[] = {
    { FLD(STL_VECTOR_PTR, list), &ui::T_alerts::T_list::_identity, 0, NULL },
    { FLD(PRIMITIVE, next_id), TID(int32_t) },
    { FLD(PRIMITIVE, civ_alert_idx), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_alerts::_identity(sizeof(ui::T_alerts), &allocator_fn<ui::T_alerts>, &ui::_identity, "T_alerts",NULL,ui_doT_Dot_T_alerts_fields);
  #define CUR_STRUCT ui::T_equipment
  static const struct_field_info ui_doT_Dot_T_equipment_fields[] = {
    { FLD(STATIC_ARRAY, items_by_type1), identity_traits<std::vector<df::item* > >::get(), 112, TID(item_type) },
    { FLD(STATIC_ARRAY, items_unassigned), identity_traits<std::vector<df::item* > >::get(), 112, TID(item_type) },
    { FLD(STATIC_ARRAY, items_assigned), identity_traits<std::vector<df::item* > >::get(), 112, TID(item_type) },
    { FLD(SUBSTRUCT, update), TID(ui::T_equipment::T_update) },
    { FLD(CONTAINER, work_weapons), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, work_units), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, hunter_ammunition), identity_traits<df::squad_ammo_spec >::get(), 0, NULL },
    { FLD(CONTAINER, ammo_items), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, ammo_units), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, training_assignments), identity_traits<df::training_assignment >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_equipment::_identity(sizeof(ui::T_equipment), &allocator_fn<ui::T_equipment>, &ui::_identity, "T_equipment",NULL,ui_doT_Dot_T_equipment_fields);
  #define CUR_STRUCT ui::T_hauling
  static const struct_field_info ui_doT_Dot_T_hauling_fields[] = {
    { FLD(STL_VECTOR_PTR, routes), identity_traits<df::hauling_route >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, view_routes), identity_traits<df::hauling_route >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, view_stops), identity_traits<df::hauling_stop >::get(), 0, NULL },
    { FLD(CONTAINER, view_bad), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, cursor_top), TID(int32_t) },
    { FLD(PRIMITIVE, in_stop), TID(bool) },
    { FLD(PRIMITIVE, cursor_stop), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, stop_conditions), identity_traits<df::stop_depart_condition >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, stop_links), identity_traits<df::route_stockpile_link >::get(), 0, NULL },
    { FLD(PRIMITIVE, in_advanced_cond), TID(bool) },
    { FLD(PRIMITIVE, in_assign_vehicle), TID(bool) },
    { FLD(PRIMITIVE, cursor_vehicle), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, vehicles), identity_traits<df::vehicle >::get(), 0, NULL },
    { FLD(PRIMITIVE, in_name), TID(bool) },
    { FLD(PRIMITIVE, old_name), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_hauling::_identity(sizeof(ui::T_hauling), &allocator_fn<ui::T_hauling>, &ui::_identity, "T_hauling",NULL,ui_doT_Dot_T_hauling_fields);
  #define CUR_STRUCT ui::T_main::T_dead_citizens
  static const struct_field_info ui_doT_Dot_T_main_doT_Dot_T_dead_citizens_fields[] = {
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, histfig_id), TID(int32_t) },
    { FLD(PRIMITIVE, death_year), TID(int32_t) },
    { FLD(PRIMITIVE, death_time), TID(int32_t) },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD(PRIMITIVE, ghost_type), TID(ghost_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_main::T_dead_citizens::_identity(sizeof(ui::T_main::T_dead_citizens), &allocator_fn<ui::T_main::T_dead_citizens>, &ui::T_main::_identity, "T_dead_citizens",NULL,ui_doT_Dot_T_main_doT_Dot_T_dead_citizens_fields);
  #define CUR_STRUCT ui::T_main
  static const struct_field_info ui_doT_Dot_T_main_fields[] = {
    { FLD(STATIC_ARRAY, hotkeys), identity_traits<df::ui_hotkey >::get(), 16, NULL },
    { FLD(PRIMITIVE, traffic_cost_high), TID(int32_t) },
    { FLD(PRIMITIVE, traffic_cost_normal), TID(int32_t) },
    { FLD(PRIMITIVE, traffic_cost_low), TID(int32_t) },
    { FLD(PRIMITIVE, traffic_cost_restricted), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, dead_citizens), &ui::T_main::T_dead_citizens::_identity, 0, NULL },
    { FLD(POINTER, fortress_entity), identity_traits<df::historical_entity >::get(), 0, NULL },
    { FLD(PRIMITIVE, mode), identity_traits<enum_field<df::ui_sidebar_mode,int16_t> >::get() },
    { FLD(PRIMITIVE, unk1), TID(int16_t) },
    { FLD(PRIMITIVE, selected_traffic_cost), TID(int16_t) },
    { FLD(PRIMITIVE, autosave_request), TID(bool) },
    { FLD(PRIMITIVE, autosave_unk), TID(bool) },
    { FLD(PRIMITIVE, unk6df4), TID(int32_t) },
    { FLD(PRIMITIVE, selected_hotkey), TID(int16_t) },
    { FLD(PRIMITIVE, in_rename_hotkey), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_main::_identity(sizeof(ui::T_main), &allocator_fn<ui::T_main>, &ui::_identity, "T_main",NULL,ui_doT_Dot_T_main_fields);
  #define CUR_STRUCT ui::T_squads
  static const struct_field_info ui_doT_Dot_T_squads_fields[] = {
    { FLD(STL_VECTOR_PTR, list), identity_traits<df::squad >::get(), 0, NULL },
    { FLD(CONTAINER, unk6e08), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, sel_squads), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD(CONTAINER, indiv_selected), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, in_select_indiv), TID(bool) },
    { FLD(PRIMITIVE, sel_indiv_squad), TID(int32_t) },
    { FLD(PRIMITIVE, unk48), TID(int32_t) },
    { FLD(POINTER, unk4c), identity_traits<df::squad >::get(), 0, NULL },
    { FLD(PRIMITIVE, in_move_order), TID(bool) },
    { FLD(PRIMITIVE, point_list_scroll), TID(int32_t) },
    { FLD(PRIMITIVE, in_kill_order), TID(bool) },
    { FLD(STL_VECTOR_PTR, kill_rect_targets), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, in_kill_list), TID(bool) },
    { FLD(STL_VECTOR_PTR, kill_targets), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(CONTAINER, sel_kill_targets), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD(PRIMITIVE, in_kill_rect), TID(bool) },
    { FLD(SUBSTRUCT, rect_start), &coord::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::T_squads::_identity(sizeof(ui::T_squads), &allocator_fn<ui::T_squads>, &ui::_identity, "T_squads",NULL,ui_doT_Dot_T_squads_fields);
  typedef df::ui::T_unk2a8c T_ui_fields[768];
  #define CUR_STRUCT ui
  static const struct_field_info ui_fields[] = {
    { FLD(PRIMITIVE, game_state), TID(int16_t) },
    { FLD(PRIMITIVE, lost_to_siege_civ), TID(int32_t) },
    { FLD(SUBSTRUCT, tax_collection), &ui::T_tax_collection::_identity },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, manager_cooldown), TID(int32_t) },
    { FLD(PRIMITIVE, bookkeeper_cooldown), TID(int32_t) },
    { FLD(PRIMITIVE, bookkeeper_precision), TID(int32_t) },
    { FLD(PRIMITIVE, bookkeeper_settings), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, caravans), identity_traits<df::caravan_state >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_2), TID(int8_t) },
    { FLD(PRIMITIVE, fortress_rank), TID(int16_t) },
    { FLD(PRIMITIVE, progress_population), TID(int16_t) },
    { FLD(PRIMITIVE, progress_trade), TID(int16_t) },
    { FLD(PRIMITIVE, progress_production), TID(int16_t) },
    { FLD(PRIMITIVE, king_arrived), TID(bool) },
    { FLD(PRIMITIVE, king_hasty), TID(bool) },
    { FLD(PRIMITIVE, economy_active), TID(bool) },
    { FLD(PRIMITIVE, ignore_labor_shortage), TID(bool) },
    { FLD(PRIMITIVE, justice_active), TID(bool) },
    { FLD(PRIMITIVE, anon_3), TID(uint16_t) },
    { FLD(PRIMITIVE, anon_4), TID(uint16_t) },
    { FLD(PRIMITIVE, manager_timer), TID(int16_t) },
    { FLD(SUBSTRUCT, becoming_capital), &ui::T_becoming_capital::_identity },
    { FLD(STATIC_ARRAY, units_killed), identity_traits<int16_t >::get(), 152, TID(profession) },
    { FLD(STATIC_ARRAY, guild_wages), identity_traits<int32_t >::get(), 6, TID(guild_id) },
    { FLD(STATIC_ARRAY, guild_happiness), identity_traits<int16_t >::get(), 6, TID(guild_id) },
    { FLD(STATIC_ARRAY, labor_slowdown_timer), identity_traits<int16_t >::get(), 6, TID(guild_id) },
    { FLD(CONTAINER, currency_value), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, trees_removed), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, fortress_age), TID(int32_t) },
    { FLD(SUBSTRUCT, tasks), &entity_activity_statistics::_identity },
    { FLD(CONTAINER, meeting_requests), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, activities), identity_traits<df::activity_info >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, dip_meeting_info), identity_traits<df::meeting_diplomat_info >::get(), 0, NULL },
    { FLD(CONTAINER, aid_requesters), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, game_over), TID(bool) },
    { FLD(SUBSTRUCT, invasions), &ui::T_invasions::_identity },
    { FLD(CONTAINER, crimes), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, punishments), identity_traits<df::punishment >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, parties), identity_traits<df::party_info >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, room_rent), identity_traits<df::room_rent_info >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, dipscripts), identity_traits<df::dipscript_info >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, dipscript_popups), identity_traits<df::dipscript_popup >::get(), 0, NULL },
    { FLD(SUBSTRUCT, kitchen), &ui::T_kitchen::_identity },
    { FLD(CONTAINER, economic_stone), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, unk23c8_flags), TID(ui::T_unk23c8_flags) },
    { FLD(PRIMITIVE, mood_cooldown), TID(int16_t) },
    { FLD(PRIMITIVE, civ_id), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, group_id), TID(int32_t) },
    { FLD(PRIMITIVE, race_id), TID(int16_t) },
    { FLD(CONTAINER, farm_crops), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, farm_seasons), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, economy_prices), &ui::T_economy_prices::_identity },
    { FLD(SUBSTRUCT, stockpile), &ui::T_stockpile::_identity },
    { FLD(STATIC_ARRAY, unk2a8c), identity_traits<T_ui_fields >::get(), 4, NULL },
    { FLD(CONTAINER, unk_mapedge_x), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_mapedge_y), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_mapedge_z), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, map_edge), &ui::T_map_edge::_identity },
    { FLD(STATIC_ARRAY, unk5b88), identity_traits<std::vector<void* > >::get(), 7, NULL },
    { FLD(SUBSTRUCT, waypoints), &ui::T_waypoints::_identity },
    { FLD(SUBSTRUCT, burrows), &ui::T_burrows::_identity },
    { FLD(SUBSTRUCT, alerts), &ui::T_alerts::_identity },
    { FLD(SUBSTRUCT, equipment), &ui::T_equipment::_identity },
    { FLD(SUBSTRUCT, hauling), &ui::T_hauling::_identity },
    { FLD(SUBSTRUCT, main), &ui::T_main::_identity },
    { FLD(SUBSTRUCT, squads), &ui::T_squads::_identity },
    { FLD(PRIMITIVE, follow_unit), TID(int32_t) },
    { FLD(PRIMITIVE, follow_item), TID(int32_t) },
    { FLD(CONTAINER, selected_farm_crops), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, available_seeds), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui::_identity(sizeof(ui), &allocator_fn<ui>, NULL, "ui",NULL,ui_fields);
  #define CUR_STRUCT ui_advmode::T_unk_v40_1
  static const struct_field_info ui_advmode_doT_Dot_T_unk_v40_1_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), TID(int8_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_advmode::T_unk_v40_1::_identity(sizeof(ui_advmode::T_unk_v40_1), &allocator_fn<ui_advmode::T_unk_v40_1>, &ui_advmode::_identity, "T_unk_v40_1",NULL,ui_advmode_doT_Dot_T_unk_v40_1_fields);
  #define CUR_STRUCT ui_advmode::T_conversation::T_choices
  static const struct_field_info ui_advmode_doT_Dot_T_conversation_doT_Dot_T_choices_fields[] = {
    { FLD(POINTER, choice), identity_traits<df::talk_choice >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, keywords), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, title), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_20), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_advmode::T_conversation::T_choices::_identity(sizeof(ui_advmode::T_conversation::T_choices), &allocator_fn<ui_advmode::T_conversation::T_choices>, &ui_advmode::T_conversation::_identity, "T_choices",NULL,ui_advmode_doT_Dot_T_conversation_doT_Dot_T_choices_fields);
  #define CUR_STRUCT ui_advmode::T_conversation::T_targets
  static const struct_field_info ui_advmode_doT_Dot_T_conversation_doT_Dot_T_targets_fields[] = {
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, histfig_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_advmode::T_conversation::T_targets::_identity(sizeof(ui_advmode::T_conversation::T_targets), &allocator_fn<ui_advmode::T_conversation::T_targets>, &ui_advmode::T_conversation::_identity, "T_targets",NULL,ui_advmode_doT_Dot_T_conversation_doT_Dot_T_targets_fields);
  #define CUR_STRUCT ui_advmode::T_conversation
  static const struct_field_info ui_advmode_doT_Dot_T_conversation_fields[] = {
    { FLD(STL_VECTOR_PTR, activity), identity_traits<df::activity_entry >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, activity_event), identity_traits<df::activity_event >::get(), 0, NULL },
    { FLD(PRIMITIVE, cursor_activity), TID(int32_t) },
    { FLD(PRIMITIVE, cursor_choice), TID(int32_t) },
    { FLD(PRIMITIVE, unk4), TID(int32_t) },
    { FLD(CONTAINER, unk5), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk6), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, choices), &ui_advmode::T_conversation::T_choices::_identity, 0, NULL },
    { FLD(PRIMITIVE, filter), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, targets), &ui_advmode::T_conversation::T_targets::_identity, 0, NULL },
    { FLD(PRIMITIVE, cursor_target), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_advmode::T_conversation::_identity(sizeof(ui_advmode::T_conversation), &allocator_fn<ui_advmode::T_conversation>, &ui_advmode::_identity, "T_conversation",NULL,ui_advmode_doT_Dot_T_conversation_fields);
  #define CUR_STRUCT ui_advmode::T_companions
  static const struct_field_info ui_advmode_doT_Dot_T_companions_fields[] = {
    { FLD(STL_VECTOR_PTR, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(CONTAINER, unit_visible), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD(SUBSTRUCT, unit_position), &coord_path::_identity },
    { FLD(CONTAINER, all_histfigs), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_advmode::T_companions::_identity(sizeof(ui_advmode::T_companions), &allocator_fn<ui_advmode::T_companions>, &ui_advmode::_identity, "T_companions",NULL,ui_advmode_doT_Dot_T_companions_fields);
  #define CUR_STRUCT ui_advmode::T_unk_v40_2
  static const struct_field_info ui_advmode_doT_Dot_T_unk_v40_2_fields[] = {
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_5), TID(int8_t) },
    { FLD(CONTAINER, anon_6), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_advmode::T_unk_v40_2::_identity(sizeof(ui_advmode::T_unk_v40_2), &allocator_fn<ui_advmode::T_unk_v40_2>, &ui_advmode::_identity, "T_unk_v40_2",NULL,ui_advmode_doT_Dot_T_unk_v40_2_fields);
  #define CUR_STRUCT ui_advmode::T_unk_v40_3
  static const struct_field_info ui_advmode_doT_Dot_T_unk_v40_3_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_advmode::T_unk_v40_3::_identity(sizeof(ui_advmode::T_unk_v40_3), &allocator_fn<ui_advmode::T_unk_v40_3>, &ui_advmode::_identity, "T_unk_v40_3",NULL,ui_advmode_doT_Dot_T_unk_v40_3_fields);
  #define CUR_STRUCT ui_advmode::T_unk_v40_4::T_unk_v40_4a
  static const struct_field_info ui_advmode_doT_Dot_T_unk_v40_4_doT_Dot_T_unk_v40_4a_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int16_t) },
    { FLD(PRIMITIVE, anon_3), TID(int16_t) },
    { FLD(PRIMITIVE, anon_4), TID(int16_t) },
    { FLD(PRIMITIVE, anon_5), TID(int16_t) },
    { FLD(PRIMITIVE, anon_6), TID(int16_t) },
    { FLD(PRIMITIVE, anon_7), TID(int16_t) },
    { FLD(PRIMITIVE, anon_8), TID(int16_t) },
    { FLD(PRIMITIVE, anon_9), TID(int32_t) },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_advmode::T_unk_v40_4::T_unk_v40_4a::_identity(sizeof(ui_advmode::T_unk_v40_4::T_unk_v40_4a), &allocator_fn<ui_advmode::T_unk_v40_4::T_unk_v40_4a>, &ui_advmode::T_unk_v40_4::_identity, "T_unk_v40_4a",NULL,ui_advmode_doT_Dot_T_unk_v40_4_doT_Dot_T_unk_v40_4a_fields);
  #define CUR_STRUCT ui_advmode::T_unk_v40_4
  static const struct_field_info ui_advmode_doT_Dot_T_unk_v40_4_fields[] = {
    { FLD(STATIC_ARRAY, unk_v40_4a), &ui_advmode::T_unk_v40_4::T_unk_v40_4a::_identity, 100, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_advmode::T_unk_v40_4::_identity(sizeof(ui_advmode::T_unk_v40_4), &allocator_fn<ui_advmode::T_unk_v40_4>, &ui_advmode::_identity, "T_unk_v40_4",NULL,ui_advmode_doT_Dot_T_unk_v40_4_fields);
  #define CUR_STRUCT ui_advmode::T_unk_v40_5
  static const struct_field_info ui_advmode_doT_Dot_T_unk_v40_5_fields[] = {
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_6), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_advmode::T_unk_v40_5::_identity(sizeof(ui_advmode::T_unk_v40_5), &allocator_fn<ui_advmode::T_unk_v40_5>, &ui_advmode::_identity, "T_unk_v40_5",NULL,ui_advmode_doT_Dot_T_unk_v40_5_fields);
  #define CUR_STRUCT ui_advmode
  static const struct_field_info ui_advmode_fields[] = {
    { FLD(PRIMITIVE, menu), TID(ui_advmode_menu) },
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, travel_clouds), TID(bool) },
    { FLD(PRIMITIVE, travel_right_map), TID(ui_advmode::T_travel_right_map) },
    { FLD(PRIMITIVE, unk4a), TID(int8_t) },
    { FLD(PRIMITIVE, travel_not_moved), TID(bool) },
    { FLD(PRIMITIVE, unk4b), TID(int8_t) },
    { FLD(PRIMITIVE, travel_move_countdown), TID(uint8_t) },
    { FLD(PRIMITIVE, tick_counter), TID(int32_t) },
    { FLD(PRIMITIVE, frame_counter), TID(int32_t) },
    { FLD(PRIMITIVE, unk6), TID(int16_t) },
    { FLD(PRIMITIVE, sleeping), TID(bool) },
    { FLD(PRIMITIVE, anon_5), TID(int8_t) },
    { FLD(PRIMITIVE, bogeymen_timer), TID(int32_t) },
    { FLD(PRIMITIVE, bogeymen_killed), TID(int32_t) },
    { FLD(PRIMITIVE, unk9), TID(int32_t) },
    { FLD(PRIMITIVE, unk10), TID(int32_t) },
    { FLD(CONTAINER, searched_x), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, searched_y), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, searched_z), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, searched_timeout), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_6), TID(int8_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD(PRIMITIVE, anon_9), TID(int32_t) },
    { FLD(PRIMITIVE, anon_10), TID(int8_t) },
    { FLD(CONTAINER, unk20), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk21), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk22), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_11), TID(int32_t) },
    { FLD(PRIMITIVE, anon_12), TID(int32_t) },
    { FLD(PRIMITIVE, anon_13), TID(int8_t) },
    { FLD(STATIC_ARRAY, anon_14), identity_traits<int32_t >::get(), 1000, NULL },
    { FLD(STATIC_ARRAY, anon_15), identity_traits<int32_t >::get(), 1000, NULL },
    { FLD(STATIC_ARRAY, anon_16), identity_traits<int32_t >::get(), 1000, NULL },
    { FLD(PRIMITIVE, anon_17), TID(int32_t) },
    { FLD(PRIMITIVE, anon_18), TID(int32_t) },
    { FLD(PRIMITIVE, anon_19), TID(int32_t) },
    { FLD(STATIC_ARRAY, anon_20), identity_traits<int16_t >::get(), 9, NULL },
    { FLD(STATIC_ARRAY, anon_21), identity_traits<int16_t >::get(), 9, NULL },
    { FLD(STATIC_ARRAY, anon_22), identity_traits<int16_t >::get(), 9, NULL },
    { FLD(STATIC_ARRAY, unk_v40_1), &ui_advmode::T_unk_v40_1::_identity, 9, NULL },
    { FLD(STATIC_ARRAY, anon_23), identity_traits<int8_t >::get(), 9, NULL },
    { FLD(STATIC_ARRAY, anon_24), identity_traits<int8_t >::get(), 9, NULL },
    { FLD(STATIC_ARRAY, anon_25), identity_traits<int32_t >::get(), 9, NULL },
    { FLD(STATIC_ARRAY, anon_26), identity_traits<int8_t >::get(), 9, NULL },
    { FLD(PRIMITIVE, anon_27), TID(int32_t) },
    { FLD(PRIMITIVE, anon_28), TID(int32_t) },
    { FLD(PRIMITIVE, anon_29), TID(int8_t) },
    { FLD(PRIMITIVE, anon_30), TID(int32_t) },
    { FLD(PRIMITIVE, anon_31), TID(int32_t) },
    { FLD(PRIMITIVE, anon_32), TID(int8_t) },
    { FLD(PRIMITIVE, anon_33), TID(int32_t) },
    { FLD(PRIMITIVE, anon_34), TID(int32_t) },
    { FLD(PRIMITIVE, anon_35), TID(int32_t) },
    { FLD(PRIMITIVE, anon_36), TID(int32_t) },
    { FLD(PRIMITIVE, anon_37), TID(int8_t) },
    { FLD(PRIMITIVE, anon_38), TID(int32_t) },
    { FLD(PRIMITIVE, anon_39), TID(int32_t) },
    { FLD(PRIMITIVE, anon_40), TID(int32_t) },
    { FLD(CONTAINER, unk_30d8), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_41), TID(int32_t) },
    { FLD(PRIMITIVE, anon_42), TID(int8_t) },
    { FLD(PRIMITIVE, unk23), TID(int16_t) },
    { FLD(PRIMITIVE, unk24), TID(int16_t) },
    { FLD(PRIMITIVE, unk25), TID(int16_t) },
    { FLD(PRIMITIVE, unk26), TID(int16_t) },
    { FLD(PRIMITIVE, player_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_43), TID(int16_t) },
    { FLD(PRIMITIVE, anon_44), TID(int16_t) },
    { FLD(PRIMITIVE, anon_45), TID(int16_t) },
    { FLD(PRIMITIVE, anon_46), TID(int32_t) },
    { FLD(SUBSTRUCT, conversation), &ui_advmode::T_conversation::_identity },
    { FLD(CONTAINER, anon_47), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_48), TID(int32_t) },
    { FLD(CONTAINER, unk28), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk29), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk30), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, actions), identity_traits<df::adventure_movement_option >::get(), 0, NULL },
    { FLD(CONTAINER, unk31), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_49), TID(int32_t) },
    { FLD(PRIMITIVE, anon_50), TID(int8_t) },
    { FLD(PRIMITIVE, anon_51), TID(int8_t) },
    { FLD(PRIMITIVE, anon_52), TID(int8_t) },
    { FLD(PRIMITIVE, anon_53), TID(int8_t) },
    { FLD(PRIMITIVE, anon_54), TID(int8_t) },
    { FLD(PRIMITIVE, anon_55), TID(int8_t) },
    { FLD(PRIMITIVE, anon_56), TID(int8_t) },
    { FLD(PRIMITIVE, anon_57), TID(int32_t) },
    { FLD(SUBSTRUCT, companions), &ui_advmode::T_companions::_identity },
    { FLD(CONTAINER, unk37), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk38), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_1e4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1e8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1ec), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1f0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1f4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1f8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1fc), TID(int32_t) },
    { FLD(PRIMITIVE, unk_200), TID(int32_t) },
    { FLD(PRIMITIVE, unk39), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_220), TID(int32_t) },
    { FLD(PRIMITIVE, unk_224), TID(int32_t) },
    { FLD(SUBSTRUCT, unk_v40_2), &ui_advmode::T_unk_v40_2::_identity },
    { FLD(SUBSTRUCT, unk_v40_3), &ui_advmode::T_unk_v40_3::_identity },
    { FLD(PRIMITIVE, anon_58), TID(int32_t) },
    { FLD(PRIMITIVE, anon_59), TID(int32_t) },
    { FLD(PRIMITIVE, anon_60), TID(int32_t) },
    { FLD(SUBSTRUCT, unk_v40_4), &ui_advmode::T_unk_v40_4::_identity },
    { FLD(SUBSTRUCT, unk_v40_5), &ui_advmode::T_unk_v40_5::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_advmode::_identity(sizeof(ui_advmode), &allocator_fn<ui_advmode>, NULL, "ui_advmode",NULL,ui_advmode_fields);
  #define CUR_STRUCT ui_build_item_req
  static const struct_field_info ui_build_item_req_fields[] = {
    { FLD(SUBSTRUCT, filter), &job_item_filter::_identity },
    { FLD(STL_VECTOR_PTR, candidates), identity_traits<df::item >::get(), 0, NULL },
    { FLD(CONTAINER, candidate_selected), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_a0), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, candidate_enabled), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(PRIMITIVE, count_required), TID(int16_t) },
    { FLD(PRIMITIVE, count_max), TID(int16_t) },
    { FLD(PRIMITIVE, count_provided), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_build_item_req::_identity(sizeof(ui_build_item_req), &allocator_fn<ui_build_item_req>, NULL, "ui_build_item_req",NULL,ui_build_item_req_fields);
  typedef int32_t T_ui_build_selector_fields[31];
  #define CUR_STRUCT ui_build_selector
  static const struct_field_info ui_build_selector_fields[] = {
    { FLD(STL_VECTOR_PTR, requirements), identity_traits<df::ui_build_item_req >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, choices), identity_traits<df::build_req_choicest >::get(), 0, NULL },
    { FLD(PRIMITIVE, building_type), TID(building_type) },
    { FLD(PRIMITIVE, building_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, custom_type), TID(int32_t) },
    { FLD(PRIMITIVE, stage), TID(int32_t) },
    { FLD(PRIMITIVE, req_index), TID(int16_t) },
    { FLD(PRIMITIVE, sel_index), TID(int16_t) },
    { FLD(PRIMITIVE, is_grouped), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, errors), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk4), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, tiles), identity_traits<T_ui_build_selector_fields >::get(), 31, NULL },
    { FLD(PRIMITIVE, unk5_0a), TID(int16_t) },
    { FLD(PRIMITIVE, unk5_0b), TID(int16_t) },
    { FLD(SUBSTRUCT, plate_info), &pressure_plate_info::_identity },
    { FLD(CONTAINER, unk6), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk7), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, friction), TID(int32_t) },
    { FLD(PRIMITIVE, use_dump), TID(int32_t) },
    { FLD(PRIMITIVE, dump_x_shift), TID(int32_t) },
    { FLD(PRIMITIVE, dump_y_shift), TID(int32_t) },
    { FLD(PRIMITIVE, speed), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_build_selector::_identity(sizeof(ui_build_selector), &allocator_fn<ui_build_selector>, NULL, "ui_build_selector",NULL,ui_build_selector_fields);
  #define CUR_STRUCT ui_hotkey
  static const struct_field_info ui_hotkey_fields[] = {
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, cmd), TID(ui_hotkey::T_cmd) },
    { FLD(PRIMITIVE, x), TID(int32_t) },
    { FLD(PRIMITIVE, y), TID(int32_t) },
    { FLD(PRIMITIVE, z), TID(int32_t) },
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, item_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_hotkey::_identity(sizeof(ui_hotkey), &allocator_fn<ui_hotkey>, NULL, "ui_hotkey",NULL,ui_hotkey_fields);
  #define CUR_STRUCT ui_look_list::T_items
  static const struct_field_info ui_look_list_doT_Dot_T_items_fields[] = {
    { FLD(PRIMITIVE, type), TID(ui_look_list::T_items::T_type) },
    { FLD(PRIMITIVE, spatter_item_type), TID(item_type) },
    { FLD(PRIMITIVE, spatter_item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, spatter_mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, spatter_mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, spatter_mat_state), TID(matter_state) },
    { FLD(POINTER, item), identity_traits<df::item >::get(), 2, NULL },
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 2, NULL },
    { FLD(POINTER, building), identity_traits<df::building >::get(), 2, NULL },
    { FLD(POINTER, vermin), identity_traits<df::vermin >::get(), 2, NULL },
    { FLD(POINTER, flow), identity_traits<df::flow_info >::get(), 2, NULL },
    { FLD(PRIMITIVE, spatter_size), TID(int8_t) },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), TID(int16_t) },
    { FLD(PRIMITIVE, anon_3), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_look_list::T_items::_identity(sizeof(ui_look_list::T_items), &allocator_fn<ui_look_list::T_items>, &ui_look_list::_identity, "T_items",NULL,ui_look_list_doT_Dot_T_items_fields);
  #define CUR_STRUCT ui_look_list
  static const struct_field_info ui_look_list_fields[] = {
    { FLD(STL_VECTOR_PTR, items), &ui_look_list::T_items::_identity, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_look_list::_identity(sizeof(ui_look_list), &allocator_fn<ui_look_list>, NULL, "ui_look_list",NULL,ui_look_list_fields);
  #define CUR_STRUCT ui_sidebar_menus::T_designation
  static const struct_field_info ui_sidebar_menus_doT_Dot_T_designation_fields[] = {
    { FLD(PRIMITIVE, marker_only), TID(bool) },
    { FLD(PRIMITIVE, priority_set), TID(bool) },
    { FLD(PRIMITIVE, priority), TID(int32_t) },
    { FLD(PRIMITIVE, mine_mode), TID(ui_sidebar_menus::T_designation::T_mine_mode) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_sidebar_menus::T_designation::_identity(sizeof(ui_sidebar_menus::T_designation), &allocator_fn<ui_sidebar_menus::T_designation>, &ui_sidebar_menus::_identity, "T_designation",NULL,ui_sidebar_menus_doT_Dot_T_designation_fields);
  #define CUR_STRUCT ui_sidebar_menus::T_workshop_job
  static const struct_field_info ui_sidebar_menus_doT_Dot_T_workshop_job_fields[] = {
    { FLD(STL_VECTOR_PTR, choices_all), identity_traits<df::interface_button_buildingst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, choices_visible), identity_traits<df::interface_button_buildingst >::get(), 0, NULL },
    { FLD(PRIMITIVE, cursor), TID(int32_t) },
    { FLD(PRIMITIVE, category_id), TID(int32_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(SUBSTRUCT, material_category), TID(job_material_category) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_sidebar_menus::T_workshop_job::_identity(sizeof(ui_sidebar_menus::T_workshop_job), &allocator_fn<ui_sidebar_menus::T_workshop_job>, &ui_sidebar_menus::_identity, "T_workshop_job",NULL,ui_sidebar_menus_doT_Dot_T_workshop_job_fields);
  #define CUR_STRUCT ui_sidebar_menus::T_building
  static const struct_field_info ui_sidebar_menus_doT_Dot_T_building_fields[] = {
    { FLD(STL_VECTOR_PTR, choices_all), identity_traits<df::interface_button_constructionst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, choices_visible), identity_traits<df::interface_button_constructionst >::get(), 0, NULL },
    { FLD(PRIMITIVE, category_id), TID(int32_t) },
    { FLD(PRIMITIVE, cursor), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_sidebar_menus::T_building::_identity(sizeof(ui_sidebar_menus::T_building), &allocator_fn<ui_sidebar_menus::T_building>, &ui_sidebar_menus::_identity, "T_building",NULL,ui_sidebar_menus_doT_Dot_T_building_fields);
  #define CUR_STRUCT ui_sidebar_menus::T_zone
  static const struct_field_info ui_sidebar_menus_doT_Dot_T_zone_fields[] = {
    { FLD(PRIMITIVE, remove), TID(bool) },
    { FLD(PRIMITIVE, mode), TID(ui_sidebar_menus::T_zone::T_mode) },
    { FLD(POINTER, selected), identity_traits<df::building_civzonest >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_sidebar_menus::T_zone::_identity(sizeof(ui_sidebar_menus::T_zone), &allocator_fn<ui_sidebar_menus::T_zone>, &ui_sidebar_menus::_identity, "T_zone",NULL,ui_sidebar_menus_doT_Dot_T_zone_fields);
  #define CUR_STRUCT ui_sidebar_menus::T_unit
  static const struct_field_info ui_sidebar_menus_doT_Dot_T_unit_fields[] = {
    { FLD(STL_VECTOR_PTR, inv_items), identity_traits<df::unit_inventory_item >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, inv_spatters), identity_traits<df::spatter >::get(), 0, NULL },
    { FLD(PRIMITIVE, in_new_squad), TID(bool) },
    { FLD(PRIMITIVE, cursor_uniform), TID(int32_t) },
    { FLD(PRIMITIVE, unk_88n_cursor), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, squads), identity_traits<df::squad >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, squad_pos), identity_traits<df::entity_position >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, squad_assn), identity_traits<df::entity_position_assignment >::get(), 0, NULL },
    { FLD(CONTAINER, squad_unk1), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD(CONTAINER, squad_unk2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(POINTER, anon_1), identity_traits<df::entity_position >::get(), 0, NULL },
    { FLD(POINTER, anon_2), identity_traits<df::entity_position_assignment >::get(), 0, NULL },
    { FLD(POINTER, anon_3), identity_traits<df::entity_position >::get(), 0, NULL },
    { FLD(PRIMITIVE, in_squad), TID(int8_t) },
    { FLD(PRIMITIVE, anon_4), TID(int8_t) },
    { FLD(PRIMITIVE, anon_5), TID(int8_t) },
    { FLD(PRIMITIVE, anon_6), TID(int8_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, unk_80), TID(int32_t) },
    { FLD(PRIMITIVE, unk_84), TID(int32_t) },
    { FLD(PRIMITIVE, unk_88), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_90), TID(int32_t) },
    { FLD(CONTAINER, list), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_a0), TID(int8_t) },
    { FLD(PRIMITIVE, unk_a1), TID(int8_t) },
    { FLD(CONTAINER, skills), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, show_combat), TID(bool) },
    { FLD(PRIMITIVE, show_labor), TID(bool) },
    { FLD(PRIMITIVE, show_misc), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_sidebar_menus::T_unit::_identity(sizeof(ui_sidebar_menus::T_unit), &allocator_fn<ui_sidebar_menus::T_unit>, &ui_sidebar_menus::_identity, "T_unit",NULL,ui_sidebar_menus_doT_Dot_T_unit_fields);
  #define CUR_STRUCT ui_sidebar_menus::T_barracks
  static const struct_field_info ui_sidebar_menus_doT_Dot_T_barracks_fields[] = {
    { FLD(PRIMITIVE, squad_cursor), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, squads), identity_traits<df::squad >::get(), 0, NULL },
    { FLD(CONTAINER, uses), identity_traits<std::vector<df::squad_use_flags > >::get(), 0, NULL },
    { FLD(PRIMITIVE, in_rename), TID(bool) },
    { FLD(PRIMITIVE, in_positions), TID(bool) },
    { FLD(POINTER, position_squad), identity_traits<df::squad >::get(), 0, NULL },
    { FLD(PRIMITIVE, position_cursor), TID(int32_t) },
    { FLD(PRIMITIVE, in_position_squads), TID(bool) },
    { FLD(STL_VECTOR_PTR, position_squads), identity_traits<df::squad >::get(), 0, NULL },
    { FLD(PRIMITIVE, position_squad_cursor), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_sidebar_menus::T_barracks::_identity(sizeof(ui_sidebar_menus::T_barracks), &allocator_fn<ui_sidebar_menus::T_barracks>, &ui_sidebar_menus::_identity, "T_barracks",NULL,ui_sidebar_menus_doT_Dot_T_barracks_fields);
  typedef int32_t T_ui_sidebar_menus_doT_Dot_T_minimap_fields[23];
  typedef uint8_t T_ui_sidebar_menus_doT_Dot_T_minimap_fields_1[23];
  typedef int16_t T_ui_sidebar_menus_doT_Dot_T_minimap_fields_2[23];
  typedef int16_t T_ui_sidebar_menus_doT_Dot_T_minimap_fields_3[23];
  typedef int16_t T_ui_sidebar_menus_doT_Dot_T_minimap_fields_4[23];
  #define CUR_STRUCT ui_sidebar_menus::T_minimap
  static const struct_field_info ui_sidebar_menus_doT_Dot_T_minimap_fields[] = {
    { FLD(STATIC_ARRAY, data), identity_traits<T_ui_sidebar_menus_doT_Dot_T_minimap_fields >::get(), 23, NULL },
    { FLD(PRIMITIVE, need_render), TID(bool) },
    { FLD(PRIMITIVE, need_scan), TID(bool) },
    { FLD(PRIMITIVE, z_level), TID(int16_t) },
    { FLD(STATIC_ARRAY, tile), identity_traits<T_ui_sidebar_menus_doT_Dot_T_minimap_fields_1 >::get(), 23, NULL },
    { FLD(STATIC_ARRAY, tile_fg), identity_traits<T_ui_sidebar_menus_doT_Dot_T_minimap_fields_2 >::get(), 23, NULL },
    { FLD(STATIC_ARRAY, tile_bg), identity_traits<T_ui_sidebar_menus_doT_Dot_T_minimap_fields_3 >::get(), 23, NULL },
    { FLD(STATIC_ARRAY, tile_bold), identity_traits<T_ui_sidebar_menus_doT_Dot_T_minimap_fields_4 >::get(), 23, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_sidebar_menus::T_minimap::_identity(sizeof(ui_sidebar_menus::T_minimap), &allocator_fn<ui_sidebar_menus::T_minimap>, &ui_sidebar_menus::_identity, "T_minimap",NULL,ui_sidebar_menus_doT_Dot_T_minimap_fields);
  #define CUR_STRUCT ui_sidebar_menus::T_unk
  static const struct_field_info ui_sidebar_menus_doT_Dot_T_unk_fields[] = {
    { FLD(PRIMITIVE, anon_1), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, anon_2), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_17c0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_17c4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_17c8), TID(int8_t) },
    { FLD(PRIMITIVE, worldgen_param_set), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_17d0), TID(int8_t) },
    { FLD(PRIMITIVE, num_speech_tokens), TID(int32_t) },
    { FLD(PRIMITIVE, unk_17d8), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_sidebar_menus::T_unk::_identity(sizeof(ui_sidebar_menus::T_unk), &allocator_fn<ui_sidebar_menus::T_unk>, &ui_sidebar_menus::_identity, "T_unk",NULL,ui_sidebar_menus_doT_Dot_T_unk_fields);
  #define CUR_STRUCT ui_sidebar_menus
  static const struct_field_info ui_sidebar_menus_fields[] = {
    { FLD(SUBSTRUCT, designation), &ui_sidebar_menus::T_designation::_identity },
    { FLD(SUBSTRUCT, workshop_job), &ui_sidebar_menus::T_workshop_job::_identity },
    { FLD(SUBSTRUCT, building), &ui_sidebar_menus::T_building::_identity },
    { FLD(SUBSTRUCT, zone), &ui_sidebar_menus::T_zone::_identity },
    { FLD(SUBSTRUCT, unit), &ui_sidebar_menus::T_unit::_identity },
    { FLD(SUBSTRUCT, barracks), &ui_sidebar_menus::T_barracks::_identity },
    { FLD(SUBSTRUCT, minimap), &ui_sidebar_menus::T_minimap::_identity },
    { FLD(SUBSTRUCT, unk), &ui_sidebar_menus::T_unk::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_sidebar_menus::_identity(sizeof(ui_sidebar_menus), &allocator_fn<ui_sidebar_menus>, NULL, "ui_sidebar_menus",NULL,ui_sidebar_menus_fields);
  #define CUR_STRUCT ui_unit_view_mode
  static const struct_field_info ui_unit_view_mode_fields[] = {
    { FLD(PRIMITIVE, value), TID(ui_unit_view_mode::T_value) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity ui_unit_view_mode::_identity(sizeof(ui_unit_view_mode), &allocator_fn<ui_unit_view_mode>, NULL, "ui_unit_view_mode",NULL,ui_unit_view_mode_fields);
  #define CUR_STRUCT unit::T_path
  static const struct_field_info unit_doT_Dot_T_path_fields[] = {
    { FLD(SUBSTRUCT, dest), &coord::_identity },
    { FLD(PRIMITIVE, goal), TID(unit_path_goal) },
    { FLD(SUBSTRUCT, path), &coord_path::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_path::_identity(sizeof(unit::T_path), &allocator_fn<unit::T_path>, &unit::_identity, "T_path",NULL,unit_doT_Dot_T_path_fields);
  #define CUR_STRUCT unit::T_meeting
  static const struct_field_info unit_doT_Dot_T_meeting_fields[] = {
    { FLD(PRIMITIVE, state), TID(unit::T_meeting::T_state) },
    { FLD(PRIMITIVE, target_entity), TID(int32_t) },
    { FLD(PRIMITIVE, target_role), identity_traits<enum_field<df::entity_position_responsibility,int16_t> >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_meeting::_identity(sizeof(unit::T_meeting), &allocator_fn<unit::T_meeting>, &unit::_identity, "T_meeting",NULL,unit_doT_Dot_T_meeting_fields);
  #define CUR_STRUCT unit::T_military
  static const struct_field_info unit_doT_Dot_T_military_fields[] = {
    { FLD(PRIMITIVE, squad_id), TID(int32_t) },
    { FLD(PRIMITIVE, squad_position), TID(int32_t) },
    { FLD(PRIMITIVE, patrol_cooldown), TID(int32_t) },
    { FLD(PRIMITIVE, patrol_timer), TID(int32_t) },
    { FLD(PRIMITIVE, cur_uniform), TID(int16_t) },
    { FLD(CONTAINER, unk_items), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, uniforms), identity_traits<std::vector<int32_t > >::get(), 4, NULL },
    { FLD(SUBSTRUCT, pickup_flags), TID(unit::T_military::T_pickup_flags) },
    { FLD(CONTAINER, uniform_pickup), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, uniform_drop), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, individual_drills), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_military::_identity(sizeof(unit::T_military), &allocator_fn<unit::T_military>, &unit::_identity, "T_military",NULL,unit_doT_Dot_T_military_fields);
  #define CUR_STRUCT unit::T_animal
  static const struct_field_info unit_doT_Dot_T_animal_fields[] = {
    { FLD(SUBSTRUCT, population), &world_population_ref::_identity },
    { FLD(PRIMITIVE, leave_countdown), TID(int32_t) },
    { FLD(PRIMITIVE, vanish_countdown), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_animal::_identity(sizeof(unit::T_animal), &allocator_fn<unit::T_animal>, &unit::_identity, "T_animal",NULL,unit_doT_Dot_T_animal_fields);
  #define CUR_STRUCT unit::T_opponent
  static const struct_field_info unit_doT_Dot_T_opponent_fields[] = {
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(SUBSTRUCT, unit_pos), &coord::_identity },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_opponent::_identity(sizeof(unit::T_opponent), &allocator_fn<unit::T_opponent>, &unit::_identity, "T_opponent",NULL,unit_doT_Dot_T_opponent_fields);
  #define CUR_STRUCT unit::T_relations
  static const struct_field_info unit_doT_Dot_T_relations_fields[] = {
    { FLD(PRIMITIVE, pregnancy_timer), TID(uint32_t) },
    { FLD(POINTER, pregnancy_genes), identity_traits<df::unit_genes >::get(), 0, NULL },
    { FLD(PRIMITIVE, pregnancy_caste), TID(int16_t) },
    { FLD(PRIMITIVE, pregnancy_spouse), TID(int32_t) },
    { FLD(PRIMITIVE, mood_copy), TID(mood_type) },
    { FLD(POINTER, ghost_info), identity_traits<df::unit_ghost_info >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, birth_year), TID(int32_t) },
    { FLD(PRIMITIVE, birth_time), TID(int32_t) },
    { FLD(PRIMITIVE, curse_year), TID(int32_t) },
    { FLD(PRIMITIVE, curse_time), TID(int32_t) },
    { FLD(PRIMITIVE, birth_year_bias), TID(int32_t) },
    { FLD(PRIMITIVE, birth_time_bias), TID(int32_t) },
    { FLD(PRIMITIVE, old_year), TID(int32_t) },
    { FLD(PRIMITIVE, old_time), TID(int32_t) },
    { FLD(POINTER, following), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_238), TID(uint16_t) },
    { FLD(PRIMITIVE, pet_owner_id), TID(int32_t) },
    { FLD(PRIMITIVE, spouse_id), TID(int32_t) },
    { FLD(PRIMITIVE, mother_id), TID(int32_t) },
    { FLD(PRIMITIVE, father_id), TID(int32_t) },
    { FLD(PRIMITIVE, last_attacker_id), TID(int32_t) },
    { FLD(PRIMITIVE, group_leader_id), TID(int32_t) },
    { FLD(PRIMITIVE, draggee_id), TID(int32_t) },
    { FLD(PRIMITIVE, dragger_id), TID(int32_t) },
    { FLD(PRIMITIVE, rider_mount_id), TID(int32_t) },
    { FLD(PRIMITIVE, lover_id), TID(int32_t) },
    { FLD(PRIMITIVE, mount_type), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_relations::_identity(sizeof(unit::T_relations), &allocator_fn<unit::T_relations>, &unit::_identity, "T_relations",NULL,unit_doT_Dot_T_relations_fields);
  #define CUR_STRUCT unit::T_job
  static const struct_field_info unit_doT_Dot_T_job_fields[] = {
    { FLD(PRIMITIVE, account), TID(int32_t) },
    { FLD(PRIMITIVE, satisfaction), TID(int32_t) },
    { FLD(POINTER, hunt_target), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, destroy_target), identity_traits<df::building >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int8_t) },
    { FLD(PRIMITIVE, gait_buildup), TID(int32_t) },
    { FLD(SUBSTRUCT, climb_hold), &coord::_identity },
    { FLD(PRIMITIVE, unk_v4014_1), TID(int32_t) },
    { FLD(POINTER, current_job), identity_traits<df::job >::get(), 0, NULL },
    { FLD(PRIMITIVE, mood_skill), TID(job_skill) },
    { FLD(PRIMITIVE, mood_timeout), TID(int32_t) },
    { FLD(PRIMITIVE, unk_39c), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_job::_identity(sizeof(unit::T_job), &allocator_fn<unit::T_job>, &unit::_identity, "T_job",NULL,unit_doT_Dot_T_job_fields);
  #define CUR_STRUCT unit::T_body
  static const struct_field_info unit_doT_Dot_T_body_fields[] = {
    { FLD(SUBSTRUCT, components), &body_component_info::_identity },
    { FLD(STL_VECTOR_PTR, wounds), identity_traits<df::unit_wound >::get(), 0, NULL },
    { FLD(PRIMITIVE, wound_next_id), TID(int32_t) },
    { FLD(STATIC_ARRAY, unk_39c), identity_traits<int32_t >::get(), 10, NULL },
    { FLD(POINTER, body_plan), identity_traits<df::caste_body_info >::get(), 0, NULL },
    { FLD(PRIMITIVE, weapon_bp), TID(int16_t) },
    { FLD(STATIC_ARRAY, physical_attrs), identity_traits<df::unit_attribute >::get(), 6, TID(physical_attribute_type) },
    { FLD(SUBSTRUCT, size_info), &body_size_info::_identity },
    { FLD(PRIMITIVE, blood_max), TID(uint32_t) },
    { FLD(PRIMITIVE, blood_count), TID(uint32_t) },
    { FLD(PRIMITIVE, infection_level), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, spatters), identity_traits<df::spatter >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_body::_identity(sizeof(unit::T_body), &allocator_fn<unit::T_body>, &unit::_identity, "T_body",NULL,unit_doT_Dot_T_body_fields);
  #define CUR_STRUCT unit::T_appearance
  static const struct_field_info unit_doT_Dot_T_appearance_fields[] = {
    { FLD(CONTAINER, body_modifiers), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_modifiers), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, size_modifier), TID(int32_t) },
    { FLD(CONTAINER, tissue_style), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, tissue_style_civ_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, tissue_style_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, tissue_style_type), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, tissue_length), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, genes), &unit_genes::_identity },
    { FLD(CONTAINER, colors), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_appearance::_identity(sizeof(unit::T_appearance), &allocator_fn<unit::T_appearance>, &unit::_identity, "T_appearance",NULL,unit_doT_Dot_T_appearance_fields);
  #define CUR_STRUCT unit::T_counters
  static const struct_field_info unit_doT_Dot_T_counters_fields[] = {
    { FLD(PRIMITIVE, think_counter), TID(int32_t) },
    { FLD(PRIMITIVE, job_counter), TID(int32_t) },
    { FLD(PRIMITIVE, swap_counter), TID(int32_t) },
    { FLD(PRIMITIVE, death_cause), identity_traits<enum_field<df::death_type,int16_t> >::get() },
    { FLD(PRIMITIVE, death_id), TID(int32_t) },
    { FLD(PRIMITIVE, winded), TID(int16_t) },
    { FLD(PRIMITIVE, stunned), TID(int16_t) },
    { FLD(PRIMITIVE, unconscious), TID(int16_t) },
    { FLD(PRIMITIVE, suffocation), TID(int16_t) },
    { FLD(PRIMITIVE, webbed), TID(int16_t) },
    { FLD(SUBSTRUCT, guts_trail1), &coord::_identity },
    { FLD(SUBSTRUCT, guts_trail2), &coord::_identity },
    { FLD(PRIMITIVE, soldier_mood_countdown), TID(int16_t) },
    { FLD(PRIMITIVE, soldier_mood), TID(unit::T_counters::T_soldier_mood) },
    { FLD(PRIMITIVE, pain), TID(uint32_t) },
    { FLD(PRIMITIVE, nausea), TID(uint32_t) },
    { FLD(PRIMITIVE, dizziness), TID(uint32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_counters::_identity(sizeof(unit::T_counters), &allocator_fn<unit::T_counters>, &unit::_identity, "T_counters",NULL,unit_doT_Dot_T_counters_fields);
  #define CUR_STRUCT unit::T_curse
  static const struct_field_info unit_doT_Dot_T_curse_fields[] = {
    { FLD(SUBSTRUCT, add_tags1), TID(cie_add_tag_mask1) },
    { FLD(SUBSTRUCT, rem_tags1), TID(cie_add_tag_mask1) },
    { FLD(SUBSTRUCT, add_tags2), TID(cie_add_tag_mask2) },
    { FLD(SUBSTRUCT, rem_tags2), TID(cie_add_tag_mask2) },
    { FLD(PRIMITIVE, name_visible), TID(bool) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_adjective), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, sym_and_color1), TID(uint32_t) },
    { FLD(PRIMITIVE, sym_and_color2), TID(uint32_t) },
    { FLD(PRIMITIVE, flash_period), TID(uint32_t) },
    { FLD(PRIMITIVE, flash_time2), TID(uint32_t) },
    { FLD(CONTAINER, body_appearance), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_appearance), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, speed_add), TID(uint32_t) },
    { FLD(PRIMITIVE, speed_mul_percent), TID(uint32_t) },
    { FLD(POINTER, attr_change), identity_traits<df::curse_attr_change >::get(), 0, NULL },
    { FLD(PRIMITIVE, luck_mul_percent), TID(uint32_t) },
    { FLD(CONTAINER, interaction_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, interaction_time), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, interaction_delay), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, time_on_site), TID(int32_t) },
    { FLD(CONTAINER, own_interaction), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, own_interaction_delay), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_curse::_identity(sizeof(unit::T_curse), &allocator_fn<unit::T_curse>, &unit::_identity, "T_curse",NULL,unit_doT_Dot_T_curse_fields);
  #define CUR_STRUCT unit::T_counters2
  static const struct_field_info unit_doT_Dot_T_counters2_fields[] = {
    { FLD(PRIMITIVE, paralysis), TID(uint32_t) },
    { FLD(PRIMITIVE, numbness), TID(uint32_t) },
    { FLD(PRIMITIVE, fever), TID(uint32_t) },
    { FLD(PRIMITIVE, exhaustion), TID(uint32_t) },
    { FLD(PRIMITIVE, hunger_timer), TID(uint32_t) },
    { FLD(PRIMITIVE, thirst_timer), TID(uint32_t) },
    { FLD(PRIMITIVE, sleepiness_timer), TID(uint32_t) },
    { FLD(PRIMITIVE, stomach_content), TID(uint32_t) },
    { FLD(PRIMITIVE, stomach_food), TID(uint32_t) },
    { FLD(PRIMITIVE, vomit_timeout), TID(uint32_t) },
    { FLD(PRIMITIVE, stored_fat), TID(uint32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_counters2::_identity(sizeof(unit::T_counters2), &allocator_fn<unit::T_counters2>, &unit::_identity, "T_counters2",NULL,unit_doT_Dot_T_counters2_fields);
  #define CUR_STRUCT unit::T_status::T_eat_history::T_food
  static const struct_field_info unit_doT_Dot_T_status_doT_Dot_T_eat_history_doT_Dot_T_food_fields[] = {
    { FLD(CONTAINER, item_type), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, item_subtype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, material), &material_vec_ref::_identity },
    { FLD(CONTAINER, year), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, year_time), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_status::T_eat_history::T_food::_identity(sizeof(unit::T_status::T_eat_history::T_food), &allocator_fn<unit::T_status::T_eat_history::T_food>, &unit::T_status::T_eat_history::_identity, "T_food",NULL,unit_doT_Dot_T_status_doT_Dot_T_eat_history_doT_Dot_T_food_fields);
  #define CUR_STRUCT unit::T_status::T_eat_history::T_drink
  static const struct_field_info unit_doT_Dot_T_status_doT_Dot_T_eat_history_doT_Dot_T_drink_fields[] = {
    { FLD(CONTAINER, item_type), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, item_subtype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, material), &material_vec_ref::_identity },
    { FLD(CONTAINER, year), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, year_time), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_status::T_eat_history::T_drink::_identity(sizeof(unit::T_status::T_eat_history::T_drink), &allocator_fn<unit::T_status::T_eat_history::T_drink>, &unit::T_status::T_eat_history::_identity, "T_drink",NULL,unit_doT_Dot_T_status_doT_Dot_T_eat_history_doT_Dot_T_drink_fields);
  #define CUR_STRUCT unit::T_status::T_eat_history
  static const struct_field_info unit_doT_Dot_T_status_doT_Dot_T_eat_history_fields[] = {
    { FLD(SUBSTRUCT, food), &unit::T_status::T_eat_history::T_food::_identity },
    { FLD(SUBSTRUCT, drink), &unit::T_status::T_eat_history::T_drink::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_status::T_eat_history::_identity(sizeof(unit::T_status::T_eat_history), &allocator_fn<unit::T_status::T_eat_history>, &unit::T_status::_identity, "T_eat_history",NULL,unit_doT_Dot_T_status_doT_Dot_T_eat_history_fields);
  #define CUR_STRUCT unit::T_status
  static const struct_field_info unit_doT_Dot_T_status_fields[] = {
    { FLD(STL_VECTOR_PTR, misc_traits), identity_traits<df::unit_misc_trait >::get(), 0, NULL },
    { FLD(POINTER, eat_history), &unit::T_status::T_eat_history::_identity, 0, NULL },
    { FLD(PRIMITIVE, demand_timeout), TID(int32_t) },
    { FLD(PRIMITIVE, mandate_timeout), TID(int32_t) },
    { FLD(CONTAINER, attacker_ids), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, attacker_cntdn), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, face_direction), TID(uint8_t) },
    { FLD(SUBSTRUCT, artifact_name), &language_name::_identity },
    { FLD(STL_VECTOR_PTR, souls), identity_traits<df::unit_soul >::get(), 0, NULL },
    { FLD(POINTER, current_soul), identity_traits<df::unit_soul >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, demands), identity_traits<df::unit_demand >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, labors), identity_traits<bool >::get(), 94, TID(unit_labor) },
    { FLD(STL_VECTOR_PTR, wrestle_items), identity_traits<df::unit_item_wrestle >::get(), 0, NULL },
    { FLD(CONTAINER, observed_traps), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, complaints), identity_traits<df::unit_complaint >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, requests), identity_traits<df::unit_request >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, coin_debts), identity_traits<df::unit_coin_debt >::get(), 0, NULL },
    { FLD(PRIMITIVE, adv_sleep_timer), TID(int16_t) },
    { FLD(SUBSTRUCT, recent_job_area), &coord::_identity },
    { FLD(SUBSTRUCT, recent_jobs), &coord_path::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_status::_identity(sizeof(unit::T_status), &allocator_fn<unit::T_status>, &unit::_identity, "T_status",NULL,unit_doT_Dot_T_status_fields);
  #define CUR_STRUCT unit::T_status2
  static const struct_field_info unit_doT_Dot_T_status2_fields[] = {
    { FLD(PRIMITIVE, limbs_stand_max), TID(int16_t) },
    { FLD(PRIMITIVE, limbs_stand_count), TID(int16_t) },
    { FLD(PRIMITIVE, limbs_grasp_max), TID(int16_t) },
    { FLD(PRIMITIVE, limbs_grasp_count), TID(int16_t) },
    { FLD(PRIMITIVE, limbs_fly_max), TID(int16_t) },
    { FLD(PRIMITIVE, limbs_fly_count), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, body_part_temperature), identity_traits<df::temperaturest >::get(), 0, NULL },
    { FLD(PRIMITIVE, add_path_flags), TID(uint32_t) },
    { FLD(SUBSTRUCT, liquid_type), TID(tile_designation) },
    { FLD(PRIMITIVE, liquid_depth), TID(uint8_t) },
    { FLD(PRIMITIVE, unk_7c0), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_status2::_identity(sizeof(unit::T_status2), &allocator_fn<unit::T_status2>, &unit::_identity, "T_status2",NULL,unit_doT_Dot_T_status2_fields);
  #define CUR_STRUCT unit::T_unknown7
  static const struct_field_info unit_doT_Dot_T_unknown7_fields[] = {
    { FLD(CONTAINER, unk_7c4), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_unknown7::_identity(sizeof(unit::T_unknown7), &allocator_fn<unit::T_unknown7>, &unit::_identity, "T_unknown7",NULL,unit_doT_Dot_T_unknown7_fields);
  #define CUR_STRUCT unit::T_syndromes
  static const struct_field_info unit_doT_Dot_T_syndromes_fields[] = {
    { FLD(STL_VECTOR_PTR, active), identity_traits<df::unit_syndrome >::get(), 0, NULL },
    { FLD(CONTAINER, reinfection_type), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, reinfection_count), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_syndromes::_identity(sizeof(unit::T_syndromes), &allocator_fn<unit::T_syndromes>, &unit::_identity, "T_syndromes",NULL,unit_doT_Dot_T_syndromes_fields);
  #define CUR_STRUCT unit::T_reports
  static const struct_field_info unit_doT_Dot_T_reports_fields[] = {
    { FLD(STATIC_ARRAY, log), identity_traits<std::vector<int32_t > >::get(), 3, TID(unit_report_type) },
    { FLD(STATIC_ARRAY, last_year), identity_traits<int32_t >::get(), 3, TID(unit_report_type) },
    { FLD(STATIC_ARRAY, last_year_tick), identity_traits<int32_t >::get(), 3, TID(unit_report_type) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_reports::_identity(sizeof(unit::T_reports), &allocator_fn<unit::T_reports>, &unit::_identity, "T_reports",NULL,unit_doT_Dot_T_reports_fields);
  #define CUR_STRUCT unit::T_enemy::T_undead
  static const struct_field_info unit_doT_Dot_T_enemy_doT_Dot_T_undead_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int16_t) },
    { FLD(PRIMITIVE, anon_7), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_enemy::T_undead::_identity(sizeof(unit::T_enemy::T_undead), &allocator_fn<unit::T_enemy::T_undead>, &unit::T_enemy::_identity, "T_undead",NULL,unit_doT_Dot_T_enemy_doT_Dot_T_undead_fields);
  #define CUR_STRUCT unit::T_enemy::T_witness_reports
  static const struct_field_info unit_doT_Dot_T_enemy_doT_Dot_T_witness_reports_fields[] = {
    { FLD(PRIMITIVE, death_id), TID(int32_t) },
    { FLD(PRIMITIVE, crime_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, year_tick), TID(int32_t) },
    { FLD(PRIMITIVE, unk2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_enemy::T_witness_reports::_identity(sizeof(unit::T_enemy::T_witness_reports), &allocator_fn<unit::T_enemy::T_witness_reports>, &unit::T_enemy::_identity, "T_witness_reports",NULL,unit_doT_Dot_T_enemy_doT_Dot_T_witness_reports_fields);
  #define CUR_STRUCT unit::T_enemy::T_anon_12
  static const struct_field_info unit_doT_Dot_T_enemy_doT_Dot_T_anon_12_fields[] = {
    { FLD(CONTAINER, unk_0), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_10), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_enemy::T_anon_12::_identity(sizeof(unit::T_enemy::T_anon_12), &allocator_fn<unit::T_enemy::T_anon_12>, &unit::T_enemy::_identity, "T_anon_12",NULL,unit_doT_Dot_T_enemy_doT_Dot_T_anon_12_fields);
  #define CUR_STRUCT unit::T_enemy
  static const struct_field_info unit_doT_Dot_T_enemy_fields[] = {
    { FLD(CONTAINER, sound_cooldown), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(POINTER, undead), &unit::T_enemy::T_undead::_identity, 0, NULL },
    { FLD(PRIMITIVE, were_race), TID(int32_t) },
    { FLD(PRIMITIVE, were_caste), TID(int32_t) },
    { FLD(PRIMITIVE, normal_race), TID(int32_t) },
    { FLD(PRIMITIVE, normal_caste), TID(int32_t) },
    { FLD(PRIMITIVE, interaction), TID(int32_t) },
    { FLD(CONTAINER, unk_850), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, witness_reports), &unit::T_enemy::T_witness_reports::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_a5c), identity_traits<df::entity_event >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, gait_index), identity_traits<int32_t >::get(), 5, TID(gait_type) },
    { FLD(STATIC_ARRAY, unk_v40_1a), identity_traits<int32_t >::get(), 10, NULL },
    { FLD(STATIC_ARRAY, unk_v40_1b), identity_traits<int32_t >::get(), 10, NULL },
    { FLD(STATIC_ARRAY, unk_v40_1c), identity_traits<int32_t >::get(), 10, NULL },
    { FLD(STATIC_ARRAY, unk_v40_1d), identity_traits<int32_t >::get(), 10, NULL },
    { FLD(STATIC_ARRAY, unk_v40_1e), identity_traits<int32_t >::get(), 10, NULL },
    { FLD(STATIC_ARRAY, unk_v40_2), identity_traits<int32_t >::get(), 20, NULL },
    { FLD(STATIC_ARRAY, anon_1), identity_traits<int32_t >::get(), 180, NULL },
    { FLD(PRIMITIVE, unk_v40_2_count), TID(int32_t) },
    { FLD(POINTER, anon_2), NULL, 0, NULL },
    { FLD(POINTER, anon_3), NULL, 0, NULL },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(POINTER, anon_8), NULL, 0, NULL },
    { FLD(CONTAINER, anon_9), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_10), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_11), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(POINTER, anon_12), &unit::T_enemy::T_anon_12::_identity, 0, NULL },
    { FLD(PRIMITIVE, enemy_status_slot), TID(int32_t) },
    { FLD(PRIMITIVE, unk_874_cntr), TID(int32_t) },
    { FLD(CONTAINER, body_part_878), identity_traits<std::vector<uint8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, body_part_888), identity_traits<std::vector<uint8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, body_part_relsize), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, body_part_8a8), identity_traits<std::vector<uint8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, body_part_base_ins), identity_traits<std::vector<uint16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, body_part_clothing_ins), identity_traits<std::vector<uint16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, body_part_8d8), identity_traits<std::vector<uint16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_8e8), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_8f8), identity_traits<std::vector<uint16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_enemy::_identity(sizeof(unit::T_enemy), &allocator_fn<unit::T_enemy>, &unit::_identity, "T_enemy",NULL,unit_doT_Dot_T_enemy_fields);
  #define CUR_STRUCT unit::T_recuperation
  static const struct_field_info unit_doT_Dot_T_recuperation_fields[] = {
    { FLD(CONTAINER, healing_rate), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, effective_rate), TID(int32_t) },
    { FLD(PRIMITIVE, tendons_heal), TID(int32_t) },
    { FLD(PRIMITIVE, ligaments_heal), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::T_recuperation::_identity(sizeof(unit::T_recuperation), &allocator_fn<unit::T_recuperation>, &unit::_identity, "T_recuperation",NULL,unit_doT_Dot_T_recuperation_fields);
  #define CUR_STRUCT unit
  static const struct_field_info unit_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, custom_profession), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, profession), TID(profession) },
    { FLD(PRIMITIVE, profession2), TID(profession) },
    { FLD(PRIMITIVE, race), TID(int32_t) },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(SUBSTRUCT, idle_area), &coord::_identity },
    { FLD(PRIMITIVE, idle_area_threshold), TID(int32_t) },
    { FLD(PRIMITIVE, idle_area_type), TID(unit_station_type) },
    { FLD(PRIMITIVE, follow_distance), TID(int32_t) },
    { FLD(SUBSTRUCT, path), &unit::T_path::_identity },
    { FLD(SUBSTRUCT, flags1), TID(unit_flags1) },
    { FLD(SUBSTRUCT, flags2), TID(unit_flags2) },
    { FLD(SUBSTRUCT, flags3), TID(unit_flags3) },
    { FLD(SUBSTRUCT, meeting), &unit::T_meeting::_identity },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(PRIMITIVE, sex), TID(int8_t) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_100), TID(int16_t) },
    { FLD(PRIMITIVE, training_level), TID(animal_training_level) },
    { FLD(PRIMITIVE, schedule_id), TID(int32_t) },
    { FLD(PRIMITIVE, civ_id), TID(int32_t) },
    { FLD(PRIMITIVE, population_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c0), TID(int32_t) },
    { FLD(PRIMITIVE, cultural_identity), TID(int32_t) },
    { FLD(PRIMITIVE, invasion_id), TID(int32_t) },
    { FLD(SUBSTRUCT, patrol_route), &coord_path::_identity },
    { FLD(PRIMITIVE, patrol_index), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, specific_refs), identity_traits<df::specific_ref >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, general_refs), identity_traits<df::general_ref >::get(), 0, NULL },
    { FLD(SUBSTRUCT, military), &unit::T_military::_identity },
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, animal), &unit::T_animal::_identity },
    { FLD(SUBSTRUCT, opponent), &unit::T_opponent::_identity },
    { FLD(PRIMITIVE, mood), TID(mood_type) },
    { FLD(PRIMITIVE, unk_18e), TID(int16_t) },
    { FLD(SUBSTRUCT, relations), &unit::T_relations::_identity },
    { FLD(SUBSTRUCT, last_hit), &history_hit_item::_identity },
    { FLD(PRIMITIVE, riding_item_id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, inventory), identity_traits<df::unit_inventory_item >::get(), 0, NULL },
    { FLD(CONTAINER, owned_items), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, traded_items), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, owned_buildings), identity_traits<df::building >::get(), 0, NULL },
    { FLD(CONTAINER, corpse_parts), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, job), &unit::T_job::_identity },
    { FLD(SUBSTRUCT, body), &unit::T_body::_identity },
    { FLD(SUBSTRUCT, appearance), &unit::T_appearance::_identity },
    { FLD(STL_VECTOR_PTR, actions), identity_traits<df::unit_action >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_action_id), TID(int32_t) },
    { FLD(SUBSTRUCT, counters), &unit::T_counters::_identity },
    { FLD(SUBSTRUCT, curse), &unit::T_curse::_identity },
    { FLD(SUBSTRUCT, counters2), &unit::T_counters2::_identity },
    { FLD(SUBSTRUCT, status), &unit::T_status::_identity },
    { FLD(PRIMITIVE, hist_figure_id), TID(int32_t) },
    { FLD(PRIMITIVE, hist_figure_id2), TID(int32_t) },
    { FLD(SUBSTRUCT, status2), &unit::T_status2::_identity },
    { FLD(SUBSTRUCT, unknown7), &unit::T_unknown7::_identity },
    { FLD(SUBSTRUCT, syndromes), &unit::T_syndromes::_identity },
    { FLD(SUBSTRUCT, reports), &unit::T_reports::_identity },
    { FLD(POINTER, health), identity_traits<df::unit_health_info >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, used_items), identity_traits<df::unit_item_use >::get(), 0, NULL },
    { FLD(SUBSTRUCT, enemy), &unit::T_enemy::_identity },
    { FLD(SUBSTRUCT, recuperation), &unit::T_recuperation::_identity },
    { FLD(PRIMITIVE, weight), TID(int32_t) },
    { FLD(PRIMITIVE, weight_fraction), TID(int32_t) },
    { FLD(CONTAINER, burrows), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, combat_side_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit::_identity(sizeof(unit), &allocator_fn<unit>, NULL, "unit",NULL,unit_fields);
  #define CUR_STRUCT unit_action::T_data::T_move
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_move_fields[] = {
    { FLD(PRIMITIVE, x), TID(int16_t) },
    { FLD(PRIMITIVE, y), TID(int16_t) },
    { FLD(PRIMITIVE, z), TID(int16_t) },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD(PRIMITIVE, timer_init), TID(int32_t) },
    { FLD(PRIMITIVE, fatigue), TID(int32_t) },
    { FLD(PRIMITIVE, flags), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_move>::identity(sizeof(unit_action::T_data::T_move), &allocator_fn<unit_action::T_data::T_move>, TID(unit_action::T_data), "T_move", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_move_fields);
  #define CUR_STRUCT unit_action::T_data::T_attack::T_unk_4
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_attack_doT_Dot_T_unk_4_fields[] = {
    { FLD(PRIMITIVE, wrestle_type), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int16_t) },
    { FLD(PRIMITIVE, unk_6), TID(int16_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_attack::T_unk_4>::identity(sizeof(unit_action::T_data::T_attack::T_unk_4), &allocator_fn<unit_action::T_data::T_attack::T_unk_4>, TID(unit_action::T_data::T_attack), "T_unk_4", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_attack_doT_Dot_T_unk_4_fields);
  #define CUR_STRUCT unit_action::T_data::T_attack
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_attack_fields[] = {
    { FLD(PRIMITIVE, target_unit_id), TID(int32_t) },
    { FLD(SUBSTRUCT, unk_4), TID(unit_action::T_data::T_attack::T_unk_4) },
    { FLD(PRIMITIVE, attack_item_id), TID(int32_t) },
    { FLD(PRIMITIVE, target_body_part_id), TID(int16_t) },
    { FLD(PRIMITIVE, attack_body_part_id), TID(int16_t) },
    { FLD(PRIMITIVE, attack_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_28), TID(int32_t) },
    { FLD(PRIMITIVE, unk_2c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_30), TID(int32_t) },
    { FLD(PRIMITIVE, flags), TID(int32_t) },
    { FLD(PRIMITIVE, unk_38), TID(int16_t) },
    { FLD(PRIMITIVE, unk_3c), TID(int32_t) },
    { FLD(PRIMITIVE, timer1), TID(int32_t) },
    { FLD(PRIMITIVE, timer2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_attack>::identity(sizeof(unit_action::T_data::T_attack), &allocator_fn<unit_action::T_data::T_attack>, TID(unit_action::T_data), "T_attack", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_attack_fields);
  #define CUR_STRUCT unit_action::T_data::T_jump
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_jump_fields[] = {
    { FLD(PRIMITIVE, x1), TID(int16_t) },
    { FLD(PRIMITIVE, y1), TID(int16_t) },
    { FLD(PRIMITIVE, z1), TID(int16_t) },
    { FLD(PRIMITIVE, x2), TID(int16_t) },
    { FLD(PRIMITIVE, y2), TID(int16_t) },
    { FLD(PRIMITIVE, z2), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_jump>::identity(sizeof(unit_action::T_data::T_jump), &allocator_fn<unit_action::T_data::T_jump>, TID(unit_action::T_data), "T_jump", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_jump_fields);
  #define CUR_STRUCT unit_action::T_data::T_holdterrain
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_holdterrain_fields[] = {
    { FLD(PRIMITIVE, x1), TID(int16_t) },
    { FLD(PRIMITIVE, y1), TID(int16_t) },
    { FLD(PRIMITIVE, z1), TID(int16_t) },
    { FLD(PRIMITIVE, x2), TID(int16_t) },
    { FLD(PRIMITIVE, y2), TID(int16_t) },
    { FLD(PRIMITIVE, z2), TID(int16_t) },
    { FLD(PRIMITIVE, x3), TID(int16_t) },
    { FLD(PRIMITIVE, y3), TID(int16_t) },
    { FLD(PRIMITIVE, z3), TID(int16_t) },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD(PRIMITIVE, fatigue), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_holdterrain>::identity(sizeof(unit_action::T_data::T_holdterrain), &allocator_fn<unit_action::T_data::T_holdterrain>, TID(unit_action::T_data), "T_holdterrain", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_holdterrain_fields);
  #define CUR_STRUCT unit_action::T_data::T_releaseterrain
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_releaseterrain_fields[] = {
    { FLD(PRIMITIVE, x), TID(int16_t) },
    { FLD(PRIMITIVE, y), TID(int16_t) },
    { FLD(PRIMITIVE, z), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_releaseterrain>::identity(sizeof(unit_action::T_data::T_releaseterrain), &allocator_fn<unit_action::T_data::T_releaseterrain>, TID(unit_action::T_data), "T_releaseterrain", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_releaseterrain_fields);
  #define CUR_STRUCT unit_action::T_data::T_climb
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_climb_fields[] = {
    { FLD(PRIMITIVE, x1), TID(int16_t) },
    { FLD(PRIMITIVE, y1), TID(int16_t) },
    { FLD(PRIMITIVE, z1), TID(int16_t) },
    { FLD(PRIMITIVE, x2), TID(int16_t) },
    { FLD(PRIMITIVE, y2), TID(int16_t) },
    { FLD(PRIMITIVE, z2), TID(int16_t) },
    { FLD(PRIMITIVE, x3), TID(int16_t) },
    { FLD(PRIMITIVE, y3), TID(int16_t) },
    { FLD(PRIMITIVE, z3), TID(int16_t) },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD(PRIMITIVE, timer_init), TID(int32_t) },
    { FLD(PRIMITIVE, fatigue), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_climb>::identity(sizeof(unit_action::T_data::T_climb), &allocator_fn<unit_action::T_data::T_climb>, TID(unit_action::T_data), "T_climb", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_climb_fields);
  #define CUR_STRUCT unit_action::T_data::T_job
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_job_fields[] = {
    { FLD(PRIMITIVE, x), TID(int16_t) },
    { FLD(PRIMITIVE, y), TID(int16_t) },
    { FLD(PRIMITIVE, z), TID(int16_t) },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_job>::identity(sizeof(unit_action::T_data::T_job), &allocator_fn<unit_action::T_data::T_job>, TID(unit_action::T_data), "T_job", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_job_fields);
  #define CUR_STRUCT unit_action::T_data::T_talk
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_talk_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, activity_id), TID(int32_t) },
    { FLD(PRIMITIVE, activity_event_idx), TID(int32_t) },
    { FLD(STATIC_ARRAY, event), identity_traits<int32_t >::get(), 10, NULL },
    { FLD(PRIMITIVE, unk_34), TID(int32_t) },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD(PRIMITIVE, unk_3c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_40), TID(int32_t) },
    { FLD(PRIMITIVE, unk_44), TID(int32_t) },
    { FLD(PRIMITIVE, unk_48), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_50), TID(int32_t) },
    { FLD(PRIMITIVE, unk_54), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_talk>::identity(sizeof(unit_action::T_data::T_talk), &allocator_fn<unit_action::T_data::T_talk>, TID(unit_action::T_data), "T_talk", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_talk_fields);
  #define CUR_STRUCT unit_action::T_data::T_unsteady
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_unsteady_fields[] = {
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_unsteady>::identity(sizeof(unit_action::T_data::T_unsteady), &allocator_fn<unit_action::T_data::T_unsteady>, TID(unit_action::T_data), "T_unsteady", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_unsteady_fields);
  #define CUR_STRUCT unit_action::T_data::T_parry
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_parry_fields[] = {
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, target_action), TID(int32_t) },
    { FLD(PRIMITIVE, parry_item_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_parry>::identity(sizeof(unit_action::T_data::T_parry), &allocator_fn<unit_action::T_data::T_parry>, TID(unit_action::T_data), "T_parry", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_parry_fields);
  #define CUR_STRUCT unit_action::T_data::T_block
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_block_fields[] = {
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, target_action), TID(int32_t) },
    { FLD(PRIMITIVE, block_item_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_block>::identity(sizeof(unit_action::T_data::T_block), &allocator_fn<unit_action::T_data::T_block>, TID(unit_action::T_data), "T_block", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_block_fields);
  #define CUR_STRUCT unit_action::T_data::T_dodge
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_dodge_fields[] = {
    { FLD(PRIMITIVE, x1), TID(int16_t) },
    { FLD(PRIMITIVE, y1), TID(int16_t) },
    { FLD(PRIMITIVE, z1), TID(int16_t) },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD(PRIMITIVE, x2), TID(int16_t) },
    { FLD(PRIMITIVE, y2), TID(int16_t) },
    { FLD(PRIMITIVE, z2), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_dodge>::identity(sizeof(unit_action::T_data::T_dodge), &allocator_fn<unit_action::T_data::T_dodge>, TID(unit_action::T_data), "T_dodge", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_dodge_fields);
  #define CUR_STRUCT unit_action::T_data::T_recover
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_recover_fields[] = {
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_recover>::identity(sizeof(unit_action::T_data::T_recover), &allocator_fn<unit_action::T_data::T_recover>, TID(unit_action::T_data), "T_recover", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_recover_fields);
  #define CUR_STRUCT unit_action::T_data::T_standup
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_standup_fields[] = {
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_standup>::identity(sizeof(unit_action::T_data::T_standup), &allocator_fn<unit_action::T_data::T_standup>, TID(unit_action::T_data), "T_standup", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_standup_fields);
  #define CUR_STRUCT unit_action::T_data::T_liedown
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_liedown_fields[] = {
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_liedown>::identity(sizeof(unit_action::T_data::T_liedown), &allocator_fn<unit_action::T_data::T_liedown>, TID(unit_action::T_data), "T_liedown", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_liedown_fields);
  #define CUR_STRUCT unit_action::T_data::T_job2
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_job2_fields[] = {
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_job2>::identity(sizeof(unit_action::T_data::T_job2), &allocator_fn<unit_action::T_data::T_job2>, TID(unit_action::T_data), "T_job2", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_job2_fields);
  #define CUR_STRUCT unit_action::T_data::T_pushobject
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_pushobject_fields[] = {
    { FLD(PRIMITIVE, x1), TID(int16_t) },
    { FLD(PRIMITIVE, y1), TID(int16_t) },
    { FLD(PRIMITIVE, z1), TID(int16_t) },
    { FLD(PRIMITIVE, x2), TID(int16_t) },
    { FLD(PRIMITIVE, y2), TID(int16_t) },
    { FLD(PRIMITIVE, z2), TID(int16_t) },
    { FLD(PRIMITIVE, x3), TID(int16_t) },
    { FLD(PRIMITIVE, y3), TID(int16_t) },
    { FLD(PRIMITIVE, z3), TID(int16_t) },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_pushobject>::identity(sizeof(unit_action::T_data::T_pushobject), &allocator_fn<unit_action::T_data::T_pushobject>, TID(unit_action::T_data), "T_pushobject", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_pushobject_fields);
  #define CUR_STRUCT unit_action::T_data::T_suckblood
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_suckblood_fields[] = {
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, timer), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_suckblood>::identity(sizeof(unit_action::T_data::T_suckblood), &allocator_fn<unit_action::T_data::T_suckblood>, TID(unit_action::T_data), "T_suckblood", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_suckblood_fields);
  #define CUR_STRUCT unit_action::T_data::T_holditem
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_holditem_fields[] = {
    { FLD(PRIMITIVE, x1), TID(int16_t) },
    { FLD(PRIMITIVE, y1), TID(int16_t) },
    { FLD(PRIMITIVE, z1), TID(int16_t) },
    { FLD(PRIMITIVE, x2), TID(int16_t) },
    { FLD(PRIMITIVE, y2), TID(int16_t) },
    { FLD(PRIMITIVE, z2), TID(int16_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_holditem>::identity(sizeof(unit_action::T_data::T_holditem), &allocator_fn<unit_action::T_data::T_holditem>, TID(unit_action::T_data), "T_holditem", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_holditem_fields);
  #define CUR_STRUCT unit_action::T_data::T_releaseitem
  static const struct_field_info unit_action_doT_Dot_T_data_doT_Dot_T_releaseitem_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data::T_releaseitem>::identity(sizeof(unit_action::T_data::T_releaseitem), &allocator_fn<unit_action::T_data::T_releaseitem>, TID(unit_action::T_data), "T_releaseitem", NULL, unit_action_doT_Dot_T_data_doT_Dot_T_releaseitem_fields);
  #define CUR_STRUCT unit_action::T_data
  static const struct_field_info unit_action_doT_Dot_T_data_fields[] = {
    { FLD(SUBSTRUCT, move), TID(unit_action::T_data::T_move) },
    { FLD(SUBSTRUCT, attack), TID(unit_action::T_data::T_attack) },
    { FLD(SUBSTRUCT, jump), TID(unit_action::T_data::T_jump) },
    { FLD(SUBSTRUCT, holdterrain), TID(unit_action::T_data::T_holdterrain) },
    { FLD(SUBSTRUCT, releaseterrain), TID(unit_action::T_data::T_releaseterrain) },
    { FLD(SUBSTRUCT, climb), TID(unit_action::T_data::T_climb) },
    { FLD(SUBSTRUCT, job), TID(unit_action::T_data::T_job) },
    { FLD(SUBSTRUCT, talk), TID(unit_action::T_data::T_talk) },
    { FLD(SUBSTRUCT, unsteady), TID(unit_action::T_data::T_unsteady) },
    { FLD(SUBSTRUCT, parry), TID(unit_action::T_data::T_parry) },
    { FLD(SUBSTRUCT, block), TID(unit_action::T_data::T_block) },
    { FLD(SUBSTRUCT, dodge), TID(unit_action::T_data::T_dodge) },
    { FLD(SUBSTRUCT, recover), TID(unit_action::T_data::T_recover) },
    { FLD(SUBSTRUCT, standup), TID(unit_action::T_data::T_standup) },
    { FLD(SUBSTRUCT, liedown), TID(unit_action::T_data::T_liedown) },
    { FLD(SUBSTRUCT, job2), TID(unit_action::T_data::T_job2) },
    { FLD(SUBSTRUCT, pushobject), TID(unit_action::T_data::T_pushobject) },
    { FLD(SUBSTRUCT, suckblood), TID(unit_action::T_data::T_suckblood) },
    { FLD(SUBSTRUCT, holditem), TID(unit_action::T_data::T_holditem) },
    { FLD(SUBSTRUCT, releaseitem), TID(unit_action::T_data::T_releaseitem) },
    { FLD(STATIC_ARRAY, raw_data), identity_traits<int32_t >::get(), 22, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_action::T_data>::identity(sizeof(unit_action::T_data), &allocator_fn<unit_action::T_data>, &unit_action::_identity, "T_data", NULL, unit_action_doT_Dot_T_data_fields);
  #define CUR_STRUCT unit_action
  static const struct_field_info unit_action_fields[] = {
    { FLD(PRIMITIVE, type), TID(unit_action_type) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(SUBSTRUCT, data), TID(unit_action::T_data) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_action::_identity(sizeof(unit_action), &allocator_fn<unit_action>, NULL, "unit_action",NULL,unit_action_fields);
  #define CUR_STRUCT unit_attribute
  static const struct_field_info unit_attribute_fields[] = {
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD(PRIMITIVE, max_value), TID(int32_t) },
    { FLD(PRIMITIVE, improve_counter), TID(int32_t) },
    { FLD(PRIMITIVE, unused_counter), TID(int32_t) },
    { FLD(PRIMITIVE, soft_demotion), TID(int32_t) },
    { FLD(PRIMITIVE, rust_counter), TID(int32_t) },
    { FLD(PRIMITIVE, demotion_counter), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_attribute::_identity(sizeof(unit_attribute), &allocator_fn<unit_attribute>, NULL, "unit_attribute",NULL,unit_attribute_fields);
  #define CUR_STRUCT unit_chunk::T_units
  static const struct_field_info unit_chunk_doT_Dot_T_units_fields[] = {
    { FLD(STL_VECTOR_PTR, items), identity_traits<df::item >::get(), 0, NULL },
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_chunk::T_units::_identity(sizeof(unit_chunk::T_units), &allocator_fn<unit_chunk::T_units>, &unit_chunk::_identity, "T_units",NULL,unit_chunk_doT_Dot_T_units_fields);
  #define CUR_STRUCT unit_chunk
  static const struct_field_info unit_chunk_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(STATIC_ARRAY, units), &unit_chunk::T_units::_identity, 100, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_chunk::_identity(sizeof(unit_chunk), &allocator_fn<unit_chunk>, NULL, "unit_chunk",NULL,unit_chunk_fields);
  #define CUR_STRUCT unit_coin_debt
  static const struct_field_info unit_coin_debt_fields[] = {
    { FLD(PRIMITIVE, recipient), TID(int32_t) },
    { FLD(PRIMITIVE, amount), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_coin_debt::_identity(sizeof(unit_coin_debt), &allocator_fn<unit_coin_debt>, NULL, "unit_coin_debt",NULL,unit_coin_debt_fields);
  #define CUR_STRUCT unit_complaint
  static const struct_field_info unit_complaint_fields[] = {
    { FLD(PRIMITIVE, type), TID(unit_complaint::T_type) },
    { FLD(PRIMITIVE, guild), identity_traits<enum_field<df::guild_id,int16_t> >::get() },
    { FLD(PRIMITIVE, age), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_complaint::_identity(sizeof(unit_complaint), &allocator_fn<unit_complaint>, NULL, "unit_complaint",NULL,unit_complaint_fields);
  #define CUR_STRUCT unit_demand
  static const struct_field_info unit_demand_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int16_t) },
    { FLD(PRIMITIVE, place), TID(unit_demand::T_place) },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, timeout_counter), TID(int32_t) },
    { FLD(PRIMITIVE, timeout_limit), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_demand::_identity(sizeof(unit_demand), &allocator_fn<unit_demand>, NULL, "unit_demand",NULL,unit_demand_fields);
  #define CUR_STRUCT unit_genes
  static const struct_field_info unit_genes_fields[] = {
    { FLD(CONTAINER, appearance), identity_traits<DfArray<uint8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, colors), identity_traits<DfArray<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_genes::_identity(sizeof(unit_genes), &allocator_fn<unit_genes>, NULL, "unit_genes",NULL,unit_genes_fields);
  #define CUR_STRUCT unit_ghost_info::T_target
  static const struct_field_info unit_ghost_info_doT_Dot_T_target_fields[] = {
    { FLD(PRIMITIVE, unit), TID(int32_t) },
    { FLD(PRIMITIVE, item), TID(int32_t) },
    { FLD(PRIMITIVE, building), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_ghost_info::T_target>::identity(sizeof(unit_ghost_info::T_target), &allocator_fn<unit_ghost_info::T_target>, &unit_ghost_info::_identity, "T_target", NULL, unit_ghost_info_doT_Dot_T_target_fields);
  #define CUR_STRUCT unit_ghost_info
  static const struct_field_info unit_ghost_info_fields[] = {
    { FLD(PRIMITIVE, type), TID(ghost_type) },
    { FLD(PRIMITIVE, type2), TID(ghost_type) },
    { FLD(PRIMITIVE, goal), TID(ghost_goal) },
    { FLD(SUBSTRUCT, target), TID(unit_ghost_info::T_target) },
    { FLD(SUBSTRUCT, misplace_pos), &coord::_identity },
    { FLD(PRIMITIVE, action_timer), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(unit_ghost_info::T_flags) },
    { FLD(PRIMITIVE, death_x), TID(int32_t) },
    { FLD(PRIMITIVE, death_y), TID(int32_t) },
    { FLD(PRIMITIVE, death_z), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_ghost_info::_identity(sizeof(unit_ghost_info), &allocator_fn<unit_ghost_info>, NULL, "unit_ghost_info",NULL,unit_ghost_info_fields);
  #define CUR_STRUCT unit_health_info::T_op_history::T_info::T_crutch
  static const struct_field_info unit_health_info_doT_Dot_T_op_history_doT_Dot_T_info_doT_Dot_T_crutch_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(int32_t) },
    { FLD(PRIMITIVE, item_subtype), TID(int32_t) },
    { FLD(PRIMITIVE, mat_type), TID(int32_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, item_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_health_info::T_op_history::T_info::T_crutch>::identity(sizeof(unit_health_info::T_op_history::T_info::T_crutch), &allocator_fn<unit_health_info::T_op_history::T_info::T_crutch>, TID(unit_health_info::T_op_history::T_info), "T_crutch", NULL, unit_health_info_doT_Dot_T_op_history_doT_Dot_T_info_doT_Dot_T_crutch_fields);
  #define CUR_STRUCT unit_health_info::T_op_history::T_info::T_bandage
  static const struct_field_info unit_health_info_doT_Dot_T_op_history_doT_Dot_T_info_doT_Dot_T_bandage_fields[] = {
    { FLD(PRIMITIVE, mat_type), TID(int32_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, body_part_id), TID(int32_t) },
    { FLD(PRIMITIVE, item_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_health_info::T_op_history::T_info::T_bandage>::identity(sizeof(unit_health_info::T_op_history::T_info::T_bandage), &allocator_fn<unit_health_info::T_op_history::T_info::T_bandage>, TID(unit_health_info::T_op_history::T_info), "T_bandage", NULL, unit_health_info_doT_Dot_T_op_history_doT_Dot_T_info_doT_Dot_T_bandage_fields);
  #define CUR_STRUCT unit_health_info::T_op_history::T_info
  static const struct_field_info unit_health_info_doT_Dot_T_op_history_doT_Dot_T_info_fields[] = {
    { FLD(SUBSTRUCT, crutch), TID(unit_health_info::T_op_history::T_info::T_crutch) },
    { FLD(PRIMITIVE, bed_id), TID(int32_t) },
    { FLD(SUBSTRUCT, bandage), TID(unit_health_info::T_op_history::T_info::T_bandage) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<unit_health_info::T_op_history::T_info>::identity(sizeof(unit_health_info::T_op_history::T_info), &allocator_fn<unit_health_info::T_op_history::T_info>, &unit_health_info::T_op_history::_identity, "T_info", NULL, unit_health_info_doT_Dot_T_op_history_doT_Dot_T_info_fields);
  #define CUR_STRUCT unit_health_info::T_op_history
  static const struct_field_info unit_health_info_doT_Dot_T_op_history_fields[] = {
    { FLD(PRIMITIVE, job_type), TID(job_type) },
    { FLD(SUBSTRUCT, info), TID(unit_health_info::T_op_history::T_info) },
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, year_time), TID(int32_t) },
    { FLD(PRIMITIVE, doctor_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_health_info::T_op_history::_identity(sizeof(unit_health_info::T_op_history), &allocator_fn<unit_health_info::T_op_history>, &unit_health_info::_identity, "T_op_history",NULL,unit_health_info_doT_Dot_T_op_history_fields);
  #define CUR_STRUCT unit_health_info
  static const struct_field_info unit_health_info_fields[] = {
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(unit_health_flags) },
    { FLD(CONTAINER, body_part_flags), identity_traits<std::vector<df::unit_bp_health_flags > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_18_cntdn), TID(int16_t) },
    { FLD(PRIMITIVE, immobilize_cntdn), TID(int16_t) },
    { FLD(PRIMITIVE, dressing_cntdn), TID(int16_t) },
    { FLD(PRIMITIVE, suture_cntdn), TID(int16_t) },
    { FLD(PRIMITIVE, crutch_cntdn), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, op_history), &unit_health_info::T_op_history::_identity, 0, NULL },
    { FLD(CONTAINER, unk_34), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_health_info::_identity(sizeof(unit_health_info), &allocator_fn<unit_health_info>, NULL, "unit_health_info",NULL,unit_health_info_fields);
  #define CUR_STRUCT unit_inventory_item
  static const struct_field_info unit_inventory_item_fields[] = {
    { FLD(POINTER, item), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, mode), TID(unit_inventory_item::T_mode) },
    { FLD(PRIMITIVE, body_part_id), TID(int16_t) },
    { FLD(PRIMITIVE, pet_seed), TID(int32_t) },
    { FLD(PRIMITIVE, wound_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_inventory_item::_identity(sizeof(unit_inventory_item), &allocator_fn<unit_inventory_item>, NULL, "unit_inventory_item",NULL,unit_inventory_item_fields);
  #define CUR_STRUCT unit_item_use
  static const struct_field_info unit_item_use_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, time_in_use), TID(int32_t) },
    { FLD(PRIMITIVE, has_grown_attached), TID(int32_t) },
    { FLD(PRIMITIVE, affection_level), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_item_use::_identity(sizeof(unit_item_use), &allocator_fn<unit_item_use>, NULL, "unit_item_use",NULL,unit_item_use_fields);
  #define CUR_STRUCT unit_item_wrestle
  static const struct_field_info unit_item_wrestle_fields[] = {
    { FLD(PRIMITIVE, unit), TID(int32_t) },
    { FLD(PRIMITIVE, self_bp), TID(int32_t) },
    { FLD(PRIMITIVE, other_bp), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, item1), TID(int32_t) },
    { FLD(PRIMITIVE, item2), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int16_t) },
    { FLD(PRIMITIVE, unk_1e), TID(int8_t) },
    { FLD(PRIMITIVE, unk_20), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_item_wrestle::_identity(sizeof(unit_item_wrestle), &allocator_fn<unit_item_wrestle>, NULL, "unit_item_wrestle",NULL,unit_item_wrestle_fields);
  #define CUR_STRUCT enum_traits<unit_labor>::attr_entry_type
  static const struct_field_info enum_traits_lT_unit_labor_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, caption), identity_traits<const char*>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<unit_labor>::attr_entry_type::_identity(sizeof(enum_traits<unit_labor>::attr_entry_type), NULL, TID(unit_labor), "_attr_entry_type", NULL, enum_traits_lT_unit_labor_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT unit_misc_trait
  static const struct_field_info unit_misc_trait_fields[] = {
    { FLD(PRIMITIVE, id), TID(misc_trait_type) },
    { FLD(PRIMITIVE, value), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_misc_trait::_identity(sizeof(unit_misc_trait), &allocator_fn<unit_misc_trait>, NULL, "unit_misc_trait",NULL,unit_misc_trait_fields);
  #define CUR_STRUCT unit_personality::T_values
  static const struct_field_info unit_personality_doT_Dot_T_values_fields[] = {
    { FLD(PRIMITIVE, type), TID(value_type) },
    { FLD(PRIMITIVE, strength), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_personality::T_values::_identity(sizeof(unit_personality::T_values), &allocator_fn<unit_personality::T_values>, &unit_personality::_identity, "T_values",NULL,unit_personality_doT_Dot_T_values_fields);
  #define CUR_STRUCT unit_personality::T_unk_v40_2
  static const struct_field_info unit_personality_doT_Dot_T_unk_v40_2_fields[] = {
    { FLD(PRIMITIVE, unk1), TID(int16_t) },
    { FLD(PRIMITIVE, unk2), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_personality::T_unk_v40_2::_identity(sizeof(unit_personality::T_unk_v40_2), &allocator_fn<unit_personality::T_unk_v40_2>, &unit_personality::_identity, "T_unk_v40_2",NULL,unit_personality_doT_Dot_T_unk_v40_2_fields);
  #define CUR_STRUCT unit_personality::T_emotions
  static const struct_field_info unit_personality_doT_Dot_T_emotions_fields[] = {
    { FLD(PRIMITIVE, type), TID(emotion_type) },
    { FLD(PRIMITIVE, unk2), TID(int32_t) },
    { FLD(PRIMITIVE, strength), TID(int32_t) },
    { FLD(PRIMITIVE, thought), TID(unit_thought_type) },
    { FLD(PRIMITIVE, subthought), TID(int32_t) },
    { FLD(PRIMITIVE, severity), TID(int32_t) },
    { FLD(PRIMITIVE, flags), TID(int32_t) },
    { FLD(PRIMITIVE, unk7), TID(int32_t) },
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, year_tick), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_personality::T_emotions::_identity(sizeof(unit_personality::T_emotions), &allocator_fn<unit_personality::T_emotions>, &unit_personality::_identity, "T_emotions",NULL,unit_personality_doT_Dot_T_emotions_fields);
  #define CUR_STRUCT unit_personality::T_dreams
  static const struct_field_info unit_personality_doT_Dot_T_dreams_fields[] = {
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD(PRIMITIVE, type), TID(goal_type) },
    { FLD(PRIMITIVE, unk3), TID(int32_t) },
    { FLD(CONTAINER, unk4), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk8), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_personality::T_dreams::_identity(sizeof(unit_personality::T_dreams), &allocator_fn<unit_personality::T_dreams>, &unit_personality::_identity, "T_dreams",NULL,unit_personality_doT_Dot_T_dreams_fields);
  #define CUR_STRUCT unit_personality::T_unk_v40_6
  static const struct_field_info unit_personality_doT_Dot_T_unk_v40_6_fields[] = {
    { FLD(PRIMITIVE, unk1), TID(int32_t) },
    { FLD(PRIMITIVE, unk2), TID(int32_t) },
    { FLD(PRIMITIVE, unk3), TID(int32_t) },
    { FLD(PRIMITIVE, unk4), TID(int32_t) },
    { FLD(PRIMITIVE, unk5), TID(int32_t) },
    { FLD(PRIMITIVE, unk6), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_personality::T_unk_v40_6::_identity(sizeof(unit_personality::T_unk_v40_6), &allocator_fn<unit_personality::T_unk_v40_6>, &unit_personality::_identity, "T_unk_v40_6",NULL,unit_personality_doT_Dot_T_unk_v40_6_fields);
  #define CUR_STRUCT unit_personality::T_unk5
  static const struct_field_info unit_personality_doT_Dot_T_unk5_fields[] = {
    { FLD(PRIMITIVE, unk1), TID(int16_t) },
    { FLD(PRIMITIVE, unk2), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_personality::T_unk5::_identity(sizeof(unit_personality::T_unk5), &allocator_fn<unit_personality::T_unk5>, &unit_personality::_identity, "T_unk5",NULL,unit_personality_doT_Dot_T_unk5_fields);
  #define CUR_STRUCT unit_personality
  static const struct_field_info unit_personality_fields[] = {
    { FLD(STL_VECTOR_PTR, values), &unit_personality::T_values::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_v40_2), &unit_personality::T_unk_v40_2::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, emotions), &unit_personality::T_emotions::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, dreams), &unit_personality::T_dreams::_identity, 0, NULL },
    { FLD(PRIMITIVE, next_dream_id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_v40_6), &unit_personality::T_unk_v40_6::_identity, 0, NULL },
    { FLD(STATIC_ARRAY, traits), identity_traits<uint16_t >::get(), 50, TID(personality_facet_type) },
    { FLD(PRIMITIVE, civ_id), TID(int32_t) },
    { FLD(PRIMITIVE, cultural_identity), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk5), &unit_personality::T_unk5::_identity, 0, NULL },
    { FLD(CONTAINER, unk6), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, stress_level), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v4014_2), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v4014_3), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v4019_1), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v4019_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_personality::_identity(sizeof(unit_personality), &allocator_fn<unit_personality>, NULL, "unit_personality",NULL,unit_personality_fields);
  #define CUR_STRUCT unit_preference
  static const struct_field_info unit_preference_fields[] = {
    { FLD(PRIMITIVE, type), TID(unit_preference::T_type) },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, creature_id), TID(int16_t) },
    { FLD(PRIMITIVE, color_id), TID(int16_t) },
    { FLD(PRIMITIVE, shape_id), TID(int16_t) },
    { FLD(PRIMITIVE, plant_id), TID(int16_t) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mattype), TID(int16_t) },
    { FLD(PRIMITIVE, matindex), TID(int32_t) },
    { FLD(PRIMITIVE, active), TID(bool) },
    { FLD(PRIMITIVE, prefstring_seed), TID(uint32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_preference::_identity(sizeof(unit_preference), &allocator_fn<unit_preference>, NULL, "unit_preference",NULL,unit_preference_fields);
  #define CUR_STRUCT unit_request
  static const struct_field_info unit_request_fields[] = {
    { FLD(PRIMITIVE, type), TID(unit_request::T_type) },
    { FLD(PRIMITIVE, guild), identity_traits<enum_field<df::guild_id,int16_t> >::get() },
    { FLD(PRIMITIVE, count), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_request::_identity(sizeof(unit_request), &allocator_fn<unit_request>, NULL, "unit_request",NULL,unit_request_fields);
  #define CUR_STRUCT unit_skill
  static const struct_field_info unit_skill_fields[] = {
    { FLD(PRIMITIVE, id), TID(job_skill) },
    { FLD(PRIMITIVE, rating), TID(skill_rating) },
    { FLD(PRIMITIVE, experience), TID(int32_t) },
    { FLD(PRIMITIVE, unused_counter), TID(int32_t) },
    { FLD(PRIMITIVE, rusty), TID(int32_t) },
    { FLD(PRIMITIVE, rust_counter), TID(int32_t) },
    { FLD(PRIMITIVE, demotion_counter), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_skill::_identity(sizeof(unit_skill), &allocator_fn<unit_skill>, NULL, "unit_skill",NULL,unit_skill_fields);
  #define CUR_STRUCT unit_soul
  static const struct_field_info unit_soul_fields[] = {
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, race), TID(uint32_t) },
    { FLD(PRIMITIVE, sex), TID(int8_t) },
    { FLD(PRIMITIVE, caste), TID(uint16_t) },
    { FLD(SUBSTRUCT, orientation_flags), TID(orientation_flags) },
    { FLD(PRIMITIVE, unk2), TID(int32_t) },
    { FLD(PRIMITIVE, unk3), TID(int32_t) },
    { FLD(PRIMITIVE, unk4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(STATIC_ARRAY, mental_attrs), identity_traits<df::unit_attribute >::get(), 13, TID(mental_attribute_type) },
    { FLD(STL_VECTOR_PTR, skills), identity_traits<df::unit_skill >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, preferences), identity_traits<df::unit_preference >::get(), 0, NULL },
    { FLD(SUBSTRUCT, personality), &unit_personality::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_soul::_identity(sizeof(unit_soul), &allocator_fn<unit_soul>, NULL, "unit_soul",NULL,unit_soul_fields);
  #define CUR_STRUCT unit_syndrome::T_symptoms
  static const struct_field_info unit_syndrome_doT_Dot_T_symptoms_fields[] = {
    { FLD(PRIMITIVE, quantity), TID(int32_t) },
    { FLD(PRIMITIVE, delay), TID(int32_t) },
    { FLD(PRIMITIVE, ticks), TID(int32_t) },
    { FLD(CONTAINER, target_bp), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, target_layer), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, target_quantity), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, target_delay), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, target_ticks), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, flags), TID(unit_syndrome::T_symptoms::T_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_syndrome::T_symptoms::_identity(sizeof(unit_syndrome::T_symptoms), &allocator_fn<unit_syndrome::T_symptoms>, &unit_syndrome::_identity, "T_symptoms",NULL,unit_syndrome_doT_Dot_T_symptoms_fields);
  #define CUR_STRUCT unit_syndrome
  static const struct_field_info unit_syndrome_fields[] = {
    { FLD(PRIMITIVE, type), TID(int32_t) },
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, year_time), TID(int32_t) },
    { FLD(PRIMITIVE, ticks), TID(int32_t) },
    { FLD(CONTAINER, wounds), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, wound_id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, symptoms), &unit_syndrome::T_symptoms::_identity, 0, NULL },
    { FLD(PRIMITIVE, reinfection_count), TID(int16_t) },
    { FLD(SUBSTRUCT, flags), TID(unit_syndrome::T_flags) },
    { FLD(CONTAINER, unk4), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_syndrome::_identity(sizeof(unit_syndrome), &allocator_fn<unit_syndrome>, NULL, "unit_syndrome",NULL,unit_syndrome_fields);
  #define CUR_STRUCT enum_traits<unit_thought_type>::attr_entry_type
  static const struct_field_info enum_traits_lT_unit_thought_type_Gt__doT_Dot_attr_entry_type_fields[] = {
    { FLD(PRIMITIVE, caption), identity_traits<const char*>::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity enum_traits<unit_thought_type>::attr_entry_type::_identity(sizeof(enum_traits<unit_thought_type>::attr_entry_type), NULL, TID(unit_thought_type), "_attr_entry_type", NULL, enum_traits_lT_unit_thought_type_Gt__doT_Dot_attr_entry_type_fields);
  #define CUR_STRUCT unit_wound::T_parts
  static const struct_field_info unit_wound_doT_Dot_T_parts_fields[] = {
    { FLD(PRIMITIVE, global_layer_idx), TID(int32_t) },
    { FLD(PRIMITIVE, body_part_id), TID(int16_t) },
    { FLD(PRIMITIVE, layer_idx), TID(int16_t) },
    { FLD(PRIMITIVE, contact_area), TID(int32_t) },
    { FLD(PRIMITIVE, surface_perc), TID(int16_t) },
    { FLD(PRIMITIVE, strain), TID(int32_t) },
    { FLD(CONTAINER, effect_perc1), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, effect_perc2), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, effect_type), identity_traits<std::vector<df::wound_effect_type > >::get(), 0, NULL },
    { FLD(PRIMITIVE, edged_curve_perc), TID(int16_t) },
    { FLD(SUBSTRUCT, flags1), TID(wound_damage_flags1) },
    { FLD(SUBSTRUCT, flags2), TID(wound_damage_flags2) },
    { FLD(PRIMITIVE, bleeding), TID(int32_t) },
    { FLD(PRIMITIVE, pain), TID(int32_t) },
    { FLD(PRIMITIVE, nausea), TID(int32_t) },
    { FLD(PRIMITIVE, dizziness), TID(int32_t) },
    { FLD(PRIMITIVE, paralysis), TID(int32_t) },
    { FLD(PRIMITIVE, numbness), TID(int32_t) },
    { FLD(PRIMITIVE, swelling), TID(int32_t) },
    { FLD(PRIMITIVE, impaired), TID(int32_t) },
    { FLD(PRIMITIVE, cur_penetration_perc), TID(int16_t) },
    { FLD(PRIMITIVE, max_penetration_perc), TID(int16_t) },
    { FLD(PRIMITIVE, jammed_layer_idx), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v406_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_wound::T_parts::_identity(sizeof(unit_wound::T_parts), &allocator_fn<unit_wound::T_parts>, &unit_wound::_identity, "T_parts",NULL,unit_wound_doT_Dot_T_parts_fields);
  #define CUR_STRUCT unit_wound
  static const struct_field_info unit_wound_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, parts), &unit_wound::T_parts::_identity, 0, NULL },
    { FLD(PRIMITIVE, age), TID(int32_t) },
    { FLD(PRIMITIVE, attacker_unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, attacker_hist_figure_id), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(unit_wound::T_flags) },
    { FLD(PRIMITIVE, syndrome_id), TID(int32_t) },
    { FLD(PRIMITIVE, pain), TID(int32_t) },
    { FLD(PRIMITIVE, nausea), TID(int32_t) },
    { FLD(PRIMITIVE, dizziness), TID(int32_t) },
    { FLD(PRIMITIVE, paralysis), TID(int32_t) },
    { FLD(PRIMITIVE, numbness), TID(int32_t) },
    { FLD(PRIMITIVE, fever), TID(int32_t) },
    { FLD(POINTER, curse), identity_traits<df::wound_curse_info >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity unit_wound::_identity(sizeof(unit_wound), &allocator_fn<unit_wound>, NULL, "unit_wound",NULL,unit_wound_fields);
  #define CUR_STRUCT vehicle
  static const struct_field_info vehicle_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, item_id), TID(int32_t) },
    { FLD(PRIMITIVE, offset_x), TID(int32_t) },
    { FLD(PRIMITIVE, offset_y), TID(int32_t) },
    { FLD(PRIMITIVE, offset_z), TID(int32_t) },
    { FLD(PRIMITIVE, speed_x), TID(int32_t) },
    { FLD(PRIMITIVE, speed_y), TID(int32_t) },
    { FLD(PRIMITIVE, speed_z), TID(int32_t) },
    { FLD(PRIMITIVE, route_id), TID(int32_t) },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(PRIMITIVE, time_stopped), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity vehicle::_identity(sizeof(vehicle), &allocator_fn<vehicle>, NULL, "vehicle",NULL,vehicle_fields);
  #define CUR_STRUCT vermin
  static const struct_field_info vermin_fields[] = {
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(SUBSTRUCT, pos), &coord::_identity },
    { FLD(PRIMITIVE, visible), TID(bool) },
    { FLD(PRIMITIVE, countdown), TID(int16_t) },
    { FLD(POINTER, item), identity_traits<df::item >::get(), 0, NULL },
    { FLD(SUBSTRUCT, flags), TID(vermin_flags) },
    { FLD(PRIMITIVE, amount), TID(int32_t) },
    { FLD(SUBSTRUCT, population), &world_population_ref::_identity },
    { FLD(PRIMITIVE, unk_34), TID(int16_t) },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity vermin::_identity(sizeof(vermin), &allocator_fn<vermin>, NULL, "vermin",NULL,vermin_fields);
  #define CUR_STRUCT viewscreen
  static const struct_field_info viewscreen_fields[] = {
    { FLD(POINTER, child), identity_traits<df::viewscreen >::get(), 0, NULL },
    { FLD(POINTER, parent), identity_traits<df::viewscreen >::get(), 0, NULL },
    { FLD(PRIMITIVE, breakdown_level), TID(interface_breakdown_types) },
    { FLD(PRIMITIVE, option_key_pressed), TID(int8_t) },
    { METHOD(OBJ_METHOD, feed) },
    { METHOD(OBJ_METHOD, logic) },
    { METHOD(OBJ_METHOD, render) },
    { METHOD(OBJ_METHOD, resize) },
    { METHOD(OBJ_METHOD, help) },
    { METHOD(OBJ_METHOD, movies_okay) },
    { METHOD(OBJ_METHOD, is_option_screen) },
    { METHOD(OBJ_METHOD, is_save_screen) },
    { METHOD(OBJ_METHOD, key_conflict) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen::_identity(sizeof(viewscreen), &allocator_fn<viewscreen>, "viewscreen","viewscreenst",NULL,viewscreen_fields);
  #define CUR_STRUCT viewscreen_adventure_logst
  static const struct_field_info viewscreen_adventure_logst_fields[] = {
    { FLD(PRIMITIVE, mode), TID(viewscreen_adventure_logst::T_mode) },
    { FLD(PRIMITIVE, map_islocalview), TID(int8_t) },
    { FLD(PRIMITIVE, map_hidden), TID(int8_t) },
    { FLD(PRIMITIVE, player_region_x), TID(int16_t) },
    { FLD(PRIMITIVE, player_region_y), TID(int16_t) },
    { FLD(PRIMITIVE, player_local_x), TID(int16_t) },
    { FLD(PRIMITIVE, player_local_y), TID(int16_t) },
    { FLD(PRIMITIVE, unk_8), TID(int16_t) },
    { FLD(PRIMITIVE, unk_9), TID(int16_t) },
    { FLD(PRIMITIVE, unk_10), TID(int16_t) },
    { FLD(PRIMITIVE, unk_11), TID(int16_t) },
    { FLD(PRIMITIVE, cursor_x), TID(int16_t) },
    { FLD(PRIMITIVE, cursor_y), TID(int16_t) },
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(PRIMITIVE, map_draw_line), TID(int8_t) },
    { FLD(PRIMITIVE, info_mode), TID(viewscreen_adventure_logst::T_info_mode) },
    { FLD(PRIMITIVE, local_area_x1), TID(int16_t) },
    { FLD(PRIMITIVE, local_area_x2), TID(int16_t) },
    { FLD(PRIMITIVE, local_area_y1), TID(int16_t) },
    { FLD(PRIMITIVE, local_area_y2), TID(int16_t) },
    { FLD(PRIMITIVE, unk_v40_1a), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1b), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1d), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1e), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1f), TID(int32_t) },
    { FLD(PRIMITIVE, filter_str), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, in_filter), TID(int8_t) },
    { FLD(STATIC_ARRAY, items), identity_traits<std::vector<df::adventure_log_item* > >::get(), 8, NULL },
    { FLD(STATIC_ARRAY, filtered_items), identity_traits<std::vector<df::adventure_log_item* > >::get(), 8, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_adventure_logst::_identity(sizeof(viewscreen_adventure_logst), &allocator_fn<viewscreen_adventure_logst>, "viewscreen_adventure_logst",NULL,&viewscreen::_identity,viewscreen_adventure_logst_fields);
  #define CUR_STRUCT viewscreen_announcelistst
  static const struct_field_info viewscreen_announcelistst_fields[] = {
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, report_type), TID(unit_report_type) },
    { FLD(PRIMITIVE, sel_idx), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, reports), identity_traits<df::report >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_announcelistst::_identity(sizeof(viewscreen_announcelistst), &allocator_fn<viewscreen_announcelistst>, "viewscreen_announcelistst",NULL,&viewscreen::_identity,viewscreen_announcelistst_fields);
  #define CUR_STRUCT viewscreen_barterst
  static const struct_field_info viewscreen_barterst_fields[] = {
    { FLD(POINTER, anon_1), NULL, 0, NULL },
    { FLD(POINTER, anon_2), NULL, 0, NULL },
    { FLD(POINTER, anon_3), NULL, 0, NULL },
    { FLD(POINTER, anon_4), NULL, 0, NULL },
    { FLD(STATIC_ARRAY, anon_5), identity_traits<std::vector<void* > >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, anon_6), identity_traits<std::vector<void* > >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, anon_7), identity_traits<std::vector<void* > >::get(), 2, NULL },
    { FLD(CONTAINER, anon_8), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_9), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, anon_10), identity_traits<int32_t >::get(), 2, NULL },
    { FLD(PRIMITIVE, anon_11), TID(int8_t) },
    { FLD(PRIMITIVE, anon_12), TID(int16_t) },
    { FLD(PRIMITIVE, anon_13), TID(int8_t) },
    { FLD(PRIMITIVE, max_ask), TID(int32_t) },
    { FLD(PRIMITIVE, max_offer), TID(int32_t) },
    { FLD(PRIMITIVE, cur_ask), TID(int32_t) },
    { FLD(PRIMITIVE, cur_offer), TID(int32_t) },
    { FLD(PRIMITIVE, anon_14), TID(int16_t) },
    { FLD(PRIMITIVE, anon_15), TID(int8_t) },
    { FLD(PRIMITIVE, anon_16), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_barterst::_identity(sizeof(viewscreen_barterst), &allocator_fn<viewscreen_barterst>, "viewscreen_barterst",NULL,&viewscreen::_identity,viewscreen_barterst_fields);
  #define CUR_STRUCT viewscreen_buildinglistst
  static const struct_field_info viewscreen_buildinglistst_fields[] = {
    { FLD(PRIMITIVE, cursor), TID(int32_t) },
    { FLD(PRIMITIVE, alt_right_panel), TID(bool) },
    { FLD(STL_VECTOR_PTR, buildings), identity_traits<df::building >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, buildings2), identity_traits<df::building >::get(), 0, NULL },
    { FLD(CONTAINER, room_value), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, room_value2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_buildinglistst::_identity(sizeof(viewscreen_buildinglistst), &allocator_fn<viewscreen_buildinglistst>, "viewscreen_buildinglistst",NULL,&viewscreen::_identity,viewscreen_buildinglistst_fields);
  #define CUR_STRUCT viewscreen_buildingst
  static const struct_field_info viewscreen_buildingst_fields[] = {
    { FLD(POINTER, building), identity_traits<df::building >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_buildingst::_identity(sizeof(viewscreen_buildingst), &allocator_fn<viewscreen_buildingst>, "viewscreen_buildingst",NULL,&viewscreen::_identity,viewscreen_buildingst_fields);
  #define CUR_STRUCT viewscreen_choose_start_sitest::T_finder
  static const struct_field_info viewscreen_choose_start_sitest_doT_Dot_T_finder_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, search_x), TID(int32_t) },
    { FLD(PRIMITIVE, search_y), TID(int32_t) },
    { FLD(PRIMITIVE, cursor), TID(int32_t) },
    { FLD(STATIC_ARRAY, options), identity_traits<int32_t >::get(), 22, TID(embark_finder_option) },
    { FLD(STATIC_ARRAY, unmatched), identity_traits<bool >::get(), 22, TID(embark_finder_option) },
    { FLD(CONTAINER, visible_options), identity_traits<std::vector<df::embark_finder_option > >::get(), 0, NULL },
    { FLD(PRIMITIVE, finder_state), TID(int16_t) },
    { FLD(PRIMITIVE, unk_11e), TID(int16_t) },
    { FLD(PRIMITIVE, unk_120), TID(int16_t) },
    { FLD(PRIMITIVE, unk_122), TID(int16_t) },
    { FLD(PRIMITIVE, unk_124), TID(int16_t) },
    { FLD(PRIMITIVE, unk_126), TID(int16_t) },
    { FLD(PRIMITIVE, unk_128), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_choose_start_sitest::T_finder::_identity(sizeof(viewscreen_choose_start_sitest::T_finder), &allocator_fn<viewscreen_choose_start_sitest::T_finder>, &viewscreen_choose_start_sitest::_identity, "T_finder",NULL,viewscreen_choose_start_sitest_doT_Dot_T_finder_fields);
  #define CUR_STRUCT viewscreen_choose_start_sitest
  static const struct_field_info viewscreen_choose_start_sitest_fields[] = {
    { FLD(PRIMITIVE, page), TID(viewscreen_choose_start_sitest::T_page) },
    { FLD(SUBSTRUCT, location), &embark_location::_identity },
    { FLD(PRIMITIVE, biome_idx), TID(int32_t) },
    { FLD(PRIMITIVE, biome_highlighted), TID(bool) },
    { FLD(PRIMITIVE, in_embark_aquifer), TID(bool) },
    { FLD(PRIMITIVE, in_embark_salt), TID(bool) },
    { FLD(PRIMITIVE, in_embark_large), TID(bool) },
    { FLD(PRIMITIVE, in_embark_normal), TID(bool) },
    { FLD(STL_VECTOR_PTR, highlighted_sites), identity_traits<df::world_site >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, local_sites), identity_traits<df::world_site >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_74), TID(int32_t) },
    { FLD(PRIMITIVE, civ_idx), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, available_civs), identity_traits<df::historical_entity >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, site_info), identity_traits<std::string >::get(), 0, NULL },
    { FLD(POINTER, site_abandoned), identity_traits<df::history_event >::get(), 0, NULL },
    { FLD(POINTER, site_created), identity_traits<df::history_event >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_a4), TID(int32_t) },
    { FLD(SUBSTRUCT, finder), &viewscreen_choose_start_sitest::T_finder::_identity },
    { FLD(CONTAINER, unk_12c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_13c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_14c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_150), TID(int32_t) },
    { FLD(PRIMITIVE, unk_154), TID(int16_t) },
    { FLD(PRIMITIVE, unk_156), TID(int16_t) },
    { FLD(PRIMITIVE, unk_158), TID(int16_t) },
    { FLD(PRIMITIVE, unk_15a), TID(int16_t) },
    { FLD(PRIMITIVE, unk_15c), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_choose_start_sitest::_identity(sizeof(viewscreen_choose_start_sitest), &allocator_fn<viewscreen_choose_start_sitest>, "viewscreen_choose_start_sitest",NULL,&viewscreen::_identity,viewscreen_choose_start_sitest_fields);
  #define CUR_STRUCT viewscreen_civlistst
  static const struct_field_info viewscreen_civlistst_fields[] = {
    { FLD(PRIMITIVE, sel_idx), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, entities), identity_traits<df::historical_entity >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_civlistst::_identity(sizeof(viewscreen_civlistst), &allocator_fn<viewscreen_civlistst>, "viewscreen_civlistst",NULL,&viewscreen::_identity,viewscreen_civlistst_fields);
  #define CUR_STRUCT viewscreen_conversationst
  static const struct_field_info viewscreen_conversationst_fields[] = {
    { FLD(POINTER, conversation), identity_traits<df::conversation >::get(), 0, NULL },
    { FLD(PRIMITIVE, cursor_speech_line), TID(int32_t) },
    { FLD(PRIMITIVE, current_question), TID(int32_t) },
    { FLD(PRIMITIVE, cursor_line), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_conversationst::_identity(sizeof(viewscreen_conversationst), &allocator_fn<viewscreen_conversationst>, "viewscreen_conversationst",NULL,&viewscreen::_identity,viewscreen_conversationst_fields);
  #define CUR_STRUCT viewscreen_createquotast
  static const struct_field_info viewscreen_createquotast_fields[] = {
    { FLD(STATIC_STRING, str_filter), NULL, 256 },
    { FLD(PRIMITIVE, top_idx), TID(int32_t) },
    { FLD(PRIMITIVE, sel_idx), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, orders), identity_traits<df::manager_order_template >::get(), 0, NULL },
    { FLD(CONTAINER, pages), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, want_quantity), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_createquotast::_identity(sizeof(viewscreen_createquotast), &allocator_fn<viewscreen_createquotast>, "viewscreen_createquotast",NULL,&viewscreen::_identity,viewscreen_createquotast_fields);
  #define CUR_STRUCT viewscreen_customize_unitst
  static const struct_field_info viewscreen_customize_unitst_fields[] = {
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, editing_nickname), TID(int8_t) },
    { FLD(PRIMITIVE, editing_profession), TID(int8_t) },
    { FLD(PRIMITIVE, previous_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, has_name), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_customize_unitst::_identity(sizeof(viewscreen_customize_unitst), &allocator_fn<viewscreen_customize_unitst>, "viewscreen_customize_unitst",NULL,&viewscreen::_identity,viewscreen_customize_unitst_fields);
  #define CUR_STRUCT viewscreen_dungeon_monsterstatusst
  static const struct_field_info viewscreen_dungeon_monsterstatusst_fields[] = {
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, inventory_cursor), TID(int32_t) },
    { FLD(PRIMITIVE, body_part_cursor), TID(int32_t) },
    { FLD(CONTAINER, body_part), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, view_skills), TID(bool) },
    { FLD(STL_VECTOR_PTR, inventory), identity_traits<df::unit_inventory_item >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, spatters), identity_traits<df::spatter >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_dungeon_monsterstatusst::_identity(sizeof(viewscreen_dungeon_monsterstatusst), &allocator_fn<viewscreen_dungeon_monsterstatusst>, "viewscreen_dungeon_monsterstatusst",NULL,&viewscreen::_identity,viewscreen_dungeon_monsterstatusst_fields);
  #define CUR_STRUCT viewscreen_dungeon_wrestlest::T_unk1
  static const struct_field_info viewscreen_dungeon_wrestlest_doT_Dot_T_unk1_fields[] = {
    { FLD(POINTER, anon_1), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_2), TID(int8_t) },
    { FLD(PRIMITIVE, anon_3), TID(int8_t) },
    { FLD(STL_VECTOR_PTR, weapons), identity_traits<df::item >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_6), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_8), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_9), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_10), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_11), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_12), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_13), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_14), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_15), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_16), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_17), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_dungeon_wrestlest::T_unk1::_identity(sizeof(viewscreen_dungeon_wrestlest::T_unk1), &allocator_fn<viewscreen_dungeon_wrestlest::T_unk1>, &viewscreen_dungeon_wrestlest::_identity, "T_unk1",NULL,viewscreen_dungeon_wrestlest_doT_Dot_T_unk1_fields);
  #define CUR_STRUCT viewscreen_dungeon_wrestlest
  static const struct_field_info viewscreen_dungeon_wrestlest_fields[] = {
    { FLD(POINTER, player), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, target), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(CONTAINER, anon_6), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, unk1), &viewscreen_dungeon_wrestlest::T_unk1::_identity },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD(PRIMITIVE, anon_9), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_dungeon_wrestlest::_identity(sizeof(viewscreen_dungeon_wrestlest), &allocator_fn<viewscreen_dungeon_wrestlest>, "viewscreen_dungeon_wrestlest",NULL,&viewscreen::_identity,viewscreen_dungeon_wrestlest_fields);
  #define CUR_STRUCT viewscreen_dungeonmodest
  static const struct_field_info viewscreen_dungeonmodest_fields[] = {
    { FLD(PRIMITIVE, x), TID(int32_t) },
    { FLD(PRIMITIVE, y), TID(int32_t) },
    { FLD(PRIMITIVE, z), TID(int32_t) },
    { FLD(PRIMITIVE, announce_y), TID(int32_t) },
    { FLD(PRIMITIVE, announce_idx), TID(int32_t) },
    { FLD(PRIMITIVE, announce_more), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_dungeonmodest::_identity(sizeof(viewscreen_dungeonmodest), &allocator_fn<viewscreen_dungeonmodest>, "viewscreen_dungeonmodest",NULL,&viewscreen::_identity,viewscreen_dungeonmodest_fields);
  #define CUR_STRUCT viewscreen_dwarfmodest
  static const struct_field_info viewscreen_dwarfmodest_fields[] = {
    { FLD(PRIMITIVE, shown_site_name), TID(int8_t) },
    { FLD(PRIMITIVE, jeweler_mat_count), TID(int16_t) },
    { FLD(CONTAINER, jeweler_cutgem), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, jeweler_encrust), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unit_labors_sidemenu), identity_traits<std::vector<df::unit_labor > >::get(), 0, NULL },
    { FLD(CONTAINER, unit_labors_sidemenu_uplevel), identity_traits<std::vector<df::unit_labor > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unit_labors_sidemenu_uplevel_idx), TID(int32_t) },
    { FLD(PRIMITIVE, sideSubmenu), TID(int8_t) },
    { FLD(PRIMITIVE, keyRepeat), TID(int8_t) },
    { FLD(STL_VECTOR_PTR, trained_animals), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, trained_animal_idx), TID(int32_t) },
    { FLD(PRIMITIVE, number_assigned_hunt), TID(int32_t) },
    { FLD(PRIMITIVE, number_assigned_war), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_dwarfmodest::_identity(sizeof(viewscreen_dwarfmodest), &allocator_fn<viewscreen_dwarfmodest>, "viewscreen_dwarfmodest",NULL,&viewscreen::_identity,viewscreen_dwarfmodest_fields);
  #define CUR_STRUCT viewscreen_entityst
  static const struct_field_info viewscreen_entityst_fields[] = {
    { FLD(POINTER, entity), identity_traits<df::historical_entity >::get(), 0, NULL },
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, important_leader_nemesis), identity_traits<df::nemesis_record >::get(), 0, NULL },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, start_idx), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, agreements), identity_traits<df::meeting_event >::get(), 0, NULL },
    { FLD(CONTAINER, agreement_status), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, agreement_cursor), TID(int32_t) },
    { FLD(PRIMITIVE, page), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_entityst::_identity(sizeof(viewscreen_entityst), &allocator_fn<viewscreen_entityst>, "viewscreen_entityst",NULL,&viewscreen::_identity,viewscreen_entityst_fields);
  #define CUR_STRUCT viewscreen_export_graphical_mapst
  static const struct_field_info viewscreen_export_graphical_mapst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), TID(int16_t) },
    { FLD(PRIMITIVE, anon_3), TID(int16_t) },
    { FLD(PRIMITIVE, anon_4), TID(int16_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD(PRIMITIVE, anon_9), TID(int32_t) },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { FLD(PRIMITIVE, anon_11), TID(int32_t) },
    { FLD(PRIMITIVE, anon_12), TID(int8_t) },
    { FLD(PRIMITIVE, sel_idx), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_export_graphical_mapst::_identity(sizeof(viewscreen_export_graphical_mapst), &allocator_fn<viewscreen_export_graphical_mapst>, "viewscreen_export_graphical_mapst",NULL,&viewscreen::_identity,viewscreen_export_graphical_mapst_fields);
  #define CUR_STRUCT viewscreen_export_regionst
  static const struct_field_info viewscreen_export_regionst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_export_regionst::_identity(sizeof(viewscreen_export_regionst), &allocator_fn<viewscreen_export_regionst>, "viewscreen_export_regionst",NULL,&viewscreen::_identity,viewscreen_export_regionst_fields);
  #define CUR_STRUCT viewscreen_game_cleanerst
  static const struct_field_info viewscreen_game_cleanerst_fields[] = {
    { FLD(PRIMITIVE, state), TID(viewscreen_game_cleanerst::T_state) },
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_game_cleanerst::_identity(sizeof(viewscreen_game_cleanerst), &allocator_fn<viewscreen_game_cleanerst>, "viewscreen_game_cleanerst",NULL,&viewscreen::_identity,viewscreen_game_cleanerst_fields);
  #define CUR_STRUCT viewscreen_itemst
  static const struct_field_info viewscreen_itemst_fields[] = {
    { FLD(POINTER, item), identity_traits<df::item >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, entry_ref), identity_traits<df::general_ref >::get(), 0, NULL },
    { FLD(CONTAINER, entry_indent), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_34), NULL, 0, NULL },
    { FLD(STL_VECTOR_PTR, entry_string), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, entry_reaction), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, cursor_pos), TID(int32_t) },
    { FLD(PRIMITIVE, caption_uses), TID(bool) },
    { FLD(PRIMITIVE, caption_contents), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_itemst::_identity(sizeof(viewscreen_itemst), &allocator_fn<viewscreen_itemst>, "viewscreen_itemst",NULL,&viewscreen::_identity,viewscreen_itemst_fields);
  #define CUR_STRUCT viewscreen_joblistst
  static const struct_field_info viewscreen_joblistst_fields[] = {
    { FLD(PRIMITIVE, allow_zoom), TID(bool) },
    { FLD(PRIMITIVE, cursor_pos), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, jobs), identity_traits<df::job >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, units), identity_traits<df::unit >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_joblistst::_identity(sizeof(viewscreen_joblistst), &allocator_fn<viewscreen_joblistst>, "viewscreen_joblistst",NULL,&viewscreen::_identity,viewscreen_joblistst_fields);
  #define CUR_STRUCT viewscreen_jobmanagementst
  static const struct_field_info viewscreen_jobmanagementst_fields[] = {
    { FLD(PRIMITIVE, sel_idx), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_jobmanagementst::_identity(sizeof(viewscreen_jobmanagementst), &allocator_fn<viewscreen_jobmanagementst>, "viewscreen_jobmanagementst",NULL,&viewscreen::_identity,viewscreen_jobmanagementst_fields);
  #define CUR_STRUCT viewscreen_jobst
  static const struct_field_info viewscreen_jobst_fields[] = {
    { FLD(POINTER, job), identity_traits<df::job >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_jobst::_identity(sizeof(viewscreen_jobst), &allocator_fn<viewscreen_jobst>, "viewscreen_jobst",NULL,&viewscreen::_identity,viewscreen_jobst_fields);
  #define CUR_STRUCT viewscreen_justicest
  static const struct_field_info viewscreen_justicest_fields[] = {
    { FLD(PRIMITIVE, jails_needed), TID(int16_t) },
    { FLD(PRIMITIVE, jails_present), TID(int16_t) },
    { FLD(PRIMITIVE, cur_column), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, convicts), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, recent_cases), identity_traits<df::crime >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, cold_cases), TID(bool) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, cursor_right), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, convictions), identity_traits<df::crime >::get(), 0, NULL },
    { FLD(POINTER, punishment), identity_traits<df::punishment >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_6), identity_traits<df::unit >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_justicest::_identity(sizeof(viewscreen_justicest), &allocator_fn<viewscreen_justicest>, "viewscreen_justicest",NULL,&viewscreen::_identity,viewscreen_justicest_fields);
  #define CUR_STRUCT viewscreen_kitchenprefst
  static const struct_field_info viewscreen_kitchenprefst_fields[] = {
    { FLD(PRIMITIVE, cursor), TID(int32_t) },
    { FLD(CONTAINER, item_type), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, item_subtype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mat_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mat_index), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, count), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, forbidden), identity_traits<std::vector<uint8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, possible), identity_traits<std::vector<uint8_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_kitchenprefst::_identity(sizeof(viewscreen_kitchenprefst), &allocator_fn<viewscreen_kitchenprefst>, "viewscreen_kitchenprefst",NULL,&viewscreen::_identity,viewscreen_kitchenprefst_fields);
  #define CUR_STRUCT viewscreen_layer
  static const struct_field_info viewscreen_layer_fields[] = {
    { FLD(STL_VECTOR_PTR, layer_objects), identity_traits<df::layer_object >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer::_identity(sizeof(viewscreen_layer), &allocator_fn<viewscreen_layer>, "viewscreen_layer","viewscreen_layerst",&viewscreen::_identity,viewscreen_layer_fields);
  #define CUR_STRUCT viewscreen_layer_arena_creaturest
  static const struct_field_info viewscreen_layer_arena_creaturest_fields[] = {
    { FLD(PRIMITIVE, unk_1c), TID(int8_t) },
    { FLD(PRIMITIVE, unk_1e), TID(int16_t) },
    { FLD(PRIMITIVE, cur_side), TID(int32_t) },
    { FLD(PRIMITIVE, cur_interaction), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_arena_creaturest::_identity(sizeof(viewscreen_layer_arena_creaturest), &allocator_fn<viewscreen_layer_arena_creaturest>, "viewscreen_layer_arena_creaturest",NULL,&viewscreen_layer::_identity,viewscreen_layer_arena_creaturest_fields);
  #define CUR_STRUCT viewscreen_layer_assigntradest
  static const struct_field_info viewscreen_layer_assigntradest_fields[] = {
    { FLD(STL_VECTOR_PTR, info), identity_traits<df::assign_trade_status >::get(), 0, NULL },
    { FLD(POINTER, depot), identity_traits<df::building_tradedepotst >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, lists), identity_traits<std::vector<int32_t > >::get(), 63, NULL },
    { FLD(CONTAINER, visible_lists), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, sort_distance), TID(bool) },
    { FLD(PRIMITIVE, pending_on_top), TID(bool) },
    { FLD(PRIMITIVE, filter_mandates), TID(bool) },
    { FLD(PRIMITIVE, filter), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_assigntradest::_identity(sizeof(viewscreen_layer_assigntradest), &allocator_fn<viewscreen_layer_assigntradest>, "viewscreen_layer_assigntradest",NULL,&viewscreen_layer::_identity,viewscreen_layer_assigntradest_fields);
  #define CUR_STRUCT viewscreen_layer_choose_language_namest
  static const struct_field_info viewscreen_layer_choose_language_namest_fields[] = {
    { FLD(POINTER, entity), identity_traits<df::historical_entity >::get(), 0, NULL },
    { FLD(POINTER, name), identity_traits<df::language_name >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk1a), TID(int32_t) },
    { FLD(PRIMITIVE, unk1b), TID(int32_t) },
    { FLD(PRIMITIVE, unk1c), TID(int32_t) },
    { FLD(SUBSTRUCT, dictionary), &language_word_table::_identity },
    { FLD(CONTAINER, list_word), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, list_part), identity_traits<std::vector<df::part_of_speech > >::get(), 0, NULL },
    { FLD(PRIMITIVE, selector), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_choose_language_namest::_identity(sizeof(viewscreen_layer_choose_language_namest), &allocator_fn<viewscreen_layer_choose_language_namest>, "viewscreen_layer_choose_language_namest",NULL,&viewscreen_layer::_identity,viewscreen_layer_choose_language_namest_fields);
  #define CUR_STRUCT viewscreen_layer_currencyst
  static const struct_field_info viewscreen_layer_currencyst_fields[] = {
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_currencyst::_identity(sizeof(viewscreen_layer_currencyst), &allocator_fn<viewscreen_layer_currencyst>, "viewscreen_layer_currencyst",NULL,&viewscreen_layer::_identity,viewscreen_layer_currencyst_fields);
  #define CUR_STRUCT viewscreen_layer_export_play_mapst
  static const struct_field_info viewscreen_layer_export_play_mapst_fields[] = {
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_export_play_mapst::_identity(sizeof(viewscreen_layer_export_play_mapst), &allocator_fn<viewscreen_layer_export_play_mapst>, "viewscreen_layer_export_play_mapst",NULL,&viewscreen_layer::_identity,viewscreen_layer_export_play_mapst_fields);
  #define CUR_STRUCT viewscreen_layer_militaryst::T_squads
  static const struct_field_info viewscreen_layer_militaryst_doT_Dot_T_squads_fields[] = {
    { FLD(STL_VECTOR_PTR, list), identity_traits<df::squad >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, leader_positions), identity_traits<df::entity_position >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, leader_assignments), identity_traits<df::entity_position_assignment >::get(), 0, NULL },
    { FLD(CONTAINER, can_appoint), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_militaryst::T_squads::_identity(sizeof(viewscreen_layer_militaryst::T_squads), &allocator_fn<viewscreen_layer_militaryst::T_squads>, &viewscreen_layer_militaryst::_identity, "T_squads",NULL,viewscreen_layer_militaryst_doT_Dot_T_squads_fields);
  #define CUR_STRUCT viewscreen_layer_militaryst::T_positions
  static const struct_field_info viewscreen_layer_militaryst_doT_Dot_T_positions_fields[] = {
    { FLD(STL_VECTOR_PTR, assigned), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(CONTAINER, skill), identity_traits<std::vector<df::job_skill > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_84), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, candidates), identity_traits<df::unit >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_militaryst::T_positions::_identity(sizeof(viewscreen_layer_militaryst::T_positions), &allocator_fn<viewscreen_layer_militaryst::T_positions>, &viewscreen_layer_militaryst::_identity, "T_positions",NULL,viewscreen_layer_militaryst_doT_Dot_T_positions_fields);
  #define CUR_STRUCT viewscreen_layer_militaryst::T_squad_members
  static const struct_field_info viewscreen_layer_militaryst_doT_Dot_T_squad_members_fields[] = {
    { FLD(CONTAINER, profession), identity_traits<std::vector<df::profession > >::get(), 0, NULL },
    { FLD(CONTAINER, count), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, max_count), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_militaryst::T_squad_members::_identity(sizeof(viewscreen_layer_militaryst::T_squad_members), &allocator_fn<viewscreen_layer_militaryst::T_squad_members>, &viewscreen_layer_militaryst::_identity, "T_squad_members",NULL,viewscreen_layer_militaryst_doT_Dot_T_squad_members_fields);
  #define CUR_STRUCT viewscreen_layer_militaryst::T_equip::T_assigned
  static const struct_field_info viewscreen_layer_militaryst_doT_Dot_T_equip_doT_Dot_T_assigned_fields[] = {
    { FLD(STL_VECTOR_PTR, spec), identity_traits<df::squad_uniform_spec >::get(), 0, NULL },
    { FLD(CONTAINER, category), identity_traits<std::vector<df::uniform_category > >::get(), 0, NULL },
    { FLD(CONTAINER, index), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_militaryst::T_equip::T_assigned::_identity(sizeof(viewscreen_layer_militaryst::T_equip::T_assigned), &allocator_fn<viewscreen_layer_militaryst::T_equip::T_assigned>, &viewscreen_layer_militaryst::T_equip::_identity, "T_assigned",NULL,viewscreen_layer_militaryst_doT_Dot_T_equip_doT_Dot_T_assigned_fields);
  #define CUR_STRUCT viewscreen_layer_militaryst::T_equip::T_uniform
  static const struct_field_info viewscreen_layer_militaryst_doT_Dot_T_equip_doT_Dot_T_uniform_fields[] = {
    { FLD(CONTAINER, type), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, subtype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, category), identity_traits<std::vector<df::uniform_category > >::get(), 0, NULL },
    { FLD(CONTAINER, index), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, info), identity_traits<df::entity_uniform_item >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_militaryst::T_equip::T_uniform::_identity(sizeof(viewscreen_layer_militaryst::T_equip::T_uniform), &allocator_fn<viewscreen_layer_militaryst::T_equip::T_uniform>, &viewscreen_layer_militaryst::T_equip::_identity, "T_uniform",NULL,viewscreen_layer_militaryst_doT_Dot_T_equip_doT_Dot_T_uniform_fields);
  #define CUR_STRUCT viewscreen_layer_militaryst::T_equip::T_add_item
  static const struct_field_info viewscreen_layer_militaryst_doT_Dot_T_equip_doT_Dot_T_add_item_fields[] = {
    { FLD(CONTAINER, type), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, subtype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_214), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, foreign), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_militaryst::T_equip::T_add_item::_identity(sizeof(viewscreen_layer_militaryst::T_equip::T_add_item), &allocator_fn<viewscreen_layer_militaryst::T_equip::T_add_item>, &viewscreen_layer_militaryst::T_equip::_identity, "T_add_item",NULL,viewscreen_layer_militaryst_doT_Dot_T_equip_doT_Dot_T_add_item_fields);
  #define CUR_STRUCT viewscreen_layer_militaryst::T_equip::T_material
  static const struct_field_info viewscreen_layer_militaryst_doT_Dot_T_equip_doT_Dot_T_material_fields[] = {
    { FLD(CONTAINER, generic), identity_traits<std::vector<df::entity_material_category > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, specific), &material_vec_ref::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_militaryst::T_equip::T_material::_identity(sizeof(viewscreen_layer_militaryst::T_equip::T_material), &allocator_fn<viewscreen_layer_militaryst::T_equip::T_material>, &viewscreen_layer_militaryst::T_equip::_identity, "T_material",NULL,viewscreen_layer_militaryst_doT_Dot_T_equip_doT_Dot_T_material_fields);
  #define CUR_STRUCT viewscreen_layer_militaryst::T_equip::T_color
  static const struct_field_info viewscreen_layer_militaryst_doT_Dot_T_equip_doT_Dot_T_color_fields[] = {
    { FLD(CONTAINER, id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, dye), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_militaryst::T_equip::T_color::_identity(sizeof(viewscreen_layer_militaryst::T_equip::T_color), &allocator_fn<viewscreen_layer_militaryst::T_equip::T_color>, &viewscreen_layer_militaryst::T_equip::_identity, "T_color",NULL,viewscreen_layer_militaryst_doT_Dot_T_equip_doT_Dot_T_color_fields);
  #define CUR_STRUCT viewscreen_layer_militaryst::T_equip
  static const struct_field_info viewscreen_layer_militaryst_doT_Dot_T_equip_fields[] = {
    { FLD(PRIMITIVE, mode), TID(viewscreen_layer_militaryst::T_equip::T_mode) },
    { FLD(STL_VECTOR_PTR, squads), identity_traits<df::squad >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, units), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, specific_items), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, prio_in_move), TID(int32_t) },
    { FLD(SUBSTRUCT, assigned), &viewscreen_layer_militaryst::T_equip::T_assigned::_identity },
    { FLD(CONTAINER, unk_178), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(POINTER, edit_spec), identity_traits<df::squad_uniform_spec >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, uniforms), identity_traits<df::entity_uniform >::get(), 0, NULL },
    { FLD(SUBSTRUCT, uniform), &viewscreen_layer_militaryst::T_equip::T_uniform::_identity },
    { FLD(PRIMITIVE, edit_mode), TID(viewscreen_layer_militaryst::T_equip::T_edit_mode) },
    { FLD(SUBSTRUCT, add_item), &viewscreen_layer_militaryst::T_equip::T_add_item::_identity },
    { FLD(SUBSTRUCT, material), &viewscreen_layer_militaryst::T_equip::T_material::_identity },
    { FLD(SUBSTRUCT, color), &viewscreen_layer_militaryst::T_equip::T_color::_identity },
    { FLD(PRIMITIVE, in_name_uniform), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_militaryst::T_equip::_identity(sizeof(viewscreen_layer_militaryst::T_equip), &allocator_fn<viewscreen_layer_militaryst::T_equip>, &viewscreen_layer_militaryst::_identity, "T_equip",NULL,viewscreen_layer_militaryst_doT_Dot_T_equip_fields);
  #define CUR_STRUCT viewscreen_layer_militaryst::T_ammo::T_add_item
  static const struct_field_info viewscreen_layer_militaryst_doT_Dot_T_ammo_doT_Dot_T_add_item_fields[] = {
    { FLD(CONTAINER, type), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, subtype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, foreign), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_militaryst::T_ammo::T_add_item::_identity(sizeof(viewscreen_layer_militaryst::T_ammo::T_add_item), &allocator_fn<viewscreen_layer_militaryst::T_ammo::T_add_item>, &viewscreen_layer_militaryst::T_ammo::_identity, "T_add_item",NULL,viewscreen_layer_militaryst_doT_Dot_T_ammo_doT_Dot_T_add_item_fields);
  #define CUR_STRUCT viewscreen_layer_militaryst::T_ammo::T_material
  static const struct_field_info viewscreen_layer_militaryst_doT_Dot_T_ammo_doT_Dot_T_material_fields[] = {
    { FLD(CONTAINER, generic), identity_traits<std::vector<df::entity_material_category > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, specific), &material_vec_ref::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_militaryst::T_ammo::T_material::_identity(sizeof(viewscreen_layer_militaryst::T_ammo::T_material), &allocator_fn<viewscreen_layer_militaryst::T_ammo::T_material>, &viewscreen_layer_militaryst::T_ammo::_identity, "T_material",NULL,viewscreen_layer_militaryst_doT_Dot_T_ammo_doT_Dot_T_material_fields);
  #define CUR_STRUCT viewscreen_layer_militaryst::T_ammo
  static const struct_field_info viewscreen_layer_militaryst_doT_Dot_T_ammo_fields[] = {
    { FLD(STL_VECTOR_PTR, squads), identity_traits<df::squad >::get(), 0, NULL },
    { FLD(PRIMITIVE, in_add_item), TID(bool) },
    { FLD(PRIMITIVE, in_set_material), TID(bool) },
    { FLD(SUBSTRUCT, add_item), &viewscreen_layer_militaryst::T_ammo::T_add_item::_identity },
    { FLD(SUBSTRUCT, material), &viewscreen_layer_militaryst::T_ammo::T_material::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_militaryst::T_ammo::_identity(sizeof(viewscreen_layer_militaryst::T_ammo), &allocator_fn<viewscreen_layer_militaryst::T_ammo>, &viewscreen_layer_militaryst::_identity, "T_ammo",NULL,viewscreen_layer_militaryst_doT_Dot_T_ammo_fields);
  #define CUR_STRUCT viewscreen_layer_militaryst
  static const struct_field_info viewscreen_layer_militaryst_fields[] = {
    { FLD(SUBSTRUCT, squads), &viewscreen_layer_militaryst::T_squads::_identity },
    { FLD(SUBSTRUCT, positions), &viewscreen_layer_militaryst::T_positions::_identity },
    { FLD(PRIMITIVE, page), TID(viewscreen_layer_militaryst::T_page) },
    { FLD(PRIMITIVE, num_squads), TID(int32_t) },
    { FLD(PRIMITIVE, num_soldiers), TID(int32_t) },
    { FLD(PRIMITIVE, num_active), TID(int32_t) },
    { FLD(SUBSTRUCT, squad_members), &viewscreen_layer_militaryst::T_squad_members::_identity },
    { FLD(PRIMITIVE, in_create_squad), TID(bool) },
    { FLD(PRIMITIVE, in_new_squad), TID(bool) },
    { FLD(PRIMITIVE, unk_e6), TID(bool) },
    { FLD(STL_VECTOR_PTR, captain_positions), identity_traits<df::entity_position >::get(), 0, NULL },
    { FLD(POINTER, new_position), identity_traits<df::entity_position >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_fc), TID(bool) },
    { FLD(PRIMITIVE, in_rename_alert), TID(bool) },
    { FLD(PRIMITIVE, in_delete_alert), TID(bool) },
    { FLD(STL_VECTOR_PTR, alert_squads), identity_traits<df::squad >::get(), 0, NULL },
    { FLD(SUBSTRUCT, equip), &viewscreen_layer_militaryst::T_equip::_identity },
    { FLD(SUBSTRUCT, ammo), &viewscreen_layer_militaryst::T_ammo::_identity },
    { FLD(STL_VECTOR_PTR, supplies_squads), identity_traits<df::squad >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_militaryst::_identity(sizeof(viewscreen_layer_militaryst), &allocator_fn<viewscreen_layer_militaryst>, "viewscreen_layer_militaryst",NULL,&viewscreen_layer::_identity,viewscreen_layer_militaryst_fields);
  virtual_identity viewscreen_layer_musicsoundst::_identity(sizeof(viewscreen_layer_musicsoundst), &allocator_fn<viewscreen_layer_musicsoundst>, "viewscreen_layer_musicsoundst",NULL,&viewscreen_layer::_identity,NULL);
  #define CUR_STRUCT viewscreen_layer_noblelistst::T_info
  static const struct_field_info viewscreen_layer_noblelistst_doT_Dot_T_info_fields[] = {
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, nemesis), identity_traits<df::nemesis_record >::get(), 0, NULL },
    { FLD(POINTER, unk_8), NULL, 0, NULL },
    { FLD(POINTER, position), identity_traits<df::entity_position >::get(), 0, NULL },
    { FLD(POINTER, assignment), identity_traits<df::entity_position_assignment >::get(), 0, NULL },
    { FLD(PRIMITIVE, group), TID(int32_t) },
    { FLD(PRIMITIVE, precedence), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_noblelistst::T_info::_identity(sizeof(viewscreen_layer_noblelistst::T_info), &allocator_fn<viewscreen_layer_noblelistst::T_info>, &viewscreen_layer_noblelistst::_identity, "T_info",NULL,viewscreen_layer_noblelistst_doT_Dot_T_info_fields);
  #define CUR_STRUCT viewscreen_layer_noblelistst::T_candidates
  static const struct_field_info viewscreen_layer_noblelistst_doT_Dot_T_candidates_fields[] = {
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, weight), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_noblelistst::T_candidates::_identity(sizeof(viewscreen_layer_noblelistst::T_candidates), &allocator_fn<viewscreen_layer_noblelistst::T_candidates>, &viewscreen_layer_noblelistst::_identity, "T_candidates",NULL,viewscreen_layer_noblelistst_doT_Dot_T_candidates_fields);
  #define CUR_STRUCT viewscreen_layer_noblelistst
  static const struct_field_info viewscreen_layer_noblelistst_fields[] = {
    { FLD(PRIMITIVE, mode), TID(viewscreen_layer_noblelistst::T_mode) },
    { FLD(STL_VECTOR_PTR, info), &viewscreen_layer_noblelistst::T_info::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, candidates), &viewscreen_layer_noblelistst::T_candidates::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, assignments), identity_traits<df::entity_position_assignment >::get(), 0, NULL },
    { FLD(CONTAINER, histfigs), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, groups), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_noblelistst::_identity(sizeof(viewscreen_layer_noblelistst), &allocator_fn<viewscreen_layer_noblelistst>, "viewscreen_layer_noblelistst",NULL,&viewscreen_layer::_identity,viewscreen_layer_noblelistst_fields);
  #define CUR_STRUCT viewscreen_layer_overall_healthst
  static const struct_field_info viewscreen_layer_overall_healthst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(CONTAINER, bits1), identity_traits<std::vector<df::health_view_bits1 > >::get(), 0, NULL },
    { FLD(CONTAINER, bits2), identity_traits<std::vector<df::health_view_bits2 > >::get(), 0, NULL },
    { FLD(CONTAINER, bits3), identity_traits<std::vector<df::health_view_bits3 > >::get(), 0, NULL },
    { FLD(PRIMITIVE, x_cursor_pos), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_overall_healthst::_identity(sizeof(viewscreen_layer_overall_healthst), &allocator_fn<viewscreen_layer_overall_healthst>, "viewscreen_layer_overall_healthst",NULL,&viewscreen_layer::_identity,viewscreen_layer_overall_healthst_fields);
  #define CUR_STRUCT viewscreen_layer_reactionst
  static const struct_field_info viewscreen_layer_reactionst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_reactionst::_identity(sizeof(viewscreen_layer_reactionst), &allocator_fn<viewscreen_layer_reactionst>, "viewscreen_layer_reactionst",NULL,&viewscreen_layer::_identity,viewscreen_layer_reactionst_fields);
  #define CUR_STRUCT viewscreen_layer_squad_schedulest
  static const struct_field_info viewscreen_layer_squad_schedulest_fields[] = {
    { FLD(STL_VECTOR_PTR, squads), identity_traits<df::squad >::get(), 0, NULL },
    { FLD(PRIMITIVE, swapped), TID(int8_t) },
    { FLD(PRIMITIVE, page_month), TID(int32_t) },
    { FLD(PRIMITIVE, cur_alert), TID(int32_t) },
    { FLD(PRIMITIVE, in_name_cell), TID(bool) },
    { FLD(PRIMITIVE, in_give_order), TID(bool) },
    { FLD(PRIMITIVE, in_edit_order), TID(bool) },
    { FLD(POINTER, order_list), identity_traits<df::squad_schedule_entry >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, order_month), TID(int32_t) },
    { FLD(PRIMITIVE, order_type), TID(int32_t) },
    { FLD(CONTAINER, burrows), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD(PRIMITIVE, patrol_route), TID(int32_t) },
    { FLD(PRIMITIVE, min_soldiers), TID(int32_t) },
    { FLD(CONTAINER, positions), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD(PRIMITIVE, station_point), TID(int32_t) },
    { FLD(POINTER, copy_item), identity_traits<df::squad_schedule_entry >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_squad_schedulest::_identity(sizeof(viewscreen_layer_squad_schedulest), &allocator_fn<viewscreen_layer_squad_schedulest>, "viewscreen_layer_squad_schedulest",NULL,&viewscreen_layer::_identity,viewscreen_layer_squad_schedulest_fields);
  #define CUR_STRUCT viewscreen_layer_stockpilest
  static const struct_field_info viewscreen_layer_stockpilest_fields[] = {
    { FLD(POINTER, settings), identity_traits<df::stockpile_settings >::get(), 0, NULL },
    { FLD(PRIMITIVE, cur_group), TID(stockpile_list) },
    { FLD(PRIMITIVE, cur_list), TID(stockpile_list) },
    { FLD(CONTAINER, group_ids), identity_traits<std::vector<df::stockpile_list > >::get(), 0, NULL },
    { FLD(CONTAINER, group_bits), identity_traits<std::vector<df::stockpile_group_set > >::get(), 0, NULL },
    { FLD(CONTAINER, list_ids), identity_traits<std::vector<df::stockpile_list > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, item_names), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, item_status), identity_traits<bool >::get(), 0, NULL },
    { FLD(PRIMITIVE, title), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_stockpilest::_identity(sizeof(viewscreen_layer_stockpilest), &allocator_fn<viewscreen_layer_stockpilest>, "viewscreen_layer_stockpilest",NULL,&viewscreen_layer::_identity,viewscreen_layer_stockpilest_fields);
  #define CUR_STRUCT viewscreen_layer_stone_restrictionst
  static const struct_field_info viewscreen_layer_stone_restrictionst_fields[] = {
    { FLD(STATIC_ARRAY, stone_type), identity_traits<std::vector<int32_t > >::get(), 2, NULL },
    { FLD(STATIC_ARRAY, stone_economic), identity_traits<std::vector<bool* > >::get(), 2, NULL },
    { FLD(PRIMITIVE, type_tab), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, use_name), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, use_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_stone_restrictionst::_identity(sizeof(viewscreen_layer_stone_restrictionst), &allocator_fn<viewscreen_layer_stone_restrictionst>, "viewscreen_layer_stone_restrictionst",NULL,&viewscreen_layer::_identity,viewscreen_layer_stone_restrictionst_fields);
  #define CUR_STRUCT viewscreen_layer_unit_actionst
  static const struct_field_info viewscreen_layer_unit_actionst_fields[] = {
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, held_items), identity_traits<df::item >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, reactions), identity_traits<df::reaction >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, choice_items), identity_traits<df::item >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, sel_items), identity_traits<df::item >::get(), 0, NULL },
    { FLD(CONTAINER, sel_reagents), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(POINTER, cur_reaction), identity_traits<df::reaction >::get(), 0, NULL },
    { FLD(PRIMITIVE, reagent), TID(int32_t) },
    { FLD(PRIMITIVE, reagent_amnt_left), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_6), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_8), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_9), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_unit_actionst::_identity(sizeof(viewscreen_layer_unit_actionst), &allocator_fn<viewscreen_layer_unit_actionst>, "viewscreen_layer_unit_actionst",NULL,&viewscreen_layer::_identity,viewscreen_layer_unit_actionst_fields);
  #define CUR_STRUCT viewscreen_layer_unit_healthst
  static const struct_field_info viewscreen_layer_unit_healthst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, page), TID(int16_t) },
    { FLD(PRIMITIVE, title), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, text), identity_traits<std::vector<std::string* > >::get(), 4, NULL },
    { FLD(STATIC_ARRAY, text_fg), identity_traits<std::vector<int16_t > >::get(), 4, NULL },
    { FLD(STATIC_ARRAY, text_bg), identity_traits<std::vector<int16_t > >::get(), 4, NULL },
    { FLD(STATIC_ARRAY, text_bold), identity_traits<std::vector<int16_t > >::get(), 4, NULL },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_unit_healthst::_identity(sizeof(viewscreen_layer_unit_healthst), &allocator_fn<viewscreen_layer_unit_healthst>, "viewscreen_layer_unit_healthst",NULL,&viewscreen_layer::_identity,viewscreen_layer_unit_healthst_fields);
  #define CUR_STRUCT viewscreen_layer_unit_relationshipst
  static const struct_field_info viewscreen_layer_unit_relationshipst_fields[] = {
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, relation_textline), identity_traits<std::string >::get(), 0, NULL },
    { FLD(CONTAINER, relation_unit_type), identity_traits<std::vector<df::unit_relationship_type > >::get(), 0, NULL },
    { FLD(CONTAINER, relation_histfig_type), identity_traits<std::vector<df::histfig_relationship_type > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, relation_unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, relation_hf), identity_traits<df::historical_figure >::get(), 0, NULL },
    { FLD(CONTAINER, level), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_unit_relationshipst::_identity(sizeof(viewscreen_layer_unit_relationshipst), &allocator_fn<viewscreen_layer_unit_relationshipst>, "viewscreen_layer_unit_relationshipst",NULL,&viewscreen_layer::_identity,viewscreen_layer_unit_relationshipst_fields);
  #define CUR_STRUCT viewscreen_layer_workshop_profilest
  static const struct_field_info viewscreen_layer_workshop_profilest_fields[] = {
    { FLD(POINTER, profile), identity_traits<df::workshop_profile >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, workers), identity_traits<df::unit >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_workshop_profilest::_identity(sizeof(viewscreen_layer_workshop_profilest), &allocator_fn<viewscreen_layer_workshop_profilest>, "viewscreen_layer_workshop_profilest",NULL,&viewscreen_layer::_identity,viewscreen_layer_workshop_profilest_fields);
  #define CUR_STRUCT viewscreen_layer_world_gen_param_presetst
  static const struct_field_info viewscreen_layer_world_gen_param_presetst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, anon_4), identity_traits<int16_t >::get(), 24, NULL },
    { FLD(STATIC_ARRAY, anon_5), identity_traits<int8_t >::get(), 24, NULL },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int16_t) },
    { FLD(PRIMITIVE, anon_8), TID(int16_t) },
    { FLD(PRIMITIVE, anon_9), TID(int16_t) },
    { FLD(PRIMITIVE, anon_10), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_world_gen_param_presetst::_identity(sizeof(viewscreen_layer_world_gen_param_presetst), &allocator_fn<viewscreen_layer_world_gen_param_presetst>, "viewscreen_layer_world_gen_param_presetst",NULL,&viewscreen_layer::_identity,viewscreen_layer_world_gen_param_presetst_fields);
  #define CUR_STRUCT viewscreen_layer_world_gen_paramst::T_unk1
  static const struct_field_info viewscreen_layer_world_gen_paramst_doT_Dot_T_unk1_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD(PRIMITIVE, anon_9), TID(int32_t) },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { FLD(PRIMITIVE, anon_11), TID(int32_t) },
    { FLD(PRIMITIVE, anon_12), TID(int32_t) },
    { FLD(PRIMITIVE, anon_13), TID(int32_t) },
    { FLD(PRIMITIVE, anon_14), TID(int32_t) },
    { FLD(PRIMITIVE, anon_15), TID(int32_t) },
    { FLD(PRIMITIVE, anon_16), TID(int32_t) },
    { FLD(PRIMITIVE, anon_17), TID(int32_t) },
    { FLD(PRIMITIVE, anon_18), TID(int32_t) },
    { FLD(PRIMITIVE, anon_19), TID(int32_t) },
    { FLD(PRIMITIVE, anon_20), TID(int32_t) },
    { FLD(PRIMITIVE, anon_21), TID(int32_t) },
    { FLD(PRIMITIVE, anon_22), TID(int32_t) },
    { FLD(PRIMITIVE, anon_23), TID(int32_t) },
    { FLD(PRIMITIVE, anon_24), TID(int32_t) },
    { FLD(PRIMITIVE, anon_25), TID(int32_t) },
    { FLD(PRIMITIVE, anon_26), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_layer_world_gen_paramst::T_unk1::_identity(sizeof(viewscreen_layer_world_gen_paramst::T_unk1), &allocator_fn<viewscreen_layer_world_gen_paramst::T_unk1>, &viewscreen_layer_world_gen_paramst::_identity, "T_unk1",NULL,viewscreen_layer_world_gen_paramst_doT_Dot_T_unk1_fields);
  #define CUR_STRUCT viewscreen_layer_world_gen_paramst
  static const struct_field_info viewscreen_layer_world_gen_paramst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), identity_traits<std::string >::get() },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, unk1), &viewscreen_layer_world_gen_paramst::T_unk1::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_layer_world_gen_paramst::_identity(sizeof(viewscreen_layer_world_gen_paramst), &allocator_fn<viewscreen_layer_world_gen_paramst>, "viewscreen_layer_world_gen_paramst",NULL,&viewscreen_layer::_identity,viewscreen_layer_world_gen_paramst_fields);
  #define CUR_STRUCT viewscreen_legendsst
  static const struct_field_info viewscreen_legendsst_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, init_step), TID(int32_t) },
    { FLD(PRIMITIVE, init_era), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, init_progress), TID(int32_t) },
    { FLD(CONTAINER, histfigs), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, sites), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, artifacts), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, regions), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, layers), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, entities), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, structures_1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, structures_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_a8), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_6), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_8), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_9), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_10), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, era_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, cur_page), TID(int16_t) },
    { FLD(PRIMITIVE, anon_11), TID(int32_t) },
    { FLD(PRIMITIVE, main_cursor), TID(int32_t) },
    { FLD(CONTAINER, main_row_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, main_row_arg1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, main_row_arg2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, main_row_arg3), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, sub_cursor), TID(int32_t) },
    { FLD(PRIMITIVE, anon_12), TID(int8_t) },
    { FLD(STL_VECTOR_PTR, anon_13), NULL, 0, NULL },
    { FLD(PRIMITIVE, map_x), TID(int16_t) },
    { FLD(PRIMITIVE, map_y), TID(int16_t) },
    { FLD(PRIMITIVE, hide_territories), TID(int16_t) },
    { FLD(PRIMITIVE, civ_site_mode), TID(int16_t) },
    { FLD(PRIMITIVE, anon_14), TID(int16_t) },
    { FLD(PRIMITIVE, filter_text), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, filter_editing), TID(int8_t) },
    { FLD(CONTAINER, anon_15), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_16), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_17), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_18), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_19), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_20), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_21), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_22), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_legendsst::_identity(sizeof(viewscreen_legendsst), &allocator_fn<viewscreen_legendsst>, "viewscreen_legendsst",NULL,&viewscreen::_identity,viewscreen_legendsst_fields);
  #define CUR_STRUCT viewscreen_loadgamest
  static const struct_field_info viewscreen_loadgamest_fields[] = {
    { FLD(PRIMITIVE, cur_step), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1b), TID(int32_t) },
    { FLD(PRIMITIVE, loading), TID(int8_t) },
    { FLD(PRIMITIVE, sel_idx), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, saves), identity_traits<df::loadgame_save_info >::get(), 0, NULL },
    { FLD(SUBSTRUCT, compressor), &file_compressorst::_identity },
    { FLD(SUBSTRUCT, glosses), &matgloss_list::_identity },
    { FLD(PRIMITIVE, unk_v40_2), TID(int32_t) },
    { FLD(SUBSTRUCT, cur_save), &loadgame_save_info::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_loadgamest::_identity(sizeof(viewscreen_loadgamest), &allocator_fn<viewscreen_loadgamest>, "viewscreen_loadgamest",NULL,&viewscreen::_identity,viewscreen_loadgamest_fields);
  #define CUR_STRUCT viewscreen_meetingst
  static const struct_field_info viewscreen_meetingst_fields[] = {
    { FLD(POINTER, dipscript_popup), identity_traits<df::dipscript_popup >::get(), 0, NULL },
    { FLD(POINTER, activity), identity_traits<df::activity_info >::get(), 0, NULL },
    { FLD(POINTER, holder), identity_traits<df::unit >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_meetingst::_identity(sizeof(viewscreen_meetingst), &allocator_fn<viewscreen_meetingst>, "viewscreen_meetingst",NULL,&viewscreen::_identity,viewscreen_meetingst_fields);
  #define CUR_STRUCT viewscreen_movieplayerst
  static const struct_field_info viewscreen_movieplayerst_fields[] = {
    { FLD(PRIMITIVE, saving), TID(int8_t) },
    { FLD(PRIMITIVE, loading), TID(int8_t) },
    { FLD(PRIMITIVE, editing), TID(int8_t) },
    { FLD(PRIMITIVE, text_mode), TID(int8_t) },
    { FLD(PRIMITIVE, editing_char), TID(uint8_t) },
    { FLD(PRIMITIVE, editing_copy_from), TID(int32_t) },
    { FLD(PRIMITIVE, editing_screenf), TID(int16_t) },
    { FLD(PRIMITIVE, editing_screenb), TID(int16_t) },
    { FLD(PRIMITIVE, editing_screenbright), TID(int16_t) },
    { FLD(PRIMITIVE, editing_selected_sound), TID(int32_t) },
    { FLD(PRIMITIVE, editing_menu), TID(int8_t) },
    { FLD(PRIMITIVE, savename), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, force_file), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, is_playing), TID(int8_t) },
    { FLD(PRIMITIVE, is_forced_play), TID(int8_t) },
    { FLD(PRIMITIVE, quit_if_no_play), TID(int8_t) },
    { FLD(PRIMITIVE, maxmoviepos), TID(int32_t) },
    { FLD(PRIMITIVE, end_frame_pos), TID(int32_t) },
    { FLD(PRIMITIVE, selfile), TID(int32_t) },
    { FLD(CONTAINER, filelist), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_movieplayerst::_identity(sizeof(viewscreen_movieplayerst), &allocator_fn<viewscreen_movieplayerst>, "viewscreen_movieplayerst",NULL,&viewscreen::_identity,viewscreen_movieplayerst_fields);
  #define CUR_STRUCT viewscreen_new_regionst
  static const struct_field_info viewscreen_new_regionst_fields[] = {
    { FLD(CONTAINER, worldgen_presets), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_2), TID(int8_t) },
    { FLD(PRIMITIVE, in_worldgen), TID(int8_t) },
    { FLD(PRIMITIVE, cursor_paramset), TID(int32_t) },
    { FLD(PRIMITIVE, random_seed), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, editing_randseed), TID(int8_t) },
    { FLD(PRIMITIVE, editing_customname), TID(int8_t) },
    { FLD(PRIMITIVE, editing_title), TID(int8_t) },
    { FLD(PRIMITIVE, popup_deleteset), TID(int8_t) },
    { FLD(PRIMITIVE, popup_changedimensions), TID(int8_t) },
    { FLD(PRIMITIVE, unk_11), TID(int8_t) },
    { FLD(PRIMITIVE, custom_size_x), TID(uint16_t) },
    { FLD(PRIMITIVE, custom_size_y), TID(uint16_t) },
    { FLD(PRIMITIVE, popup_abort), TID(int8_t) },
    { FLD(PRIMITIVE, popup_goon), TID(int8_t) },
    { FLD(PRIMITIVE, unsaved_changes), TID(int8_t) },
    { FLD(PRIMITIVE, simple_mode), TID(int8_t) },
    { FLD(PRIMITIVE, unk_20), TID(int8_t) },
    { FLD(PRIMITIVE, unk_21), TID(int8_t) },
    { FLD(PRIMITIVE, cursor_line), TID(int16_t) },
    { FLD(PRIMITIVE, world_size), TID(int32_t) },
    { FLD(PRIMITIVE, history), TID(int32_t) },
    { FLD(PRIMITIVE, number_civs), TID(int32_t) },
    { FLD(PRIMITIVE, number_sites), TID(int32_t) },
    { FLD(PRIMITIVE, number_beasts), TID(int32_t) },
    { FLD(PRIMITIVE, savagery), TID(int32_t) },
    { FLD(PRIMITIVE, mineral_occurence), TID(int32_t) },
    { FLD(PRIMITIVE, worldgen_paused), TID(int8_t) },
    { FLD(PRIMITIVE, worldgen_rejected), TID(int8_t) },
    { FLD(STL_VECTOR_PTR, unk_32), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_33), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_98), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_b4), TID(int8_t) },
    { FLD(PRIMITIVE, unk_b8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_bc), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_new_regionst::_identity(sizeof(viewscreen_new_regionst), &allocator_fn<viewscreen_new_regionst>, "viewscreen_new_regionst",NULL,&viewscreen::_identity,viewscreen_new_regionst_fields);
  #define CUR_STRUCT viewscreen_noblest
  static const struct_field_info viewscreen_noblest_fields[] = {
    { FLD(PRIMITIVE, become_capital_offerings), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_noblest::_identity(sizeof(viewscreen_noblest), &allocator_fn<viewscreen_noblest>, "viewscreen_noblest",NULL,&viewscreen::_identity,viewscreen_noblest_fields);
  #define CUR_STRUCT viewscreen_optionst
  static const struct_field_info viewscreen_optionst_fields[] = {
    { FLD(PRIMITIVE, msg_quit), TID(int8_t) },
    { FLD(PRIMITIVE, in_retire_adv), TID(int8_t) },
    { FLD(PRIMITIVE, msg_peasant), TID(int8_t) },
    { FLD(PRIMITIVE, in_retire_dwf_abandon_adv), TID(int8_t) },
    { FLD(PRIMITIVE, in_abandon_dwf), TID(int8_t) },
    { FLD(PRIMITIVE, sel_idx), TID(int32_t) },
    { FLD(CONTAINER, options), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_optionst::_identity(sizeof(viewscreen_optionst), &allocator_fn<viewscreen_optionst>, "viewscreen_optionst",NULL,&viewscreen::_identity,viewscreen_optionst_fields);
  #define CUR_STRUCT viewscreen_overallstatusst
  static const struct_field_info viewscreen_overallstatusst_fields[] = {
    { FLD(CONTAINER, visible_pages), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, page_cursor), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_overallstatusst::_identity(sizeof(viewscreen_overallstatusst), &allocator_fn<viewscreen_overallstatusst>, "viewscreen_overallstatusst",NULL,&viewscreen::_identity,viewscreen_overallstatusst_fields);
  #define CUR_STRUCT viewscreen_petst::T_animal
  static const struct_field_info viewscreen_petst_doT_Dot_T_animal_fields[] = {
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 2, NULL },
    { FLD(POINTER, item), identity_traits<df::item >::get(), 2, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity identity_traits<viewscreen_petst::T_animal>::identity(sizeof(viewscreen_petst::T_animal), &allocator_fn<viewscreen_petst::T_animal>, &viewscreen_petst::_identity, "T_animal", NULL, viewscreen_petst_doT_Dot_T_animal_fields);
  #define CUR_STRUCT viewscreen_petst
  static const struct_field_info viewscreen_petst_fields[] = {
    { FLD(PRIMITIVE, cursor), TID(int32_t) },
    { FLD(CONTAINER, animal), identity_traits<std::vector<df::viewscreen_petst::T_animal > >::get(), 0, NULL },
    { FLD(CONTAINER, is_vermin), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, is_tame), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, is_adopting), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(PRIMITIVE, mode), TID(viewscreen_petst::T_mode) },
    { FLD(PRIMITIVE, knowledge_page), TID(int32_t) },
    { FLD(CONTAINER, known), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, trainer_cursor), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, trainer_unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(CONTAINER, trainer_mode), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_petst::_identity(sizeof(viewscreen_petst), &allocator_fn<viewscreen_petst>, "viewscreen_petst",NULL,&viewscreen::_identity,viewscreen_petst_fields);
  #define CUR_STRUCT viewscreen_pricest
  static const struct_field_info viewscreen_pricest_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_pricest::_identity(sizeof(viewscreen_pricest), &allocator_fn<viewscreen_pricest>, "viewscreen_pricest",NULL,&viewscreen::_identity,viewscreen_pricest_fields);
  #define CUR_STRUCT viewscreen_reportlistst
  static const struct_field_info viewscreen_reportlistst_fields[] = {
    { FLD(STL_VECTOR_PTR, units), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(CONTAINER, types), identity_traits<std::vector<df::unit_report_type > >::get(), 0, NULL },
    { FLD(CONTAINER, last_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, cursor), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_reportlistst::_identity(sizeof(viewscreen_reportlistst), &allocator_fn<viewscreen_reportlistst>, "viewscreen_reportlistst",NULL,&viewscreen::_identity,viewscreen_reportlistst_fields);
  #define CUR_STRUCT viewscreen_requestagreementst
  static const struct_field_info viewscreen_requestagreementst_fields[] = {
    { FLD(POINTER, requests), identity_traits<df::entity_buy_prices >::get(), 0, NULL },
    { FLD(PRIMITIVE, civ_id), TID(int32_t) },
    { FLD(PRIMITIVE, cursor), TID(int32_t) },
    { FLD(STATIC_STRING, title), NULL, 256 },
    { FLD(POINTER, anon_1), identity_traits<df::historical_entity >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_requestagreementst::_identity(sizeof(viewscreen_requestagreementst), &allocator_fn<viewscreen_requestagreementst>, "viewscreen_requestagreementst",NULL,&viewscreen::_identity,viewscreen_requestagreementst_fields);
  #define CUR_STRUCT viewscreen_savegamest
  static const struct_field_info viewscreen_savegamest_fields[] = {
    { FLD(PRIMITIVE, anon_1), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, cur_step), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1b), TID(int32_t) },
    { FLD(SUBSTRUCT, compressor), &file_compressorst::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_savegamest::_identity(sizeof(viewscreen_savegamest), &allocator_fn<viewscreen_savegamest>, "viewscreen_savegamest",NULL,&viewscreen::_identity,viewscreen_savegamest_fields);
  #define CUR_STRUCT viewscreen_selectitemst
  static const struct_field_info viewscreen_selectitemst_fields[] = {
    { FLD(POINTER, p_item_type), identity_traits<int16_t >::get(), 0, NULL },
    { FLD(POINTER, p_item_subtype), identity_traits<int16_t >::get(), 0, NULL },
    { FLD(POINTER, p_mattype), identity_traits<int16_t >::get(), 0, NULL },
    { FLD(POINTER, p_matindex), identity_traits<int32_t >::get(), 0, NULL },
    { FLD(POINTER, choice), identity_traits<df::embark_item_choice >::get(), 0, NULL },
    { FLD(POINTER, screen), identity_traits<df::viewscreen_setupdwarfgamest >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, page_base), identity_traits<std::vector<int32_t > >::get(), 107, TID(entity_sell_category) },
    { FLD(STATIC_STRING, title), NULL, 256 },
    { FLD(STATIC_STRING, anon_1), NULL, 256 },
    { FLD(STATIC_STRING, filter), NULL, 256 },
    { FLD(PRIMITIVE, right_pos), TID(int32_t) },
    { FLD(PRIMITIVE, right_page_base), TID(int32_t) },
    { FLD(PRIMITIVE, right_list), TID(bool) },
    { FLD(PRIMITIVE, sel_category), TID(int32_t) },
    { FLD(CONTAINER, categories), identity_traits<std::vector<enum_field<df::entity_sell_category,int16_t> > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_selectitemst::_identity(sizeof(viewscreen_selectitemst), &allocator_fn<viewscreen_selectitemst>, "viewscreen_selectitemst",NULL,&viewscreen::_identity,viewscreen_selectitemst_fields);
  #define CUR_STRUCT viewscreen_setupadventurest::T_adventurer
  static const struct_field_info viewscreen_setupadventurest_doT_Dot_T_adventurer_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(STATIC_ARRAY, skills), identity_traits<int32_t >::get(), 118, TID(job_skill) },
    { FLD(PRIMITIVE, entity), TID(int32_t) },
    { FLD(PRIMITIVE, histfig), TID(int16_t) },
    { FLD(PRIMITIVE, unk_7), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_9), TID(int16_t) },
    { FLD(STATIC_ARRAY, attributes), identity_traits<int32_t >::get(), 19, NULL },
    { FLD(PRIMITIVE, status), TID(viewscreen_setupadventurest::T_adventurer::T_status) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_setupadventurest::T_adventurer::_identity(sizeof(viewscreen_setupadventurest::T_adventurer), &allocator_fn<viewscreen_setupadventurest::T_adventurer>, &viewscreen_setupadventurest::_identity, "T_adventurer",NULL,viewscreen_setupadventurest_doT_Dot_T_adventurer_fields);
  #define CUR_STRUCT viewscreen_setupadventurest
  static const struct_field_info viewscreen_setupadventurest_fields[] = {
    { FLD(PRIMITIVE, editing_name), TID(int8_t) },
    { FLD(PRIMITIVE, saved_firstname), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, index_col1), TID(int32_t) },
    { FLD(PRIMITIVE, index_skills), TID(int32_t) },
    { FLD(PRIMITIVE, skill_points_remaining), TID(int32_t) },
    { FLD(PRIMITIVE, subscreen), TID(viewscreen_setupadventurest::T_subscreen) },
    { FLD(SUBSTRUCT, adventurer), &viewscreen_setupadventurest::T_adventurer::_identity },
    { FLD(PRIMITIVE, unk_v40_1a), TID(int32_t) },
    { FLD(PRIMITIVE, site_id), TID(int32_t) },
    { FLD(PRIMITIVE, deity_id), TID(int32_t) },
    { FLD(PRIMITIVE, belief_strength), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, background), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, sites), identity_traits<df::world_site >::get(), 0, NULL },
    { FLD(CONTAINER, background_type), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, sel_background), TID(int32_t) },
    { FLD(CONTAINER, race_list), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, entity_list), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, nemesis_list), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, skill_list), identity_traits<std::vector<df::job_skill > >::get(), 0, NULL },
    { FLD(PRIMITIVE, focus_column), TID(int8_t) },
    { FLD(PRIMITIVE, attribute_points_remaining), TID(int32_t) },
    { FLD(PRIMITIVE, index_attributes), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_setupadventurest::_identity(sizeof(viewscreen_setupadventurest), &allocator_fn<viewscreen_setupadventurest>, "viewscreen_setupadventurest",NULL,&viewscreen::_identity,viewscreen_setupadventurest_fields);
  #define CUR_STRUCT viewscreen_setupdwarfgamest::T_dwarf_info
  static const struct_field_info viewscreen_setupdwarfgamest_doT_Dot_T_dwarf_info_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(STATIC_ARRAY, skills), identity_traits<int32_t >::get(), 118, TID(job_skill) },
    { FLD(PRIMITIVE, unk_244), TID(int32_t) },
    { FLD(PRIMITIVE, unk_248), TID(int16_t) },
    { FLD(PRIMITIVE, levels_remaining), TID(int16_t) },
    { FLD(STATIC_ARRAY, unk_258), identity_traits<int32_t >::get(), 19, NULL },
    { FLD(PRIMITIVE, unk_2a4), TID(int16_t) },
    { FLD(PRIMITIVE, unk_2a8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_2ac), TID(int32_t) },
    { FLD(PRIMITIVE, unk_2b0), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_setupdwarfgamest::T_dwarf_info::_identity(sizeof(viewscreen_setupdwarfgamest::T_dwarf_info), &allocator_fn<viewscreen_setupdwarfgamest::T_dwarf_info>, &viewscreen_setupdwarfgamest::_identity, "T_dwarf_info",NULL,viewscreen_setupdwarfgamest_doT_Dot_T_dwarf_info_fields);
  #define CUR_STRUCT viewscreen_setupdwarfgamest::T_animals
  static const struct_field_info viewscreen_setupdwarfgamest_doT_Dot_T_animals_fields[] = {
    { FLD(CONTAINER, race), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, caste), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, profession), identity_traits<std::vector<df::profession > >::get(), 0, NULL },
    { FLD(CONTAINER, count), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_setupdwarfgamest::T_animals::_identity(sizeof(viewscreen_setupdwarfgamest::T_animals), &allocator_fn<viewscreen_setupdwarfgamest::T_animals>, &viewscreen_setupdwarfgamest::_identity, "T_animals",NULL,viewscreen_setupdwarfgamest_doT_Dot_T_animals_fields);
  #define CUR_STRUCT viewscreen_setupdwarfgamest
  static const struct_field_info viewscreen_setupdwarfgamest_fields[] = {
    { FLD(STATIC_STRING, title), NULL, 256 },
    { FLD(STL_VECTOR_PTR, dwarf_info), &viewscreen_setupdwarfgamest::T_dwarf_info::_identity, 0, NULL },
    { FLD(CONTAINER, embark_skills), identity_traits<std::vector<df::job_skill > >::get(), 0, NULL },
    { FLD(CONTAINER, reclaim_professions), identity_traits<std::vector<df::profession > >::get(), 0, NULL },
    { FLD(PRIMITIVE, mode), TID(int32_t) },
    { FLD(PRIMITIVE, dwarf_cursor), TID(int32_t) },
    { FLD(PRIMITIVE, dwarf_page_idx), TID(int32_t) },
    { FLD(PRIMITIVE, item_cursor), TID(int32_t) },
    { FLD(PRIMITIVE, skill_cursor), TID(int32_t) },
    { FLD(PRIMITIVE, animal_cursor), TID(int32_t) },
    { FLD(PRIMITIVE, dwarf_column), TID(int32_t) },
    { FLD(PRIMITIVE, supply_column), TID(int32_t) },
    { FLD(PRIMITIVE, display_row), TID(int32_t) },
    { FLD(PRIMITIVE, show_play_now), TID(int8_t) },
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, choice), TID(int32_t) },
    { FLD(PRIMITIVE, profile_name), identity_traits<std::string >::get() },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int8_t) },
    { FLD(PRIMITIVE, in_save_profile), TID(int8_t) },
    { FLD(PRIMITIVE, anon_6), TID(int8_t) },
    { FLD(SUBSTRUCT, item_choice), &embark_item_choice::_identity },
    { FLD(SUBSTRUCT, animals), &viewscreen_setupdwarfgamest::T_animals::_identity },
    { FLD(SUBSTRUCT, fort_name), &language_name::_identity },
    { FLD(SUBSTRUCT, group_name), &language_name::_identity },
    { FLD(PRIMITIVE, anon_7), TID(int8_t) },
    { FLD(SUBSTRUCT, location), &embark_location::_identity },
    { FLD(STL_VECTOR_PTR, units), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, items), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD(PRIMITIVE, points_remaining), TID(int32_t) },
    { FLD(PRIMITIVE, add_item_type), TID(item_type) },
    { FLD(PRIMITIVE, add_item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, add_mattype), TID(int16_t) },
    { FLD(PRIMITIVE, add_matindex), TID(int32_t) },
    { FLD(PRIMITIVE, adding_item), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_setupdwarfgamest::_identity(sizeof(viewscreen_setupdwarfgamest), &allocator_fn<viewscreen_setupdwarfgamest>, "viewscreen_setupdwarfgamest",NULL,&viewscreen::_identity,viewscreen_setupdwarfgamest_fields);
  #define CUR_STRUCT viewscreen_storesst
  static const struct_field_info viewscreen_storesst_fields[] = {
    { FLD(STATIC_STRING, title), NULL, 256 },
    { FLD(PRIMITIVE, category_cursor), TID(int32_t) },
    { FLD(PRIMITIVE, item_cursor), TID(int32_t) },
    { FLD(PRIMITIVE, in_right_list), TID(int16_t) },
    { FLD(PRIMITIVE, in_group_mode), TID(int16_t) },
    { FLD(CONTAINER, category_total), identity_traits<std::vector<int32_t > >::get(), 0, TID(item_type) },
    { FLD(CONTAINER, category_busy), identity_traits<std::vector<int32_t > >::get(), 0, TID(item_type) },
    { FLD(STL_VECTOR_PTR, items), identity_traits<df::item >::get(), 0, NULL },
    { FLD(CONTAINER, group_item_type), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, group_item_subtype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, group_mat_type), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, group_mat_index), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, group_count), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, category_order), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(PRIMITIVE, can_zoom), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_storesst::_identity(sizeof(viewscreen_storesst), &allocator_fn<viewscreen_storesst>, "viewscreen_storesst",NULL,&viewscreen::_identity,viewscreen_storesst_fields);
  #define CUR_STRUCT viewscreen_textviewerst::T_formatted_text
  static const struct_field_info viewscreen_textviewerst_doT_Dot_T_formatted_text_fields[] = {
    { FLD(POINTER, text), identity_traits<char >::get(), 0, NULL },
    { FLD(POINTER, format), identity_traits<char >::get(), 0, NULL },
    { FLD(SUBSTRUCT, flags), TID(viewscreen_textviewerst::T_formatted_text::T_flags) },
    { FLD(PRIMITIVE, pause_depth), TID(int32_t) },
    { FLD(PRIMITIVE, return_val), TID(int32_t) },
    { FLD(PRIMITIVE, indent), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity viewscreen_textviewerst::T_formatted_text::_identity(sizeof(viewscreen_textviewerst::T_formatted_text), &allocator_fn<viewscreen_textviewerst::T_formatted_text>, &viewscreen_textviewerst::_identity, "T_formatted_text",NULL,viewscreen_textviewerst_doT_Dot_T_formatted_text_fields);
  #define CUR_STRUCT viewscreen_textviewerst
  static const struct_field_info viewscreen_textviewerst_fields[] = {
    { FLD(PRIMITIVE, title), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, title_colors), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, src_text), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, outvar_type), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, outvar_name), identity_traits<std::string >::get() },
    { FLD(SUBSTRUCT, meeting_context), &meeting_context::_identity },
    { FLD(PRIMITIVE, help_filename), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, page_filename), identity_traits<std::string >::get() },
    { FLD(STL_VECTOR_PTR, formatted_text), &viewscreen_textviewerst::T_formatted_text::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, hyperlinks), identity_traits<char >::get(), 0, NULL },
    { FLD(PRIMITIVE, logged_error), TID(int8_t) },
    { FLD(PRIMITIVE, scroll_pos), TID(int32_t) },
    { FLD(PRIMITIVE, cursor_line), TID(int32_t) },
    { FLD(PRIMITIVE, pause_depth), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_textviewerst::_identity(sizeof(viewscreen_textviewerst), &allocator_fn<viewscreen_textviewerst>, "viewscreen_textviewerst",NULL,&viewscreen::_identity,viewscreen_textviewerst_fields);
  #define CUR_STRUCT viewscreen_titlest
  static const struct_field_info viewscreen_titlest_fields[] = {
    { FLD(STATIC_STRING, str_histories), NULL, 256 },
    { FLD(STATIC_STRING, menu_items), NULL, 256 },
    { FLD(PRIMITIVE, sel_subpage), TID(viewscreen_titlest::T_sel_subpage) },
    { FLD(PRIMITIVE, sel_menu_line), TID(int32_t) },
    { FLD(PRIMITIVE, sel_submenu_line), TID(int32_t) },
    { FLD(PRIMITIVE, loading), TID(int8_t) },
    { FLD(CONTAINER, menu_line_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, submenu_line_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, submenu_line_text), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, start_savegames), identity_traits<std::string >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, continue_savegames), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, str_slaves), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, str_chapter), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, str_copyright), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, str_version), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, str_unk), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, str_programmed), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, str_designed), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, str_visit), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, str_site), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_36c), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_388), TID(int32_t) },
    { FLD(PRIMITIVE, unk_38c), TID(int8_t) },
    { FLD(PRIMITIVE, unk_390), TID(int32_t) },
    { FLD(PRIMITIVE, unk_394), TID(int8_t) },
    { FLD(PRIMITIVE, unk_398), TID(int32_t) },
    { FLD(PRIMITIVE, unk_39c), TID(int8_t) },
    { FLD(PRIMITIVE, unk_3a0), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_titlest::_identity(sizeof(viewscreen_titlest), &allocator_fn<viewscreen_titlest>, "viewscreen_titlest",NULL,&viewscreen::_identity,viewscreen_titlest_fields);
  #define CUR_STRUCT viewscreen_topicmeeting_fill_land_holder_positionst
  static const struct_field_info viewscreen_topicmeeting_fill_land_holder_positionst_fields[] = {
    { FLD(STATIC_STRING, anon_1), NULL, 256 },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(CONTAINER, anon_6), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_8), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_9), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { FLD(PRIMITIVE, anon_11), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_topicmeeting_fill_land_holder_positionst::_identity(sizeof(viewscreen_topicmeeting_fill_land_holder_positionst), &allocator_fn<viewscreen_topicmeeting_fill_land_holder_positionst>, "viewscreen_topicmeeting_fill_land_holder_positionst",NULL,&viewscreen::_identity,viewscreen_topicmeeting_fill_land_holder_positionst_fields);
  #define CUR_STRUCT viewscreen_topicmeeting_takerequestsst
  static const struct_field_info viewscreen_topicmeeting_takerequestsst_fields[] = {
    { FLD(STATIC_STRING, title), NULL, 256 },
    { FLD(POINTER, popup), identity_traits<df::dipscript_popup >::get(), 0, NULL },
    { FLD(POINTER, meeting), identity_traits<df::meeting_diplomat_info >::get(), 0, NULL },
    { FLD(CONTAINER, type_categories), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, type_idx), TID(int32_t) },
    { FLD(PRIMITIVE, good_idx), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_topicmeeting_takerequestsst::_identity(sizeof(viewscreen_topicmeeting_takerequestsst), &allocator_fn<viewscreen_topicmeeting_takerequestsst>, "viewscreen_topicmeeting_takerequestsst",NULL,&viewscreen::_identity,viewscreen_topicmeeting_takerequestsst_fields);
  #define CUR_STRUCT viewscreen_topicmeetingst
  static const struct_field_info viewscreen_topicmeetingst_fields[] = {
    { FLD(POINTER, popup), identity_traits<df::dipscript_popup >::get(), 0, NULL },
    { FLD(POINTER, meeting), identity_traits<df::meeting_diplomat_info >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, text), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_28), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_topicmeetingst::_identity(sizeof(viewscreen_topicmeetingst), &allocator_fn<viewscreen_topicmeetingst>, "viewscreen_topicmeetingst",NULL,&viewscreen::_identity,viewscreen_topicmeetingst_fields);
  #define CUR_STRUCT viewscreen_tradeagreementst
  static const struct_field_info viewscreen_tradeagreementst_fields[] = {
    { FLD(POINTER, requests), identity_traits<df::entity_sell_prices >::get(), 0, NULL },
    { FLD(PRIMITIVE, civ_id), TID(int32_t) },
    { FLD(CONTAINER, anon_1), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, type_idx), TID(int32_t) },
    { FLD(PRIMITIVE, good_idx), TID(int32_t) },
    { FLD(STATIC_STRING, title), NULL, 256 },
    { FLD(POINTER, civ), identity_traits<df::historical_entity >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_tradeagreementst::_identity(sizeof(viewscreen_tradeagreementst), &allocator_fn<viewscreen_tradeagreementst>, "viewscreen_tradeagreementst",NULL,&viewscreen::_identity,viewscreen_tradeagreementst_fields);
  #define CUR_STRUCT viewscreen_tradegoodsst
  static const struct_field_info viewscreen_tradegoodsst_fields[] = {
    { FLD(STATIC_STRING, title), NULL, 256 },
    { FLD(PRIMITIVE, merchant_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, merchant_entity), identity_traits<std::string >::get() },
    { FLD(POINTER, depot), identity_traits<df::building_tradedepotst >::get(), 0, NULL },
    { FLD(POINTER, caravan), identity_traits<df::caravan_state >::get(), 0, NULL },
    { FLD(POINTER, entity), identity_traits<df::historical_entity >::get(), 0, NULL },
    { FLD(PRIMITIVE, is_unloading), TID(bool) },
    { FLD(PRIMITIVE, has_traders), TID(bool) },
    { FLD(POINTER, trader), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(POINTER, broker), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, trader_items), identity_traits<df::item >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, broker_items), identity_traits<df::item >::get(), 0, NULL },
    { FLD(CONTAINER, trader_selected), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, broker_selected), identity_traits<std::vector<char > >::get(), 0, NULL },
    { FLD(CONTAINER, trader_count), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, broker_count), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, trader_cursor), TID(int32_t) },
    { FLD(PRIMITIVE, broker_cursor), TID(int32_t) },
    { FLD(PRIMITIVE, in_right_pane), TID(bool) },
    { FLD(PRIMITIVE, trade_reply), TID(int16_t) },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, has_offer), TID(int8_t) },
    { FLD(STL_VECTOR_PTR, counteroffer), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, in_edit_count), TID(int8_t) },
    { FLD(PRIMITIVE, edit_count), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_tradegoodsst::_identity(sizeof(viewscreen_tradegoodsst), &allocator_fn<viewscreen_tradegoodsst>, "viewscreen_tradegoodsst",NULL,&viewscreen::_identity,viewscreen_tradegoodsst_fields);
  #define CUR_STRUCT viewscreen_tradelistst
  static const struct_field_info viewscreen_tradelistst_fields[] = {
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(POINTER, depot), identity_traits<df::building_tradedepotst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, caravans), identity_traits<df::caravan_state >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_tradelistst::_identity(sizeof(viewscreen_tradelistst), &allocator_fn<viewscreen_tradelistst>, "viewscreen_tradelistst",NULL,&viewscreen::_identity,viewscreen_tradelistst_fields);
  #define CUR_STRUCT viewscreen_treasurelistst
  static const struct_field_info viewscreen_treasurelistst_fields[] = {
    { FLD(PRIMITIVE, sel_idx), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_treasurelistst::_identity(sizeof(viewscreen_treasurelistst), &allocator_fn<viewscreen_treasurelistst>, "viewscreen_treasurelistst",NULL,&viewscreen::_identity,viewscreen_treasurelistst_fields);
  #define CUR_STRUCT viewscreen_unitlistst
  static const struct_field_info viewscreen_unitlistst_fields[] = {
    { FLD(PRIMITIVE, allow_zoom), TID(bool) },
    { FLD(PRIMITIVE, page), TID(viewscreen_unitlist_page) },
    { FLD(STATIC_ARRAY, cursor_pos), identity_traits<int32_t >::get(), 4, TID(viewscreen_unitlist_page) },
    { FLD(STATIC_ARRAY, jobs), identity_traits<std::vector<df::job* > >::get(), 4, TID(viewscreen_unitlist_page) },
    { FLD(STATIC_ARRAY, units), identity_traits<std::vector<df::unit* > >::get(), 4, TID(viewscreen_unitlist_page) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_unitlistst::_identity(sizeof(viewscreen_unitlistst), &allocator_fn<viewscreen_unitlistst>, "viewscreen_unitlistst",NULL,&viewscreen::_identity,viewscreen_unitlistst_fields);
  #define CUR_STRUCT viewscreen_unitst
  static const struct_field_info viewscreen_unitst_fields[] = {
    { FLD(POINTER, unit), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_unitst::_identity(sizeof(viewscreen_unitst), &allocator_fn<viewscreen_unitst>, "viewscreen_unitst",NULL,&viewscreen::_identity,viewscreen_unitst_fields);
  #define CUR_STRUCT viewscreen_update_regionst
  static const struct_field_info viewscreen_update_regionst_fields[] = {
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, year_tick), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_update_regionst::_identity(sizeof(viewscreen_update_regionst), &allocator_fn<viewscreen_update_regionst>, "viewscreen_update_regionst",NULL,&viewscreen::_identity,viewscreen_update_regionst_fields);
  #define CUR_STRUCT viewscreen_wagesst
  static const struct_field_info viewscreen_wagesst_fields[] = {
    { FLD(PRIMITIVE, profession_category), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity viewscreen_wagesst::_identity(sizeof(viewscreen_wagesst), &allocator_fn<viewscreen_wagesst>, "viewscreen_wagesst",NULL,&viewscreen::_identity,viewscreen_wagesst_fields);
  #define CUR_STRUCT weapon_attack
  static const struct_field_info weapon_attack_fields[] = {
    { FLD(PRIMITIVE, edged), TID(bool) },
    { FLD(PRIMITIVE, contact), TID(int32_t) },
    { FLD(PRIMITIVE, penetration), TID(int32_t) },
    { FLD(PRIMITIVE, velocity_mult), TID(int32_t) },
    { FLD(PRIMITIVE, verb_2nd), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, verb_3rd), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, noun), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, prepare), TID(int32_t) },
    { FLD(PRIMITIVE, recover), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(weapon_attack::T_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity weapon_attack::_identity(sizeof(weapon_attack), &allocator_fn<weapon_attack>, NULL, "weapon_attack",NULL,weapon_attack_fields);
  #define CUR_STRUCT web_cluster
  static const struct_field_info web_cluster_fields[] = {
    { FLD(CONTAINER, x), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, y), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, z), TID(int16_t) },
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(PRIMITIVE, caste), TID(int16_t) },
    { FLD(SUBSTRUCT, pos_min), &coord2d::_identity },
    { FLD(SUBSTRUCT, pos_max), &coord2d::_identity },
    { FLD(CONTAINER, ambushers), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity web_cluster::_identity(sizeof(web_cluster), &allocator_fn<web_cluster>, NULL, "web_cluster",NULL,web_cluster_fields);
  #define CUR_STRUCT workshop_profile
  static const struct_field_info workshop_profile_fields[] = {
    { FLD(CONTAINER, permitted_workers), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, min_level), TID(int32_t) },
    { FLD(PRIMITIVE, max_level), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity workshop_profile::_identity(sizeof(workshop_profile), &allocator_fn<workshop_profile>, NULL, "workshop_profile",NULL,workshop_profile_fields);
  #define CUR_STRUCT world::T_vermin
  static const struct_field_info world_doT_Dot_T_vermin_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::vermin >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, colonies), identity_traits<df::vermin >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_vermin::_identity(sizeof(world::T_vermin), &allocator_fn<world::T_vermin>, &world::_identity, "T_vermin",NULL,world_doT_Dot_T_vermin_fields);
  #define CUR_STRUCT world::T_entities
  static const struct_field_info world_doT_Dot_T_entities_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::historical_entity >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::historical_entity >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_entities::_identity(sizeof(world::T_entities), &allocator_fn<world::T_entities>, &world::_identity, "T_entities",NULL,world_doT_Dot_T_entities_fields);
  #define CUR_STRUCT world::T_worldgen_coord_buf
  static const struct_field_info world_doT_Dot_T_worldgen_coord_buf_fields[] = {
    { FLD(STATIC_ARRAY, slots), identity_traits<df::coord2d >::get(), 20000, NULL },
    { FLD(PRIMITIVE, next_slot), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_worldgen_coord_buf::_identity(sizeof(world::T_worldgen_coord_buf), &allocator_fn<world::T_worldgen_coord_buf>, &world::_identity, "T_worldgen_coord_buf",NULL,world_doT_Dot_T_worldgen_coord_buf_fields);
  #define CUR_STRUCT world::T_units
  static const struct_field_info world_doT_Dot_T_units_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, active), identity_traits<df::unit >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, other), identity_traits<std::vector<df::unit* > >::get(), 2, TID(units_other_id) },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::unit >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_units::_identity(sizeof(world::T_units), &allocator_fn<world::T_units>, &world::_identity, "T_units",NULL,world_doT_Dot_T_units_fields);
  #define CUR_STRUCT world::T_nemesis
  static const struct_field_info world_doT_Dot_T_nemesis_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::nemesis_record >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, other), identity_traits<std::vector<df::nemesis_record* > >::get(), 2, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::nemesis_record >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_nemesis::_identity(sizeof(world::T_nemesis), &allocator_fn<world::T_nemesis>, &world::_identity, "T_nemesis",NULL,world_doT_Dot_T_nemesis_fields);
  #define CUR_STRUCT world::T_items
  static const struct_field_info world_doT_Dot_T_items_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::item >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, other), identity_traits<std::vector<df::item* > >::get(), 129, TID(items_other_id) },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::item >::get(), 0, NULL },
    { FLD(CONTAINER, bad_tag), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_items::_identity(sizeof(world::T_items), &allocator_fn<world::T_items>, &world::_identity, "T_items",NULL,world_doT_Dot_T_items_fields);
  #define CUR_STRUCT world::T_artifacts
  static const struct_field_info world_doT_Dot_T_artifacts_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::artifact_record >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::artifact_record >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_artifacts::_identity(sizeof(world::T_artifacts), &allocator_fn<world::T_artifacts>, &world::_identity, "T_artifacts",NULL,world_doT_Dot_T_artifacts_fields);
  #define CUR_STRUCT world::T_anon_1
  static const struct_field_info world_doT_Dot_T_anon_1_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(POINTER, job), identity_traits<df::job >::get(), 0, NULL },
    { FLD(PRIMITIVE, flags), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_anon_1::_identity(sizeof(world::T_anon_1), &allocator_fn<world::T_anon_1>, &world::_identity, "T_anon_1",NULL,world_doT_Dot_T_anon_1_fields);
  #define CUR_STRUCT world::T_anon_2
  static const struct_field_info world_doT_Dot_T_anon_2_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_anon_2::_identity(sizeof(world::T_anon_2), &allocator_fn<world::T_anon_2>, &world::_identity, "T_anon_2",NULL,world_doT_Dot_T_anon_2_fields);
  #define CUR_STRUCT world::T_buildings
  static const struct_field_info world_doT_Dot_T_buildings_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::building >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, other), identity_traits<std::vector<df::building* > >::get(), 87, TID(buildings_other_id) },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::building >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_buildings::_identity(sizeof(world::T_buildings), &allocator_fn<world::T_buildings>, &world::_identity, "T_buildings",NULL,world_doT_Dot_T_buildings_fields);
  #define CUR_STRUCT world::T_machines
  static const struct_field_info world_doT_Dot_T_machines_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::machine >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::machine >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_machines::_identity(sizeof(world::T_machines), &allocator_fn<world::T_machines>, &world::_identity, "T_machines",NULL,world_doT_Dot_T_machines_fields);
  #define CUR_STRUCT world::T_flow_guides
  static const struct_field_info world_doT_Dot_T_flow_guides_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::flow_guide >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::flow_guide >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_flow_guides::_identity(sizeof(world::T_flow_guides), &allocator_fn<world::T_flow_guides>, &world::_identity, "T_flow_guides",NULL,world_doT_Dot_T_flow_guides_fields);
  #define CUR_STRUCT world::T_stockpile::T_simple1
  static const struct_field_info world_doT_Dot_T_stockpile_doT_Dot_T_simple1_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(PRIMITIVE, food), TID(int8_t) },
    { FLD(PRIMITIVE, anon_2), TID(int8_t) },
    { FLD(PRIMITIVE, anon_3), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_stockpile::T_simple1::_identity(sizeof(world::T_stockpile::T_simple1), &allocator_fn<world::T_stockpile::T_simple1>, &world::T_stockpile::_identity, "T_simple1",NULL,world_doT_Dot_T_stockpile_doT_Dot_T_simple1_fields);
  #define CUR_STRUCT world::T_stockpile::T_simple2
  static const struct_field_info world_doT_Dot_T_stockpile_doT_Dot_T_simple2_fields[] = {
    { FLD(PRIMITIVE, seeds), TID(int8_t) },
    { FLD(PRIMITIVE, plants), TID(int8_t) },
    { FLD(PRIMITIVE, cheese), TID(int8_t) },
    { FLD(PRIMITIVE, fish), TID(int8_t) },
    { FLD(PRIMITIVE, meat), TID(int8_t) },
    { FLD(PRIMITIVE, leaves), TID(int8_t) },
    { FLD(PRIMITIVE, powder), TID(int8_t) },
    { FLD(PRIMITIVE, eggs), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_stockpile::T_simple2::_identity(sizeof(world::T_stockpile::T_simple2), &allocator_fn<world::T_stockpile::T_simple2>, &world::T_stockpile::_identity, "T_simple2",NULL,world_doT_Dot_T_stockpile_doT_Dot_T_simple2_fields);
  #define CUR_STRUCT world::T_stockpile::T_simple3
  static const struct_field_info world_doT_Dot_T_stockpile_doT_Dot_T_simple3_fields[] = {
    { FLD(PRIMITIVE, glob_fat), TID(int8_t) },
    { FLD(PRIMITIVE, glob_tallow), TID(int8_t) },
    { FLD(PRIMITIVE, glob_paste), TID(int8_t) },
    { FLD(PRIMITIVE, glob_pressed), TID(int8_t) },
    { FLD(PRIMITIVE, weapons), TID(int8_t) },
    { FLD(PRIMITIVE, shields), TID(int8_t) },
    { FLD(PRIMITIVE, ammo), TID(int8_t) },
    { FLD(PRIMITIVE, coins), TID(int8_t) },
    { FLD(PRIMITIVE, bar_blocks), TID(int8_t) },
    { FLD(PRIMITIVE, gems), TID(int8_t) },
    { FLD(PRIMITIVE, finished_goods), TID(int8_t) },
    { FLD(PRIMITIVE, tanned_skins), TID(int8_t) },
    { FLD(PRIMITIVE, thread_cloth), TID(int8_t) },
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(PRIMITIVE, anon_2), TID(int8_t) },
    { FLD(PRIMITIVE, anon_3), TID(int8_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_stockpile::T_simple3::_identity(sizeof(world::T_stockpile::T_simple3), &allocator_fn<world::T_stockpile::T_simple3>, &world::T_stockpile::_identity, "T_simple3",NULL,world_doT_Dot_T_stockpile_doT_Dot_T_simple3_fields);
  #define CUR_STRUCT world::T_stockpile
  static const struct_field_info world_doT_Dot_T_stockpile_fields[] = {
    { FLD(STATIC_ARRAY, num_jobs), identity_traits<int32_t >::get(), 10, TID(hauler_type) },
    { FLD(STATIC_ARRAY, num_haulers), identity_traits<int32_t >::get(), 10, TID(hauler_type) },
    { FLD(SUBSTRUCT, simple1), &world::T_stockpile::T_simple1::_identity },
    { FLD(CONTAINER, seeds), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, plants), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, cheese), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, meat_fish), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, eggs), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, leaves), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, plant_powder), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, simple2), &world::T_stockpile::T_simple2::_identity },
    { FLD(CONTAINER, liquid_plant), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, liquid_animal), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(CONTAINER, liquid_builtin), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, simple3), &world::T_stockpile::T_simple3::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_stockpile::_identity(sizeof(world::T_stockpile), &allocator_fn<world::T_stockpile>, &world::_identity, "T_stockpile",NULL,world_doT_Dot_T_stockpile_fields);
  #define CUR_STRUCT world::T_plants
  static const struct_field_info world_doT_Dot_T_plants_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::plant >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, shrub_dry), identity_traits<df::plant >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, shrub_wet), identity_traits<df::plant >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, tree_dry), identity_traits<df::plant >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, tree_wet), identity_traits<df::plant >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, empty), identity_traits<df::plant >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_plants::_identity(sizeof(world::T_plants), &allocator_fn<world::T_plants>, &world::_identity, "T_plants",NULL,world_doT_Dot_T_plants_fields);
  typedef int32_t T_world_doT_Dot_T_enemy_status_cache_fields[500];
  #define CUR_STRUCT world::T_enemy_status_cache
  static const struct_field_info world_doT_Dot_T_enemy_status_cache_fields[] = {
    { FLD(STATIC_ARRAY, slot_used), identity_traits<bool >::get(), 500, NULL },
    { FLD(STATIC_ARRAY, rel_map), identity_traits<T_world_doT_Dot_T_enemy_status_cache_fields >::get(), 500, NULL },
    { FLD(PRIMITIVE, next_slot), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_enemy_status_cache::_identity(sizeof(world::T_enemy_status_cache), &allocator_fn<world::T_enemy_status_cache>, &world::_identity, "T_enemy_status_cache",NULL,world_doT_Dot_T_enemy_status_cache_fields);
  #define CUR_STRUCT world::T_schedules
  static const struct_field_info world_doT_Dot_T_schedules_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::schedule_info >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::schedule_info >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_schedules::_identity(sizeof(world::T_schedules), &allocator_fn<world::T_schedules>, &world::_identity, "T_schedules",NULL,world_doT_Dot_T_schedules_fields);
  #define CUR_STRUCT world::T_squads
  static const struct_field_info world_doT_Dot_T_squads_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::squad >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::squad >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_squads::_identity(sizeof(world::T_squads), &allocator_fn<world::T_squads>, &world::_identity, "T_squads",NULL,world_doT_Dot_T_squads_fields);
  #define CUR_STRUCT world::T_formations
  static const struct_field_info world_doT_Dot_T_formations_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<int32_t >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), NULL, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_formations::_identity(sizeof(world::T_formations), &allocator_fn<world::T_formations>, &world::_identity, "T_formations",NULL,world_doT_Dot_T_formations_fields);
  #define CUR_STRUCT world::T_activities
  static const struct_field_info world_doT_Dot_T_activities_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::activity_entry >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::activity_entry >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_activities::_identity(sizeof(world::T_activities), &allocator_fn<world::T_activities>, &world::_identity, "T_activities",NULL,world_doT_Dot_T_activities_fields);
  #define CUR_STRUCT world::T_status::T_slots
  static const struct_field_info world_doT_Dot_T_status_doT_Dot_T_slots_fields[] = {
    { FLD(PRIMITIVE, type), TID(combat_report_event_type) },
    { FLD(PRIMITIVE, item), TID(int32_t) },
    { FLD(PRIMITIVE, unk1b), TID(int32_t) },
    { FLD(PRIMITIVE, unk1c), TID(int32_t) },
    { FLD(PRIMITIVE, unk1d), TID(int32_t) },
    { FLD(PRIMITIVE, body_part), TID(int16_t) },
    { FLD(PRIMITIVE, unk2b), TID(int16_t) },
    { FLD(PRIMITIVE, unk2c), TID(int16_t) },
    { FLD(PRIMITIVE, unk2d), TID(int16_t) },
    { FLD(PRIMITIVE, target_bp_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, verb), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, with_item_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk3d), identity_traits<std::string >::get() },
    { FLD(SUBSTRUCT, flags), TID(world::T_status::T_slots::T_flags) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_status::T_slots::_identity(sizeof(world::T_status::T_slots), &allocator_fn<world::T_status::T_slots>, &world::T_status::_identity, "T_slots",NULL,world_doT_Dot_T_status_doT_Dot_T_slots_fields);
  #define CUR_STRUCT world::T_status
  static const struct_field_info world_doT_Dot_T_status_fields[] = {
    { FLD(STL_VECTOR_PTR, reports), identity_traits<df::report >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, announcements), identity_traits<df::report >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, popups), identity_traits<df::popup_message >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_report_id), TID(int32_t) },
    { FLD(SUBSTRUCT, flags), TID(world::T_status::T_flags) },
    { FLD(PRIMITIVE, display_timer), TID(int32_t) },
    { FLD(STATIC_ARRAY, slots), &world::T_status::T_slots::_identity, 100, NULL },
    { FLD(STATIC_ARRAY, slot_id_used), identity_traits<int16_t >::get(), 37, TID(combat_report_event_type) },
    { FLD(STATIC_ARRAY, slot_id_idx1), identity_traits<int16_t >::get(), 37, TID(combat_report_event_type) },
    { FLD(STATIC_ARRAY, slot_id_idx2), identity_traits<int16_t >::get(), 37, TID(combat_report_event_type) },
    { FLD(PRIMITIVE, slots_used), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_status::_identity(sizeof(world::T_status), &allocator_fn<world::T_status>, &world::_identity, "T_status",NULL,world_doT_Dot_T_status_fields);
  #define CUR_STRUCT world::T_interaction_instances
  static const struct_field_info world_doT_Dot_T_interaction_instances_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::interaction_instance >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::interaction_instance >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_interaction_instances::_identity(sizeof(world::T_interaction_instances), &allocator_fn<world::T_interaction_instances>, &world::_identity, "T_interaction_instances",NULL,world_doT_Dot_T_interaction_instances_fields);
  #define CUR_STRUCT world::T_written_contents
  static const struct_field_info world_doT_Dot_T_written_contents_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::written_content >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::written_content >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_written_contents::_identity(sizeof(world::T_written_contents), &allocator_fn<world::T_written_contents>, &world::_identity, "T_written_contents",NULL,world_doT_Dot_T_written_contents_fields);
  #define CUR_STRUCT world::T_identities
  static const struct_field_info world_doT_Dot_T_identities_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::identity >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::identity >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_identities::_identity(sizeof(world::T_identities), &allocator_fn<world::T_identities>, &world::_identity, "T_identities",NULL,world_doT_Dot_T_identities_fields);
  #define CUR_STRUCT world::T_incidents
  static const struct_field_info world_doT_Dot_T_incidents_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::incident >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::incident >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_incidents::_identity(sizeof(world::T_incidents), &allocator_fn<world::T_incidents>, &world::_identity, "T_incidents",NULL,world_doT_Dot_T_incidents_fields);
  #define CUR_STRUCT world::T_crimes
  static const struct_field_info world_doT_Dot_T_crimes_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::crime >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::crime >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_crimes::_identity(sizeof(world::T_crimes), &allocator_fn<world::T_crimes>, &world::_identity, "T_crimes",NULL,world_doT_Dot_T_crimes_fields);
  #define CUR_STRUCT world::T_vehicles
  static const struct_field_info world_doT_Dot_T_vehicles_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::vehicle >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, active), identity_traits<df::vehicle >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::vehicle >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_vehicles::_identity(sizeof(world::T_vehicles), &allocator_fn<world::T_vehicles>, &world::_identity, "T_vehicles",NULL,world_doT_Dot_T_vehicles_fields);
  #define CUR_STRUCT world::T_armies
  static const struct_field_info world_doT_Dot_T_armies_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::army >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::army >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_armies::_identity(sizeof(world::T_armies), &allocator_fn<world::T_armies>, &world::_identity, "T_armies",NULL,world_doT_Dot_T_armies_fields);
  #define CUR_STRUCT world::T_army_controllers
  static const struct_field_info world_doT_Dot_T_army_controllers_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::army_controller >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::army_controller >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_army_controllers::_identity(sizeof(world::T_army_controllers), &allocator_fn<world::T_army_controllers>, &world::_identity, "T_army_controllers",NULL,world_doT_Dot_T_army_controllers_fields);
  #define CUR_STRUCT world::T_army_tracking_info
  static const struct_field_info world_doT_Dot_T_army_tracking_info_fields[] = {
    { FLD(CONTAINER, all), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bad), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_army_tracking_info::_identity(sizeof(world::T_army_tracking_info), &allocator_fn<world::T_army_tracking_info>, &world::_identity, "T_army_tracking_info",NULL,world_doT_Dot_T_army_tracking_info_fields);
  #define CUR_STRUCT world::T_cultural_identities
  static const struct_field_info world_doT_Dot_T_cultural_identities_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::cultural_identity >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bad), identity_traits<df::cultural_identity >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_cultural_identities::_identity(sizeof(world::T_cultural_identities), &allocator_fn<world::T_cultural_identities>, &world::_identity, "T_cultural_identities",NULL,world_doT_Dot_T_cultural_identities_fields);
  #define CUR_STRUCT world::T_agreements
  static const struct_field_info world_doT_Dot_T_agreements_fields[] = {
    { FLD(CONTAINER, all), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, bad), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_agreements::_identity(sizeof(world::T_agreements), &allocator_fn<world::T_agreements>, &world::_identity, "T_agreements",NULL,world_doT_Dot_T_agreements_fields);
  #define CUR_STRUCT world::T_map
  static const struct_field_info world_doT_Dot_T_map_fields[] = {
    { FLD(STL_VECTOR_PTR, map_blocks), identity_traits<df::map_block >::get(), 0, NULL },
    { FLD(POINTER, block_index), identity_traits<df::map_block*** >::get(), 1, NULL },
    { FLD(STL_VECTOR_PTR, map_block_columns), identity_traits<df::map_block_column >::get(), 0, NULL },
    { FLD(POINTER, column_index), identity_traits<df::map_block_column** >::get(), 1, NULL },
    { FLD(PRIMITIVE, x_count_block), TID(int32_t) },
    { FLD(PRIMITIVE, y_count_block), TID(int32_t) },
    { FLD(PRIMITIVE, z_count_block), TID(int32_t) },
    { FLD(PRIMITIVE, x_count), TID(int32_t) },
    { FLD(PRIMITIVE, y_count), TID(int32_t) },
    { FLD(PRIMITIVE, z_count), TID(int32_t) },
    { FLD(PRIMITIVE, region_x), TID(int32_t) },
    { FLD(PRIMITIVE, region_y), TID(int32_t) },
    { FLD(PRIMITIVE, region_z), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_map::_identity(sizeof(world::T_map), &allocator_fn<world::T_map>, &world::_identity, "T_map",NULL,world_doT_Dot_T_map_fields);
  #define CUR_STRUCT world::T_map_extras
  static const struct_field_info world_doT_Dot_T_map_extras_fields[] = {
    { FLD(PRIMITIVE, rotation), TID(uint8_t) },
    { FLD(POINTER, z_level_flags), identity_traits<df::z_level_flags >::get(), 1, NULL },
    { FLD(STL_VECTOR_PTR, unk_v40_3a), identity_traits<df::block_square_event >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_3b), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_3c), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_3d), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_map_extras::_identity(sizeof(world::T_map_extras), &allocator_fn<world::T_map_extras>, &world::_identity, "T_map_extras",NULL,world_doT_Dot_T_map_extras_fields);
  #define CUR_STRUCT world::T_worldgen_status
  static const struct_field_info world_doT_Dot_T_worldgen_status_fields[] = {
    { FLD(PRIMITIVE, state), TID(int16_t) },
    { FLD(PRIMITIVE, num_rejects), TID(int32_t) },
    { FLD(STATIC_ARRAY, anon_1), identity_traits<int32_t >::get(), 53, NULL },
    { FLD(STATIC_ARRAY, anon_2), identity_traits<int32_t >::get(), 53, NULL },
    { FLD(PRIMITIVE, rejection_reason), TID(int16_t) },
    { FLD(PRIMITIVE, lakes_total), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int16_t) },
    { FLD(PRIMITIVE, lakes_cur), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(STATIC_ARRAY, anon_7), identity_traits<int32_t >::get(), 100, NULL },
    { FLD(STATIC_ARRAY, anon_8), identity_traits<int8_t >::get(), 100, NULL },
    { FLD(STATIC_ARRAY, anon_9), identity_traits<int16_t >::get(), 100, NULL },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { FLD(PRIMITIVE, finalized_civ_mats), TID(int32_t) },
    { FLD(PRIMITIVE, finalized_art), TID(int32_t) },
    { FLD(PRIMITIVE, finalized_uniforms), TID(int32_t) },
    { FLD(PRIMITIVE, finalized_sites), TID(int32_t) },
    { FLD(PRIMITIVE, anon_11), TID(int32_t) },
    { FLD(PRIMITIVE, anon_12), TID(int32_t) },
    { FLD(PRIMITIVE, anon_13), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, anon_14), NULL, 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_15), NULL, 0, NULL },
    { FLD(PRIMITIVE, width), TID(int32_t) },
    { FLD(PRIMITIVE, height), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, anon_16), NULL, 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_17), NULL, 0, NULL },
    { FLD(PRIMITIVE, rivers_total), TID(int32_t) },
    { FLD(PRIMITIVE, rivers_cur), TID(int32_t) },
    { FLD(PRIMITIVE, anon_18), TID(int8_t) },
    { FLD(PRIMITIVE, last_param_set), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, last_seed), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, last_name_seed), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, last_history_seed), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, last_creature_seed), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, placed_caves), TID(bool) },
    { FLD(PRIMITIVE, placed_good_evil), TID(bool) },
    { FLD(PRIMITIVE, placed_megabeasts), TID(bool) },
    { FLD(PRIMITIVE, placed_other_beasts), TID(bool) },
    { FLD(PRIMITIVE, made_cave_pops), TID(bool) },
    { FLD(PRIMITIVE, made_cave_civs), TID(bool) },
    { FLD(PRIMITIVE, placed_civs), TID(bool) },
    { FLD(PRIMITIVE, finished_prehistory), TID(bool) },
    { FLD(STL_VECTOR_PTR, anon_19), NULL, 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_20), NULL, 0, NULL },
    { FLD(PRIMITIVE, anon_21), TID(int32_t) },
    { FLD(PRIMITIVE, anon_22), TID(int8_t) },
    { FLD(PRIMITIVE, anon_23), TID(int8_t) },
    { FLD(PRIMITIVE, anon_24), TID(int8_t) },
    { FLD(PRIMITIVE, anon_25), TID(int8_t) },
    { FLD(STL_VECTOR_PTR, anon_26), NULL, 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_27), NULL, 0, NULL },
    { FLD(PRIMITIVE, anon_28), TID(int32_t) },
    { FLD(PRIMITIVE, anon_29), TID(int32_t) },
    { FLD(STATIC_ARRAY, anon_30), identity_traits<std::vector<void* > >::get(), 10, NULL },
    { FLD(STATIC_ARRAY, anon_31), identity_traits<std::vector<void* > >::get(), 10, NULL },
    { FLD(STATIC_ARRAY, anon_32), identity_traits<std::vector<void* > >::get(), 10, NULL },
    { FLD(CONTAINER, anon_33), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_34), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_35), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_36), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_37), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_38), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_39), TID(int32_t) },
    { FLD(PRIMITIVE, anon_40), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_worldgen_status::_identity(sizeof(world::T_worldgen_status), &allocator_fn<world::T_worldgen_status>, &world::_identity, "T_worldgen_status",NULL,world_doT_Dot_T_worldgen_status_fields);
  #define CUR_STRUCT world::T_unk_59dc4::T_unk1
  static const struct_field_info world_doT_Dot_T_unk_59dc4_doT_Dot_T_unk1_fields[] = {
    { FLD(SUBSTRUCT, ref), &world_population_ref::_identity },
    { FLD(CONTAINER, unk), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_unk_59dc4::T_unk1::_identity(sizeof(world::T_unk_59dc4::T_unk1), &allocator_fn<world::T_unk_59dc4::T_unk1>, &world::T_unk_59dc4::_identity, "T_unk1",NULL,world_doT_Dot_T_unk_59dc4_doT_Dot_T_unk1_fields);
  #define CUR_STRUCT world::T_unk_59dc4
  static const struct_field_info world_doT_Dot_T_unk_59dc4_fields[] = {
    { FLD(SUBSTRUCT, regions), &coord2d_path::_identity },
    { FLD(STL_VECTOR_PTR, unk1), &world::T_unk_59dc4::T_unk1::_identity, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_unk_59dc4::_identity(sizeof(world::T_unk_59dc4), &allocator_fn<world::T_unk_59dc4>, &world::_identity, "T_unk_59dc4",NULL,world_doT_Dot_T_unk_59dc4_fields);
  #define CUR_STRUCT world::T_flow_engine
  static const struct_field_info world_doT_Dot_T_flow_engine_fields[] = {
    { FLD(PRIMITIVE, rnd_16), TID(int8_t) },
    { FLD(PRIMITIVE, rnd_256), TID(int16_t) },
    { FLD(PRIMITIVE, rnd_pos), TID(int16_t) },
    { FLD(STATIC_ARRAY, rnd_x), identity_traits<int16_t >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, rnd_y), identity_traits<int16_t >::get(), 16, NULL },
    { FLD(PRIMITIVE, block_idx), TID(int32_t) },
    { FLD(CONTAINER, unk7a), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk7b), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk7c), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk7_cntdn), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_flow_engine::_identity(sizeof(world::T_flow_engine), &allocator_fn<world::T_flow_engine>, &world::_identity, "T_flow_engine",NULL,world_doT_Dot_T_flow_engine_fields);
  typedef int32_t T_world_doT_Dot_T_worldgen_doT_Dot_T_worldgen_parms_fields[10];
  typedef int32_t T_world_doT_Dot_T_worldgen_doT_Dot_T_worldgen_parms_fields_1[24];
  #define CUR_STRUCT world::T_worldgen::T_worldgen_parms
  static const struct_field_info world_doT_Dot_T_worldgen_doT_Dot_T_worldgen_parms_fields[] = {
    { FLD(PRIMITIVE, title), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, seed), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, history_seed), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_seed), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, creature_seed), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, dim_x), TID(int32_t) },
    { FLD(PRIMITIVE, dim_y), TID(int32_t) },
    { FLD(PRIMITIVE, custom_name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, has_seed), TID(bool) },
    { FLD(PRIMITIVE, has_history_seed), TID(bool) },
    { FLD(PRIMITIVE, has_name_seed), TID(bool) },
    { FLD(PRIMITIVE, has_creature_seed), TID(bool) },
    { FLD(PRIMITIVE, embark_points), TID(int32_t) },
    { FLD(PRIMITIVE, peak_number_min), TID(int32_t) },
    { FLD(PRIMITIVE, partial_ocean_edge_min), TID(int32_t) },
    { FLD(PRIMITIVE, complete_ocean_edge_min), TID(int32_t) },
    { FLD(PRIMITIVE, volcano_min), TID(int32_t) },
    { FLD(STATIC_ARRAY, region_counts), identity_traits<T_world_doT_Dot_T_worldgen_doT_Dot_T_worldgen_parms_fields >::get(), 3, NULL },
    { FLD(STATIC_ARRAY, river_mins), identity_traits<int32_t >::get(), 2, NULL },
    { FLD(PRIMITIVE, subregion_max), TID(int32_t) },
    { FLD(PRIMITIVE, cavern_layer_count), TID(int32_t) },
    { FLD(PRIMITIVE, cavern_layer_openness_min), TID(int32_t) },
    { FLD(PRIMITIVE, cavern_layer_openness_max), TID(int32_t) },
    { FLD(PRIMITIVE, cavern_layer_passage_density_min), TID(int32_t) },
    { FLD(PRIMITIVE, cavern_layer_passage_density_max), TID(int32_t) },
    { FLD(PRIMITIVE, cavern_layer_water_min), TID(int32_t) },
    { FLD(PRIMITIVE, cavern_layer_water_max), TID(int32_t) },
    { FLD(PRIMITIVE, have_bottom_layer_1), TID(bool) },
    { FLD(PRIMITIVE, have_bottom_layer_2), TID(bool) },
    { FLD(PRIMITIVE, levels_above_ground), TID(int32_t) },
    { FLD(PRIMITIVE, levels_above_layer_1), TID(int32_t) },
    { FLD(PRIMITIVE, levels_above_layer_2), TID(int32_t) },
    { FLD(PRIMITIVE, levels_above_layer_3), TID(int32_t) },
    { FLD(PRIMITIVE, levels_above_layer_4), TID(int32_t) },
    { FLD(PRIMITIVE, levels_above_layer_5), TID(int32_t) },
    { FLD(PRIMITIVE, levels_at_bottom), TID(int32_t) },
    { FLD(PRIMITIVE, cave_min_size), TID(int32_t) },
    { FLD(PRIMITIVE, cave_max_size), TID(int32_t) },
    { FLD(PRIMITIVE, mountain_cave_min), TID(int32_t) },
    { FLD(PRIMITIVE, non_mountain_cave_min), TID(int32_t) },
    { FLD(PRIMITIVE, total_civ_number), TID(int32_t) },
    { FLD(PRIMITIVE, rain_ranges_1), TID(int32_t) },
    { FLD(PRIMITIVE, rain_ranges_0), TID(int32_t) },
    { FLD(PRIMITIVE, rain_ranges_2), TID(int32_t) },
    { FLD(PRIMITIVE, drainage_ranges_1), TID(int32_t) },
    { FLD(PRIMITIVE, drainage_ranges_0), TID(int32_t) },
    { FLD(PRIMITIVE, drainage_ranges_2), TID(int32_t) },
    { FLD(PRIMITIVE, savagery_ranges_1), TID(int32_t) },
    { FLD(PRIMITIVE, savagery_ranges_0), TID(int32_t) },
    { FLD(PRIMITIVE, savagery_ranges_2), TID(int32_t) },
    { FLD(PRIMITIVE, volcanism_ranges_1), TID(int32_t) },
    { FLD(PRIMITIVE, volcanism_ranges_0), TID(int32_t) },
    { FLD(PRIMITIVE, volcanism_ranges_2), TID(int32_t) },
    { FLD(STATIC_ARRAY, ranges), identity_traits<T_world_doT_Dot_T_worldgen_doT_Dot_T_worldgen_parms_fields_1 >::get(), 4, NULL },
    { FLD(PRIMITIVE, beast_end_year), TID(int32_t) },
    { FLD(PRIMITIVE, end_year), TID(int32_t) },
    { FLD(PRIMITIVE, beast_end_year_percent), TID(int32_t) },
    { FLD(PRIMITIVE, total_civ_population), TID(int32_t) },
    { FLD(PRIMITIVE, site_cap), TID(int32_t) },
    { FLD(PRIMITIVE, elevation_ranges_1), TID(int32_t) },
    { FLD(PRIMITIVE, elevation_ranges_0), TID(int32_t) },
    { FLD(PRIMITIVE, elevation_ranges_2), TID(int32_t) },
    { FLD(PRIMITIVE, mineral_scarcity), TID(int32_t) },
    { FLD(PRIMITIVE, megabeast_cap), TID(int32_t) },
    { FLD(PRIMITIVE, semimegabeast_cap), TID(int32_t) },
    { FLD(PRIMITIVE, titan_number), TID(int32_t) },
    { FLD(STATIC_ARRAY, titan_attack_trigger), identity_traits<int32_t >::get(), 3, NULL },
    { FLD(PRIMITIVE, demon_number), TID(int32_t) },
    { FLD(PRIMITIVE, night_troll_number), TID(int32_t) },
    { FLD(PRIMITIVE, bogeyman_number), TID(int32_t) },
    { FLD(PRIMITIVE, vampire_number), TID(int32_t) },
    { FLD(PRIMITIVE, werebeast_number), TID(int32_t) },
    { FLD(PRIMITIVE, secret_number), TID(int32_t) },
    { FLD(PRIMITIVE, regional_interaction_number), TID(int32_t) },
    { FLD(PRIMITIVE, disturbance_interaction_number), TID(int32_t) },
    { FLD(PRIMITIVE, evil_cloud_number), TID(int32_t) },
    { FLD(PRIMITIVE, evil_rain_number), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, good_sq_counts_0), TID(int32_t) },
    { FLD(PRIMITIVE, evil_sq_counts_0), TID(int32_t) },
    { FLD(PRIMITIVE, good_sq_counts_1), TID(int32_t) },
    { FLD(PRIMITIVE, evil_sq_counts_1), TID(int32_t) },
    { FLD(PRIMITIVE, good_sq_counts_2), TID(int32_t) },
    { FLD(PRIMITIVE, evil_sq_counts_2), TID(int32_t) },
    { FLD(STATIC_ARRAY, elevation_frequency), identity_traits<int32_t >::get(), 6, NULL },
    { FLD(STATIC_ARRAY, rain_frequency), identity_traits<int32_t >::get(), 6, NULL },
    { FLD(STATIC_ARRAY, drainage_frequency), identity_traits<int32_t >::get(), 6, NULL },
    { FLD(STATIC_ARRAY, savagery_frequency), identity_traits<int32_t >::get(), 6, NULL },
    { FLD(STATIC_ARRAY, temperature_frequency), identity_traits<int32_t >::get(), 6, NULL },
    { FLD(STATIC_ARRAY, volcanism_frequency), identity_traits<int32_t >::get(), 6, NULL },
    { FLD(POINTER, ps), NULL, 0, NULL },
    { FLD(PRIMITIVE, reveal_all_history), TID(int32_t) },
    { FLD(PRIMITIVE, cull_historical_figures), TID(int32_t) },
    { FLD(PRIMITIVE, erosion_cycle_count), TID(int32_t) },
    { FLD(PRIMITIVE, periodically_erode_extremes), TID(int32_t) },
    { FLD(PRIMITIVE, orographic_precipitation), TID(int32_t) },
    { FLD(PRIMITIVE, playable_civilization_required), TID(int32_t) },
    { FLD(PRIMITIVE, all_caves_visible), TID(int32_t) },
    { FLD(PRIMITIVE, show_embark_tunnel), TID(int32_t) },
    { FLD(PRIMITIVE, pole), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_worldgen::T_worldgen_parms::_identity(sizeof(world::T_worldgen::T_worldgen_parms), &allocator_fn<world::T_worldgen::T_worldgen_parms>, &world::T_worldgen::_identity, "T_worldgen_parms",NULL,world_doT_Dot_T_worldgen_doT_Dot_T_worldgen_parms_fields);
  #define CUR_STRUCT world::T_worldgen
  static const struct_field_info world_doT_Dot_T_worldgen_fields[] = {
    { FLD(PRIMITIVE, version), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, next_unit_chunk_id), TID(int32_t) },
    { FLD(PRIMITIVE, next_unit_chunk_offset), TID(int16_t) },
    { FLD(PRIMITIVE, next_art_image_chunk_id), TID(int32_t) },
    { FLD(PRIMITIVE, next_art_image_chunk_offset), TID(int16_t) },
    { FLD(SUBSTRUCT, worldgen_parms), &world::T_worldgen::T_worldgen_parms::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_worldgen::_identity(sizeof(world::T_worldgen), &allocator_fn<world::T_worldgen>, &world::_identity, "T_worldgen",NULL,world_doT_Dot_T_worldgen_fields);
  #define CUR_STRUCT world::T_pathfinder::T_boundary_heap
  static const struct_field_info world_doT_Dot_T_pathfinder_doT_Dot_T_boundary_heap_fields[] = {
    { FLD(PRIMITIVE, total_cost), TID(int32_t) },
    { FLD(PRIMITIVE, local_cost), TID(int32_t) },
    { FLD(PRIMITIVE, x), TID(int16_t) },
    { FLD(PRIMITIVE, y), TID(int16_t) },
    { FLD(PRIMITIVE, z), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_pathfinder::T_boundary_heap::_identity(sizeof(world::T_pathfinder::T_boundary_heap), &allocator_fn<world::T_pathfinder::T_boundary_heap>, &world::T_pathfinder::_identity, "T_boundary_heap",NULL,world_doT_Dot_T_pathfinder_doT_Dot_T_boundary_heap_fields);
  #define CUR_STRUCT world::T_pathfinder
  static const struct_field_info world_doT_Dot_T_pathfinder_fields[] = {
    { FLD(STATIC_ARRAY, boundary_heap), &world::T_pathfinder::T_boundary_heap::_identity, 80000, NULL },
    { FLD(PRIMITIVE, heap_count), TID(int32_t) },
    { FLD(SUBSTRUCT, pos1), &coord::_identity },
    { FLD(SUBSTRUCT, pos2), &coord::_identity },
    { FLD(PRIMITIVE, dist_x), TID(int32_t) },
    { FLD(PRIMITIVE, dist_y), TID(int32_t) },
    { FLD(PRIMITIVE, dist_z), TID(int32_t) },
    { FLD(PRIMITIVE, next_path_cost), TID(int32_t) },
    { FLD(PRIMITIVE, wipe_path_cost), TID(bool) },
    { FLD(PRIMITIVE, next_path_tag), TID(uint16_t) },
    { FLD(PRIMITIVE, wipe_path_tag), TID(bool) },
    { FLD(PRIMITIVE, next_walkable_id), TID(int16_t) },
    { FLD(PRIMITIVE, plant_update_step), TID(int16_t) },
    { FLD(PRIMITIVE, anon_1), TID(bool) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_pathfinder::_identity(sizeof(world::T_pathfinder), &allocator_fn<world::T_pathfinder>, &world::_identity, "T_pathfinder",NULL,world_doT_Dot_T_pathfinder_fields);
  #define CUR_STRUCT world::T_cur_savegame
  static const struct_field_info world_doT_Dot_T_cur_savegame_fields[] = {
    { FLD(PRIMITIVE, save_dir), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, unk_v40_1), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_2), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_3), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_4), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_v40_5), identity_traits<std::string >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_v40_6), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_7), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_cur_savegame::_identity(sizeof(world::T_cur_savegame), &allocator_fn<world::T_cur_savegame>, &world::_identity, "T_cur_savegame",NULL,world_doT_Dot_T_cur_savegame_fields);
  #define CUR_STRUCT world::T_features
  static const struct_field_info world_doT_Dot_T_features_fields[] = {
    { FLD(STL_VECTOR_PTR, map_features), identity_traits<df::feature_init >::get(), 0, NULL },
    { FLD(CONTAINER, feature_x), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, feature_y), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, feature_local_idx), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, feature_global_idx), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_1), identity_traits<df::feature_init >::get(), 0, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_6), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_8), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_9), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_10), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_11), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_12), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_13), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_14), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_15), identity_traits<std::vector<bool> >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_features::_identity(sizeof(world::T_features), &allocator_fn<world::T_features>, &world::_identity, "T_features",NULL,world_doT_Dot_T_features_fields);
  #define CUR_STRUCT world::T_arena_spawn::T_item_types
  static const struct_field_info world_doT_Dot_T_arena_spawn_doT_Dot_T_item_types_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mattype), TID(int16_t) },
    { FLD(PRIMITIVE, matindex), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(bool) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_arena_spawn::T_item_types::_identity(sizeof(world::T_arena_spawn::T_item_types), &allocator_fn<world::T_arena_spawn::T_item_types>, &world::T_arena_spawn::_identity, "T_item_types",NULL,world_doT_Dot_T_arena_spawn_doT_Dot_T_item_types_fields);
  #define CUR_STRUCT world::T_arena_spawn::T_equipment
  static const struct_field_info world_doT_Dot_T_arena_spawn_doT_Dot_T_equipment_fields[] = {
    { FLD(CONTAINER, skills), identity_traits<std::vector<df::job_skill > >::get(), 0, NULL },
    { FLD(CONTAINER, skill_levels), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, item_types), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { FLD(CONTAINER, item_subtypes), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, item_materials), &material_vec_ref::_identity },
    { FLD(CONTAINER, item_counts), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_arena_spawn::T_equipment::_identity(sizeof(world::T_arena_spawn::T_equipment), &allocator_fn<world::T_arena_spawn::T_equipment>, &world::T_arena_spawn::_identity, "T_equipment",NULL,world_doT_Dot_T_arena_spawn_doT_Dot_T_equipment_fields);
  #define CUR_STRUCT world::T_arena_spawn
  static const struct_field_info world_doT_Dot_T_arena_spawn_fields[] = {
    { FLD(CONTAINER, race), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, caste), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, type), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), identity_traits<std::string >::get() },
    { FLD(STATIC_ARRAY, item_types), identity_traits<std::vector<df::world::T_arena_spawn::T_item_types* > >::get(), 107, NULL },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, equipment), &world::T_arena_spawn::T_equipment::_identity },
    { FLD(PRIMITIVE, side), TID(int32_t) },
    { FLD(PRIMITIVE, interaction), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, interactions), NULL, 0, NULL },
    { FLD(CONTAINER, creature_cnt), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, conflict_level), TID(int32_t) },
    { FLD(PRIMITIVE, morale_enable), TID(bool) },
    { FLD(PRIMITIVE, anon_6), TID(int16_t) },
    { FLD(PRIMITIVE, temperature), TID(uint16_t) },
    { FLD(PRIMITIVE, time), TID(int16_t) },
    { FLD(PRIMITIVE, weather_column), TID(int32_t) },
    { FLD(PRIMITIVE, weather_row), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, tree_types), identity_traits<df::plant_raw >::get(), 0, NULL },
    { FLD(PRIMITIVE, tree_cursor), TID(int32_t) },
    { FLD(PRIMITIVE, tree_age), TID(int32_t) },
    { FLD(PRIMITIVE, tree_filter), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, tree_age_str), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_arena_spawn::_identity(sizeof(world::T_arena_spawn), &allocator_fn<world::T_arena_spawn>, &world::_identity, "T_arena_spawn",NULL,world_doT_Dot_T_arena_spawn_fields);
  #define CUR_STRUCT world::T_unk_19325c::T_anon_1
  static const struct_field_info world_doT_Dot_T_unk_19325c_doT_Dot_T_anon_1_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int16_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_unk_19325c::T_anon_1::_identity(sizeof(world::T_unk_19325c::T_anon_1), &allocator_fn<world::T_unk_19325c::T_anon_1>, &world::T_unk_19325c::_identity, "T_anon_1",NULL,world_doT_Dot_T_unk_19325c_doT_Dot_T_anon_1_fields);
  #define CUR_STRUCT world::T_unk_19325c::T_anon_2
  static const struct_field_info world_doT_Dot_T_unk_19325c_doT_Dot_T_anon_2_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_unk_19325c::T_anon_2::_identity(sizeof(world::T_unk_19325c::T_anon_2), &allocator_fn<world::T_unk_19325c::T_anon_2>, &world::T_unk_19325c::_identity, "T_anon_2",NULL,world_doT_Dot_T_unk_19325c_doT_Dot_T_anon_2_fields);
  #define CUR_STRUCT world::T_unk_19325c::T_anon_3
  static const struct_field_info world_doT_Dot_T_unk_19325c_doT_Dot_T_anon_3_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_unk_19325c::T_anon_3::_identity(sizeof(world::T_unk_19325c::T_anon_3), &allocator_fn<world::T_unk_19325c::T_anon_3>, &world::T_unk_19325c::_identity, "T_anon_3",NULL,world_doT_Dot_T_unk_19325c_doT_Dot_T_anon_3_fields);
  #define CUR_STRUCT world::T_unk_19325c
  static const struct_field_info world_doT_Dot_T_unk_19325c_fields[] = {
    { FLD(STL_VECTOR_PTR, anon_1), &world::T_unk_19325c::T_anon_1::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_2), &world::T_unk_19325c::T_anon_2::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_3), &world::T_unk_19325c::T_anon_3::_identity, 0, NULL },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::T_unk_19325c::_identity(sizeof(world::T_unk_19325c), &allocator_fn<world::T_unk_19325c>, &world::_identity, "T_unk_19325c",NULL,world_doT_Dot_T_unk_19325c_fields);
  typedef int16_t T_world_fields[53];
  #define CUR_STRUCT world
  static const struct_field_info world_fields[] = {
    { FLD(STL_VECTOR_PTR, glowing_barriers), identity_traits<df::glowing_barrier >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, deep_vein_hollows), identity_traits<df::deep_vein_hollow >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_20), identity_traits<df::world_unk_20 >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, engravings), identity_traits<df::engraving >::get(), 0, NULL },
    { FLD(SUBSTRUCT, vermin), &world::T_vermin::_identity },
    { FLD(STL_VECTOR_PTR, unk_3C), identity_traits<df::coord >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, campfires), identity_traits<df::campfire >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, web_clusters), identity_traits<df::web_cluster >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, fires), identity_traits<df::fire >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_6C), identity_traits<df::world_unk_6c >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, ocean_waves), identity_traits<df::ocean_wave >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, constructions), identity_traits<df::construction >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_90), identity_traits<df::world_unk_90 >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_9C), identity_traits<df::world_unk_9c >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_A8), identity_traits<df::world_unk_a8 >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_B4), identity_traits<df::world_unk_b4 >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_C0), identity_traits<df::world_unk_c0 >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_CC), identity_traits<df::engraving >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_D8), identity_traits<df::construction >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_E4), identity_traits<df::world_unk_9c >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_F0), identity_traits<df::world_unk_6c >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_FC), identity_traits<df::world_unk_90 >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, effects), identity_traits<df::effect_info >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, coin_batches), identity_traits<df::coin_batch >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, populations), identity_traits<df::local_population >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, manager_orders), identity_traits<df::manager_order >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, mandates), identity_traits<df::mandate >::get(), 0, NULL },
    { FLD(SUBSTRUCT, entities), &world::T_entities::_identity },
    { FLD(SUBSTRUCT, worldgen_coord_buf), &world::T_worldgen_coord_buf::_identity },
    { FLD(SUBSTRUCT, units), &world::T_units::_identity },
    { FLD(STL_VECTOR_PTR, unit_chunks), identity_traits<df::unit_chunk >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, art_image_chunks), identity_traits<df::art_image_chunk >::get(), 0, NULL },
    { FLD(SUBSTRUCT, nemesis), &world::T_nemesis::_identity },
    { FLD(PRIMITIVE, unk4), TID(bool) },
    { FLD(SUBSTRUCT, items), &world::T_items::_identity },
    { FLD(SUBSTRUCT, artifacts), &world::T_artifacts::_identity },
    { FLD(CONTAINER, job_list), identity_traits<df::job_list_link >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, anon_1), &world::T_anon_1::_identity, 0, NULL },
    { FLD(STATIC_ARRAY, anon_2), &world::T_anon_2::_identity, 2000, NULL },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(CONTAINER, proj_list), identity_traits<df::proj_list_link >::get(), 0, NULL },
    { FLD(SUBSTRUCT, buildings), &world::T_buildings::_identity },
    { FLD(PRIMITIVE, check_bridge_collapse), TID(bool) },
    { FLD(PRIMITIVE, check_machine_collapse), TID(bool) },
    { FLD(SUBSTRUCT, machines), &world::T_machines::_identity },
    { FLD(SUBSTRUCT, flow_guides), &world::T_flow_guides::_identity },
    { FLD(SUBSTRUCT, stockpile), &world::T_stockpile::_identity },
    { FLD(SUBSTRUCT, plants), &world::T_plants::_identity },
    { FLD(SUBSTRUCT, enemy_status_cache), &world::T_enemy_status_cache::_identity },
    { FLD(SUBSTRUCT, schedules), &world::T_schedules::_identity },
    { FLD(SUBSTRUCT, squads), &world::T_squads::_identity },
    { FLD(SUBSTRUCT, formations), &world::T_formations::_identity },
    { FLD(SUBSTRUCT, activities), &world::T_activities::_identity },
    { FLD(SUBSTRUCT, status), &world::T_status::_identity },
    { FLD(SUBSTRUCT, interaction_instances), &world::T_interaction_instances::_identity },
    { FLD(SUBSTRUCT, written_contents), &world::T_written_contents::_identity },
    { FLD(SUBSTRUCT, identities), &world::T_identities::_identity },
    { FLD(SUBSTRUCT, incidents), &world::T_incidents::_identity },
    { FLD(SUBSTRUCT, crimes), &world::T_crimes::_identity },
    { FLD(SUBSTRUCT, vehicles), &world::T_vehicles::_identity },
    { FLD(SUBSTRUCT, armies), &world::T_armies::_identity },
    { FLD(SUBSTRUCT, army_controllers), &world::T_army_controllers::_identity },
    { FLD(SUBSTRUCT, army_tracking_info), &world::T_army_tracking_info::_identity },
    { FLD(SUBSTRUCT, cultural_identities), &world::T_cultural_identities::_identity },
    { FLD(SUBSTRUCT, agreements), &world::T_agreements::_identity },
    { FLD(POINTER, selected_building), identity_traits<df::building >::get(), 0, NULL },
    { FLD(PRIMITIVE, selected_stockpile_type), TID(stockpile_category) },
    { FLD(PRIMITIVE, update_selected_building), TID(bool) },
    { FLD(PRIMITIVE, building_width), TID(int16_t) },
    { FLD(PRIMITIVE, building_height), TID(int16_t) },
    { FLD(PRIMITIVE, selected_direction), TID(screw_pump_direction) },
    { FLD(SUBSTRUCT, map), &world::T_map::_identity },
    { FLD(STATIC_ARRAY, distance_lookup), identity_traits<T_world_fields >::get(), 53, NULL },
    { FLD(STATIC_ARRAY, unk_v40_1a), identity_traits<std::vector<int16_t > >::get(), 112, TID(profession) },
    { FLD(STATIC_ARRAY, unk_v40_1b), identity_traits<std::vector<int16_t > >::get(), 112, TID(profession) },
    { FLD(STATIC_ARRAY, unk_v40_2a), identity_traits<int32_t >::get(), 80, NULL },
    { FLD(STATIC_ARRAY, unk_v40_2b), identity_traits<double >::get(), 181, NULL },
    { FLD(STATIC_ARRAY, unk_v40_2c), identity_traits<double >::get(), 121, NULL },
    { FLD(SUBSTRUCT, map_extras), &world::T_map_extras::_identity },
    { FLD(POINTER, world_data), identity_traits<df::world_data >::get(), 0, NULL },
    { FLD(SUBSTRUCT, worldgen_status), &world::T_worldgen_status::_identity },
    { FLD(CONTAINER, unk_10d298), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_10d2a4), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, orphaned_flow_pool), &flow_reuse_pool::_identity },
    { FLD(SUBSTRUCT, raws), &world_raws::_identity },
    { FLD(SUBSTRUCT, unk_59dc4), &world::T_unk_59dc4::_identity },
    { FLD(SUBSTRUCT, flow_engine), &world::T_flow_engine::_identity },
    { FLD(CONTAINER, busy_buildings), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, cavein_flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(PRIMITIVE, original_save_version), TID(int32_t) },
    { FLD(SUBSTRUCT, worldgen), &world::T_worldgen::_identity },
    { FLD(SUBSTRUCT, history), &world_history::_identity },
    { FLD(STL_VECTOR_PTR, entity_populations), identity_traits<df::entity_population >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, unk_v40_6a), identity_traits<std::vector<int32_t > >::get(), 336, NULL },
    { FLD(STATIC_ARRAY, unk_v40_6b), identity_traits<std::vector<int32_t > >::get(), 336, NULL },
    { FLD(STATIC_ARRAY, unk_v40_6c), identity_traits<std::vector<int32_t > >::get(), 336, NULL },
    { FLD(STATIC_ARRAY, unk_v40_6d), identity_traits<std::vector<int32_t > >::get(), 336, NULL },
    { FLD(STATIC_ARRAY, unk_v40_6e), identity_traits<std::vector<int32_t > >::get(), 336, NULL },
    { FLD(STATIC_ARRAY, unk_v40_6f), identity_traits<std::vector<int32_t > >::get(), 336, NULL },
    { FLD(CONTAINER, unk_v40_7), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, reindex_pathfinding), TID(bool) },
    { FLD(PRIMITIVE, frame_counter), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, orphaned_flows), identity_traits<df::flow_info >::get(), 0, NULL },
    { FLD(SUBSTRUCT, pathfinder), &world::T_pathfinder::_identity },
    { FLD(SUBSTRUCT, cur_savegame), &world::T_cur_savegame::_identity },
    { FLD(SUBSTRUCT, features), &world::T_features::_identity },
    { FLD(PRIMITIVE, anon_4), TID(bool) },
    { FLD(PRIMITIVE, anon_5), TID(bool) },
    { FLD(SUBSTRUCT, arena_spawn), &world::T_arena_spawn::_identity },
    { FLD(SUBSTRUCT, unk_19325c), &world::T_unk_19325c::_identity },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world::_identity(sizeof(world), &allocator_fn<world>, NULL, "world",NULL,world_fields);
  #define CUR_STRUCT world_construction
  static const struct_field_info world_construction_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, square_obj), identity_traits<df::world_construction_square >::get(), 0, NULL },
    { FLD(SUBSTRUCT, square_pos), &coord2d_path::_identity },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, getName) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity world_construction::_identity(sizeof(world_construction), &allocator_fn<world_construction>, "world_construction","world_constructionst",NULL,world_construction_fields);
  #define CUR_STRUCT world_construction_bridgest
  static const struct_field_info world_construction_bridgest_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity world_construction_bridgest::_identity(sizeof(world_construction_bridgest), &allocator_fn<world_construction_bridgest>, "world_construction_bridgest",NULL,&world_construction::_identity,world_construction_bridgest_fields);
  #define CUR_STRUCT world_construction_roadst
  static const struct_field_info world_construction_roadst_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity world_construction_roadst::_identity(sizeof(world_construction_roadst), &allocator_fn<world_construction_roadst>, "world_construction_roadst",NULL,&world_construction::_identity,world_construction_roadst_fields);
  #define CUR_STRUCT world_construction_square
  static const struct_field_info world_construction_square_fields[] = {
    { FLD(SUBSTRUCT, region_pos), &coord2d::_identity },
    { FLD(PRIMITIVE, construction_id), TID(int32_t) },
    { FLD(CONTAINER, embark_x), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, embark_y), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, embark_unk), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, embark_z), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { METHOD(OBJ_METHOD, getType) },
    { METHOD(OBJ_METHOD, write_file) },
    { METHOD(OBJ_METHOD, read_file) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity world_construction_square::_identity(sizeof(world_construction_square), &allocator_fn<world_construction_square>, "world_construction_square","world_construction_squarest",NULL,world_construction_square_fields);
  #define CUR_STRUCT world_construction_square_bridgest
  static const struct_field_info world_construction_square_bridgest_fields[] = {
    { FLD(PRIMITIVE, road_id), TID(int32_t) },
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity world_construction_square_bridgest::_identity(sizeof(world_construction_square_bridgest), &allocator_fn<world_construction_square_bridgest>, "world_construction_square_bridgest",NULL,&world_construction_square::_identity,world_construction_square_bridgest_fields);
  #define CUR_STRUCT world_construction_square_roadst
  static const struct_field_info world_construction_square_roadst_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity world_construction_square_roadst::_identity(sizeof(world_construction_square_roadst), &allocator_fn<world_construction_square_roadst>, "world_construction_square_roadst",NULL,&world_construction_square::_identity,world_construction_square_roadst_fields);
  virtual_identity world_construction_square_tunnelst::_identity(sizeof(world_construction_square_tunnelst), &allocator_fn<world_construction_square_tunnelst>, "world_construction_square_tunnelst",NULL,&world_construction_square::_identity,NULL);
  #define CUR_STRUCT world_construction_square_wallst
  static const struct_field_info world_construction_square_wallst_fields[] = {
    { FLD(PRIMITIVE, item_type), TID(item_type) },
    { FLD(PRIMITIVE, item_subtype), TID(int16_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity world_construction_square_wallst::_identity(sizeof(world_construction_square_wallst), &allocator_fn<world_construction_square_wallst>, "world_construction_square_wallst",NULL,&world_construction_square::_identity,world_construction_square_wallst_fields);
  #define CUR_STRUCT world_construction_tunnelst
  static const struct_field_info world_construction_tunnelst_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity world_construction_tunnelst::_identity(sizeof(world_construction_tunnelst), &allocator_fn<world_construction_tunnelst>, "world_construction_tunnelst",NULL,&world_construction::_identity,world_construction_tunnelst_fields);
  #define CUR_STRUCT world_construction_wallst
  static const struct_field_info world_construction_wallst_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  virtual_identity world_construction_wallst::_identity(sizeof(world_construction_wallst), &allocator_fn<world_construction_wallst>, "world_construction_wallst",NULL,&world_construction::_identity,world_construction_wallst_fields);
  #define CUR_STRUCT world_data::T_unk_b4
  static const struct_field_info world_data_doT_Dot_T_unk_b4_fields[] = {
    { FLD(PRIMITIVE, world_width2), TID(int32_t) },
    { FLD(PRIMITIVE, world_height2), TID(int32_t) },
    { FLD(POINTER, anon_1), identity_traits<uint32_t >::get(), 1, NULL },
    { FLD(POINTER, anon_2), identity_traits<uint32_t >::get(), 1, NULL },
    { FLD(POINTER, anon_3), identity_traits<uint32_t >::get(), 1, NULL },
    { FLD(POINTER, anon_4), identity_traits<uint8_t >::get(), 1, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_unk_b4::_identity(sizeof(world_data::T_unk_b4), &allocator_fn<world_data::T_unk_b4>, &world_data::_identity, "T_unk_b4",NULL,world_data_doT_Dot_T_unk_b4_fields);
  #define CUR_STRUCT world_data::T_constructions
  static const struct_field_info world_data_doT_Dot_T_constructions_fields[] = {
    { FLD(PRIMITIVE, width), TID(int16_t) },
    { FLD(PRIMITIVE, height), TID(int16_t) },
    { FLD(POINTER, map), identity_traits<std::vector<df::world_construction_square* >* >::get(), 1, NULL },
    { FLD(STL_VECTOR_PTR, list), identity_traits<df::world_construction >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_constructions::_identity(sizeof(world_data::T_constructions), &allocator_fn<world_data::T_constructions>, &world_data::_identity, "T_constructions",NULL,world_data_doT_Dot_T_constructions_fields);
  #define CUR_STRUCT world_data::T_unk_150::T_unk_8
  static const struct_field_info world_data_doT_Dot_T_unk_150_doT_Dot_T_unk_8_fields[] = {
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_unk_150::T_unk_8::_identity(sizeof(world_data::T_unk_150::T_unk_8), &allocator_fn<world_data::T_unk_150::T_unk_8>, &world_data::T_unk_150::_identity, "T_unk_8",NULL,world_data_doT_Dot_T_unk_150_doT_Dot_T_unk_8_fields);
  #define CUR_STRUCT world_data::T_unk_150::T_unk_18
  static const struct_field_info world_data_doT_Dot_T_unk_150_doT_Dot_T_unk_18_fields[] = {
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_unk_150::T_unk_18::_identity(sizeof(world_data::T_unk_150::T_unk_18), &allocator_fn<world_data::T_unk_150::T_unk_18>, &world_data::T_unk_150::_identity, "T_unk_18",NULL,world_data_doT_Dot_T_unk_150_doT_Dot_T_unk_18_fields);
  #define CUR_STRUCT world_data::T_unk_150::T_unk_28
  static const struct_field_info world_data_doT_Dot_T_unk_150_doT_Dot_T_unk_28_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_unk_150::T_unk_28::_identity(sizeof(world_data::T_unk_150::T_unk_28), &allocator_fn<world_data::T_unk_150::T_unk_28>, &world_data::T_unk_150::_identity, "T_unk_28",NULL,world_data_doT_Dot_T_unk_150_doT_Dot_T_unk_28_fields);
  #define CUR_STRUCT world_data::T_unk_150
  static const struct_field_info world_data_doT_Dot_T_unk_150_fields[] = {
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_8), &world_data::T_unk_150::T_unk_8::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_18), &world_data::T_unk_150::T_unk_18::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_28), &world_data::T_unk_150::T_unk_28::_identity, 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_unk_150::_identity(sizeof(world_data::T_unk_150), &allocator_fn<world_data::T_unk_150>, &world_data::_identity, "T_unk_150",NULL,world_data_doT_Dot_T_unk_150_fields);
  #define CUR_STRUCT world_data::T_unk_170::T_unk_4
  static const struct_field_info world_data_doT_Dot_T_unk_170_doT_Dot_T_unk_4_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_unk_170::T_unk_4::_identity(sizeof(world_data::T_unk_170::T_unk_4), &allocator_fn<world_data::T_unk_170::T_unk_4>, &world_data::T_unk_170::_identity, "T_unk_4",NULL,world_data_doT_Dot_T_unk_170_doT_Dot_T_unk_4_fields);
  #define CUR_STRUCT world_data::T_unk_170
  static const struct_field_info world_data_doT_Dot_T_unk_170_fields[] = {
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_4), &world_data::T_unk_170::T_unk_4::_identity, 0, NULL },
    { FLD(CONTAINER, unk_14), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_24), TID(int32_t) },
    { FLD(PRIMITIVE, unk_28), TID(int32_t) },
    { FLD(PRIMITIVE, unk_2c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_30), TID(int32_t) },
    { FLD(PRIMITIVE, unk_34), TID(int32_t) },
    { FLD(CONTAINER, unk_38), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_unk_170::_identity(sizeof(world_data::T_unk_170), &allocator_fn<world_data::T_unk_170>, &world_data::_identity, "T_unk_170",NULL,world_data_doT_Dot_T_unk_170_fields);
  #define CUR_STRUCT world_data::T_freakish_weather
  static const struct_field_info world_data_doT_Dot_T_freakish_weather_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, mat_type), TID(int16_t) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, region_x), TID(int32_t) },
    { FLD(PRIMITIVE, region_y), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_20), TID(int32_t) },
    { FLD(PRIMITIVE, unk_24), TID(int32_t) },
    { FLD(PRIMITIVE, unk_28), TID(int32_t) },
    { FLD(PRIMITIVE, unk_2c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_30), TID(int32_t) },
    { FLD(PRIMITIVE, unk_34), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_freakish_weather::_identity(sizeof(world_data::T_freakish_weather), &allocator_fn<world_data::T_freakish_weather>, &world_data::_identity, "T_freakish_weather",NULL,world_data_doT_Dot_T_freakish_weather_fields);
  #define CUR_STRUCT world_data::T_mountain_peaks
  static const struct_field_info world_data_doT_Dot_T_mountain_peaks_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(SUBSTRUCT, pos), &coord2d::_identity },
    { FLD(CONTAINER, flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(PRIMITIVE, height), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_mountain_peaks::_identity(sizeof(world_data::T_mountain_peaks), &allocator_fn<world_data::T_mountain_peaks>, &world_data::_identity, "T_mountain_peaks",NULL,world_data_doT_Dot_T_mountain_peaks_fields);
  typedef std::vector<df::feature_init* > T_world_data_doT_Dot_T_feature_map_doT_Dot_T_features_fields[16];
  typedef int32_t T_world_data_doT_Dot_T_feature_map_doT_Dot_T_features_fields_1[16][30];
  #define CUR_STRUCT world_data::T_feature_map::T_features
  static const struct_field_info world_data_doT_Dot_T_feature_map_doT_Dot_T_features_fields[] = {
    { FLD(STATIC_ARRAY, feature_init), identity_traits<T_world_data_doT_Dot_T_feature_map_doT_Dot_T_features_fields >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, unk), identity_traits<T_world_data_doT_Dot_T_feature_map_doT_Dot_T_features_fields_1 >::get(), 16, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_feature_map::T_features::_identity(sizeof(world_data::T_feature_map::T_features), &allocator_fn<world_data::T_feature_map::T_features>, &world_data::T_feature_map::_identity, "T_features",NULL,world_data_doT_Dot_T_feature_map_doT_Dot_T_features_fields);
  #define CUR_STRUCT world_data::T_feature_map
  static const struct_field_info world_data_doT_Dot_T_feature_map_fields[] = {
    { FLD(PRIMITIVE, x), TID(int16_t) },
    { FLD(PRIMITIVE, y), TID(int16_t) },
    { FLD(POINTER, features), &world_data::T_feature_map::T_features::_identity, 0, NULL },
    { FLD(POINTER, unk_8), identity_traits<int16_t >::get(), 1, NULL },
    { FLD(POINTER, unk_c), identity_traits<int32_t >::get(), 1, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_feature_map::_identity(sizeof(world_data::T_feature_map), &allocator_fn<world_data::T_feature_map>, &world_data::_identity, "T_feature_map",NULL,world_data_doT_Dot_T_feature_map_fields);
  #define CUR_STRUCT world_data::T_unk_274::T_unk_10
  static const struct_field_info world_data_doT_Dot_T_unk_274_doT_Dot_T_unk_10_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_unk_274::T_unk_10::_identity(sizeof(world_data::T_unk_274::T_unk_10), &allocator_fn<world_data::T_unk_274::T_unk_10>, &world_data::T_unk_274::_identity, "T_unk_10",NULL,world_data_doT_Dot_T_unk_274_doT_Dot_T_unk_10_fields);
  #define CUR_STRUCT world_data::T_unk_274
  static const struct_field_info world_data_doT_Dot_T_unk_274_fields[] = {
    { FLD(STL_VECTOR_PTR, unk_0), identity_traits<df::historical_figure >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_10), &world_data::T_unk_274::T_unk_10::_identity, 0, NULL },
    { FLD(POINTER, unk_20), identity_traits<df::historical_entity >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_24), TID(int32_t) },
    { FLD(POINTER, unk_28), identity_traits<df::language_name >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_2c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_30), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_unk_274::_identity(sizeof(world_data::T_unk_274), &allocator_fn<world_data::T_unk_274>, &world_data::_identity, "T_unk_274",NULL,world_data_doT_Dot_T_unk_274_fields);
  #define CUR_STRUCT world_data::T_unk_482f8
  static const struct_field_info world_data_doT_Dot_T_unk_482f8_fields[] = {
    { FLD(STATIC_ARRAY, anon_1), identity_traits<int32_t >::get(), 320000, NULL },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::T_unk_482f8::_identity(sizeof(world_data::T_unk_482f8), &allocator_fn<world_data::T_unk_482f8>, &world_data::_identity, "T_unk_482f8",NULL,world_data_doT_Dot_T_unk_482f8_fields);
  #define CUR_STRUCT world_data
  static const struct_field_info world_data_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(STATIC_ARRAY, unk1), identity_traits<int8_t >::get(), 15, NULL },
    { FLD(PRIMITIVE, next_site_id), TID(int32_t) },
    { FLD(PRIMITIVE, next_site_unk136_id), TID(int32_t) },
    { FLD(PRIMITIVE, next_unk_140_id), TID(int32_t) },
    { FLD(PRIMITIVE, next_unk_150_id), TID(int32_t) },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, world_width), TID(int32_t) },
    { FLD(PRIMITIVE, world_height), TID(int32_t) },
    { FLD(PRIMITIVE, unk_78), TID(int32_t) },
    { FLD(PRIMITIVE, moon_phase), TID(int32_t) },
    { FLD(PRIMITIVE, flip_latitude), TID(int16_t) },
    { FLD(PRIMITIVE, flip_longitude), TID(int16_t) },
    { FLD(PRIMITIVE, unk_84), TID(int16_t) },
    { FLD(PRIMITIVE, unk_86), TID(int16_t) },
    { FLD(PRIMITIVE, unk_88), TID(int16_t) },
    { FLD(PRIMITIVE, unk_8a), TID(int16_t) },
    { FLD(PRIMITIVE, anon_3), TID(int16_t) },
    { FLD(PRIMITIVE, anon_4), TID(int16_t) },
    { FLD(SUBSTRUCT, unk_b4), &world_data::T_unk_b4::_identity },
    { FLD(STL_VECTOR_PTR, region_details), identity_traits<df::world_region_details >::get(), 0, NULL },
    { FLD(PRIMITIVE, adv_region_x), TID(int32_t) },
    { FLD(PRIMITIVE, adv_region_y), TID(int32_t) },
    { FLD(PRIMITIVE, adv_emb_x), TID(int32_t) },
    { FLD(PRIMITIVE, adv_emb_y), TID(int32_t) },
    { FLD(PRIMITIVE, unk_x1), TID(int16_t) },
    { FLD(PRIMITIVE, unk_y1), TID(int16_t) },
    { FLD(PRIMITIVE, unk_x2), TID(int16_t) },
    { FLD(PRIMITIVE, unk_y2), TID(int16_t) },
    { FLD(SUBSTRUCT, constructions), &world_data::T_constructions::_identity },
    { FLD(SUBSTRUCT, entity_claims1), &entity_claim_mask::_identity },
    { FLD(SUBSTRUCT, entity_claims2), &entity_claim_mask::_identity },
    { FLD(STL_VECTOR_PTR, sites), identity_traits<df::world_site >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, site_unk130), identity_traits<df::world_site_unk130 >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, resource_allotments), identity_traits<df::resource_allotment_data >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_150), &world_data::T_unk_150::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_170), &world_data::T_unk_170::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, freakish_weather), &world_data::T_freakish_weather::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, object_data), identity_traits<df::world_object_data >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, landmasses), identity_traits<df::world_landmass >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, regions), identity_traits<df::world_region >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, underground_regions), identity_traits<df::world_underground_region >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, geo_biomes), identity_traits<df::world_geo_biome >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, mountain_peaks), &world_data::T_mountain_peaks::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, rivers), identity_traits<df::world_river >::get(), 0, NULL },
    { FLD(POINTER, region_map), identity_traits<df::region_map_entry* >::get(), 1, NULL },
    { FLD(POINTER, unk_1c4), NULL, 0, NULL },
    { FLD(CONTAINER, unk_1cc), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(POINTER, unk_1dc), identity_traits<std::vector<void* >* >::get(), 1, NULL },
    { FLD(POINTER, unk_1e0), identity_traits<std::vector<void* >* >::get(), 1, NULL },
    { FLD(POINTER, unk_1e4), identity_traits<std::vector<void* >* >::get(), 1, NULL },
    { FLD(POINTER, unk_1e8), identity_traits<std::vector<void* >* >::get(), 1, NULL },
    { FLD(POINTER, unk_1ec), identity_traits<std::vector<void* >* >::get(), 1, NULL },
    { FLD(POINTER, unk_1f0), identity_traits<std::vector<void* >* >::get(), 1, NULL },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD(PRIMITIVE, anon_9), TID(int32_t) },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { FLD(PRIMITIVE, anon_11), TID(int32_t) },
    { FLD(PRIMITIVE, anon_12), TID(int32_t) },
    { FLD(PRIMITIVE, anon_13), TID(int32_t) },
    { FLD(PRIMITIVE, anon_14), TID(int32_t) },
    { FLD(PRIMITIVE, anon_15), TID(int32_t) },
    { FLD(PRIMITIVE, anon_16), TID(int32_t) },
    { FLD(PRIMITIVE, anon_17), TID(int32_t) },
    { FLD(PRIMITIVE, anon_18), TID(int32_t) },
    { FLD(PRIMITIVE, anon_19), TID(int32_t) },
    { FLD(PRIMITIVE, anon_20), TID(int32_t) },
    { FLD(PRIMITIVE, anon_22), TID(int8_t) },
    { FLD(PRIMITIVE, anon_23), TID(int8_t) },
    { FLD(STL_VECTOR_PTR, active_site), identity_traits<df::world_site >::get(), 0, NULL },
    { FLD(POINTER, feature_map), identity_traits<df::world_data::T_feature_map* >::get(), 1, NULL },
    { FLD(CONTAINER, old_sites), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, old_site_x), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, old_site_y), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, land_rgns), &coord2d_path::_identity },
    { FLD(PRIMITIVE, unk_260), TID(int32_t) },
    { FLD(PRIMITIVE, unk_264), TID(int8_t) },
    { FLD(PRIMITIVE, unk_268), TID(int32_t) },
    { FLD(PRIMITIVE, unk_26c), TID(int8_t) },
    { FLD(PRIMITIVE, unk_270), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_274), &world_data::T_unk_274::_identity, 0, NULL },
    { FLD(SUBSTRUCT, unk_482f8), &world_data::T_unk_482f8::_identity },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_data::_identity(sizeof(world_data), &allocator_fn<world_data>, NULL, "world_data",NULL,world_data_fields);
  #define CUR_STRUCT world_geo_biome
  static const struct_field_info world_geo_biome_fields[] = {
    { FLD(PRIMITIVE, unk1), TID(int16_t) },
    { FLD(PRIMITIVE, index), TID(int16_t) },
    { FLD(STL_VECTOR_PTR, layers), identity_traits<df::world_geo_layer >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_geo_biome::_identity(sizeof(world_geo_biome), &allocator_fn<world_geo_biome>, NULL, "world_geo_biome",NULL,world_geo_biome_fields);
  #define CUR_STRUCT world_geo_layer
  static const struct_field_info world_geo_layer_fields[] = {
    { FLD(PRIMITIVE, type), TID(geo_layer_type) },
    { FLD(PRIMITIVE, mat_index), TID(int32_t) },
    { FLD(CONTAINER, vein_mat), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, vein_nested_in), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, vein_type), identity_traits<std::vector<enum_field<df::inclusion_type,int8_t> > >::get(), 0, NULL },
    { FLD(CONTAINER, vein_unk_38), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, top_height), TID(int16_t) },
    { FLD(PRIMITIVE, bottom_height), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_geo_layer::_identity(sizeof(world_geo_layer), &allocator_fn<world_geo_layer>, NULL, "world_geo_layer",NULL,world_geo_layer_fields);
  #define CUR_STRUCT world_history::T_event_collections
  static const struct_field_info world_history_doT_Dot_T_event_collections_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::history_event_collection >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, other), identity_traits<std::vector<df::history_event_collection* > >::get(), 9, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_history::T_event_collections::_identity(sizeof(world_history::T_event_collections), &allocator_fn<world_history::T_event_collections>, &world_history::_identity, "T_event_collections",NULL,world_history_doT_Dot_T_event_collections_fields);
  #define CUR_STRUCT world_history
  static const struct_field_info world_history_fields[] = {
    { FLD(STL_VECTOR_PTR, events), identity_traits<df::history_event >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, events2), identity_traits<df::history_event >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, figures), identity_traits<df::historical_figure >::get(), 0, NULL },
    { FLD(SUBSTRUCT, event_collections), &world_history::T_event_collections::_identity },
    { FLD(STL_VECTOR_PTR, eras), identity_traits<df::history_era >::get(), 0, NULL },
    { FLD(CONTAINER, unk1), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk2), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, total_powers), TID(int32_t) },
    { FLD(PRIMITIVE, total_megabeasts), TID(int32_t) },
    { FLD(PRIMITIVE, total_semimegabeasts), TID(int32_t) },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_6), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_7), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, unk_v40_1), identity_traits<std::vector<void* > >::get(), 12, NULL },
    { FLD(CONTAINER, anon_8), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_9), TID(bool) },
    { FLD(CONTAINER, anon_10), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_11), TID(int32_t) },
    { FLD(PRIMITIVE, anon_12), TID(int32_t) },
    { FLD(PRIMITIVE, anon_13), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_history::_identity(sizeof(world_history), &allocator_fn<world_history>, NULL, "world_history",NULL,world_history_fields);
  #define CUR_STRUCT world_landmass
  static const struct_field_info world_landmass_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(PRIMITIVE, area), TID(int32_t) },
    { FLD(PRIMITIVE, min_x), TID(int32_t) },
    { FLD(PRIMITIVE, max_x), TID(int32_t) },
    { FLD(PRIMITIVE, min_y), TID(int32_t) },
    { FLD(PRIMITIVE, max_y), TID(int32_t) },
    { FLD(CONTAINER, unk_74), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_84), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_landmass::_identity(sizeof(world_landmass), &allocator_fn<world_landmass>, NULL, "world_landmass",NULL,world_landmass_fields);
  #define CUR_STRUCT world_object_data::T_offloaded_items
  static const struct_field_info world_object_data_doT_Dot_T_offloaded_items_fields[] = {
    { FLD(POINTER, item), identity_traits<df::item >::get(), 0, NULL },
    { FLD(PRIMITIVE, global_x), TID(int32_t) },
    { FLD(PRIMITIVE, global_y), TID(int32_t) },
    { FLD(PRIMITIVE, global_z), TID(int32_t) },
    { FLD(PRIMITIVE, container), TID(int32_t) },
    { FLD(PRIMITIVE, building), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_object_data::T_offloaded_items::_identity(sizeof(world_object_data::T_offloaded_items), &allocator_fn<world_object_data::T_offloaded_items>, &world_object_data::_identity, "T_offloaded_items",NULL,world_object_data_doT_Dot_T_offloaded_items_fields);
  #define CUR_STRUCT world_object_data::T_offloaded_buildings
  static const struct_field_info world_object_data_doT_Dot_T_offloaded_buildings_fields[] = {
    { FLD(POINTER, building), identity_traits<df::building >::get(), 0, NULL },
    { FLD(PRIMITIVE, global_x), TID(int32_t) },
    { FLD(PRIMITIVE, global_y), TID(int32_t) },
    { FLD(PRIMITIVE, global_z), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_object_data::T_offloaded_buildings::_identity(sizeof(world_object_data::T_offloaded_buildings), &allocator_fn<world_object_data::T_offloaded_buildings>, &world_object_data::_identity, "T_offloaded_buildings",NULL,world_object_data_doT_Dot_T_offloaded_buildings_fields);
  #define CUR_STRUCT world_object_data::T_unk_94
  static const struct_field_info world_object_data_doT_Dot_T_unk_94_fields[] = {
    { FLD(PRIMITIVE, global_x), TID(int32_t) },
    { FLD(PRIMITIVE, global_y), TID(int32_t) },
    { FLD(PRIMITIVE, global_z), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_object_data::T_unk_94::_identity(sizeof(world_object_data::T_unk_94), &allocator_fn<world_object_data::T_unk_94>, &world_object_data::_identity, "T_unk_94",NULL,world_object_data_doT_Dot_T_unk_94_fields);
  #define CUR_STRUCT world_object_data
  static const struct_field_info world_object_data_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(CONTAINER, altered_items), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, offloaded_items), &world_object_data::T_offloaded_items::_identity, 0, NULL },
    { FLD(CONTAINER, unk_24), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_34), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_44), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_54), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_64), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, altered_buildings), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, offloaded_buildings), &world_object_data::T_offloaded_buildings::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_94), &world_object_data::T_unk_94::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, creation_zone_alterations), NULL, 0, NULL },
    { FLD(PRIMITIVE, unk_v40_1), TID(int32_t) },
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, year_tick), TID(int32_t) },
    { FLD(CONTAINER, unk_c0), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_d0), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_e0), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_f0), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_100), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_110), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_object_data::_identity(sizeof(world_object_data), &allocator_fn<world_object_data>, NULL, "world_object_data",NULL,world_object_data_fields);
  #define CUR_STRUCT world_population
  static const struct_field_info world_population_fields[] = {
    { FLD(PRIMITIVE, type), identity_traits<enum_field<df::world_population_type,int16_t> >::get() },
    { FLD(PRIMITIVE, race), TID(int16_t) },
    { FLD(PRIMITIVE, plant), TID(int16_t) },
    { FLD(PRIMITIVE, count_min), TID(int32_t) },
    { FLD(PRIMITIVE, count_max), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, owner), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_population::_identity(sizeof(world_population), &allocator_fn<world_population>, NULL, "world_population",NULL,world_population_fields);
  #define CUR_STRUCT world_population_ref
  static const struct_field_info world_population_ref_fields[] = {
    { FLD(PRIMITIVE, region_x), TID(int16_t) },
    { FLD(PRIMITIVE, region_y), TID(int16_t) },
    { FLD(PRIMITIVE, feature_idx), TID(int16_t) },
    { FLD(PRIMITIVE, cave_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_28), TID(int32_t) },
    { FLD(PRIMITIVE, population_idx), TID(int32_t) },
    { FLD(PRIMITIVE, depth), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_population_ref::_identity(sizeof(world_population_ref), &allocator_fn<world_population_ref>, NULL, "world_population_ref",NULL,world_population_ref_fields);
  #define CUR_STRUCT world_raws::T_plants
  static const struct_field_info world_raws_doT_Dot_T_plants_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::plant_raw >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bushes), identity_traits<df::plant_raw >::get(), 0, NULL },
    { FLD(CONTAINER, bushes_idx), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, trees), identity_traits<df::plant_raw >::get(), 0, NULL },
    { FLD(CONTAINER, trees_idx), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, grasses), identity_traits<df::plant_raw >::get(), 0, NULL },
    { FLD(CONTAINER, grasses_idx), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_raws::T_plants::_identity(sizeof(world_raws::T_plants), &allocator_fn<world_raws::T_plants>, &world_raws::_identity, "T_plants",NULL,world_raws_doT_Dot_T_plants_fields);
  #define CUR_STRUCT world_raws::T_bodyglosses
  static const struct_field_info world_raws_doT_Dot_T_bodyglosses_fields[] = {
    { FLD(PRIMITIVE, id), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, old_singular), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, new_singular), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, old_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, new_plural), identity_traits<std::string >::get() },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_raws::T_bodyglosses::_identity(sizeof(world_raws::T_bodyglosses), &allocator_fn<world_raws::T_bodyglosses>, &world_raws::_identity, "T_bodyglosses",NULL,world_raws_doT_Dot_T_bodyglosses_fields);
  #define CUR_STRUCT world_raws::T_creatures
  static const struct_field_info world_raws_doT_Dot_T_creatures_fields[] = {
    { FLD(STL_VECTOR_PTR, alphabetic), identity_traits<df::creature_raw >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::creature_raw >::get(), 0, NULL },
    { FLD(PRIMITIVE, num_caste), TID(int32_t) },
    { FLD(CONTAINER, list_creature), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, list_caste), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, action_strings), identity_traits<std::string >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_raws::T_creatures::_identity(sizeof(world_raws::T_creatures), &allocator_fn<world_raws::T_creatures>, &world_raws::_identity, "T_creatures",NULL,world_raws_doT_Dot_T_creatures_fields);
  #define CUR_STRUCT world_raws::T_itemdefs
  static const struct_field_info world_raws_doT_Dot_T_itemdefs_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::itemdef >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, weapons), identity_traits<df::itemdef_weaponst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, trapcomps), identity_traits<df::itemdef_trapcompst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, toys), identity_traits<df::itemdef_toyst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, tools), identity_traits<df::itemdef_toolst >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, tools_by_type), identity_traits<std::vector<df::itemdef_toolst* > >::get(), 18, TID(tool_uses) },
    { FLD(STL_VECTOR_PTR, instruments), identity_traits<df::itemdef_instrumentst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, armor), identity_traits<df::itemdef_armorst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, ammo), identity_traits<df::itemdef_ammost >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, siege_ammo), identity_traits<df::itemdef_siegeammost >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, gloves), identity_traits<df::itemdef_glovesst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, shoes), identity_traits<df::itemdef_shoesst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, shields), identity_traits<df::itemdef_shieldst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, helms), identity_traits<df::itemdef_helmst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, pants), identity_traits<df::itemdef_pantsst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, food), identity_traits<df::itemdef_foodst >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_raws::T_itemdefs::_identity(sizeof(world_raws::T_itemdefs), &allocator_fn<world_raws::T_itemdefs>, &world_raws::_identity, "T_itemdefs",NULL,world_raws_doT_Dot_T_itemdefs_fields);
  typedef df::language_word_table T_world_raws_doT_Dot_T_language_fields[60];
  #define CUR_STRUCT world_raws::T_language
  static const struct_field_info world_raws_doT_Dot_T_language_fields[] = {
    { FLD(STL_VECTOR_PTR, words), identity_traits<df::language_word >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, symbols), identity_traits<df::language_symbol >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, translations), identity_traits<df::language_translation >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, word_table), identity_traits<T_world_raws_doT_Dot_T_language_fields >::get(), 2, NULL },
    { FLD(STL_VECTOR_PTR, colors), identity_traits<df::descriptor_color >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, shapes), identity_traits<df::descriptor_shape >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, patterns), identity_traits<df::descriptor_pattern >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_raws::T_language::_identity(sizeof(world_raws::T_language), &allocator_fn<world_raws::T_language>, &world_raws::_identity, "T_language",NULL,world_raws_doT_Dot_T_language_fields);
  #define CUR_STRUCT world_raws::T_buildings
  static const struct_field_info world_raws_doT_Dot_T_buildings_fields[] = {
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::building_def >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, workshops), identity_traits<df::building_def_workshopst >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, furnaces), identity_traits<df::building_def_furnacest >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_raws::T_buildings::_identity(sizeof(world_raws::T_buildings), &allocator_fn<world_raws::T_buildings>, &world_raws::_identity, "T_buildings",NULL,world_raws_doT_Dot_T_buildings_fields);
  #define CUR_STRUCT world_raws::T_syndromes
  static const struct_field_info world_raws_doT_Dot_T_syndromes_fields[] = {
    { FLD(CONTAINER, mat_types), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mat_indexes), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, interactions), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::syndrome >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_raws::T_syndromes::_identity(sizeof(world_raws::T_syndromes), &allocator_fn<world_raws::T_syndromes>, &world_raws::_identity, "T_syndromes",NULL,world_raws_doT_Dot_T_syndromes_fields);
  #define CUR_STRUCT world_raws::T_effects
  static const struct_field_info world_raws_doT_Dot_T_effects_fields[] = {
    { FLD(CONTAINER, mat_types), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, mat_indexes), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, interactions), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, all), identity_traits<df::creature_interaction_effect >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_raws::T_effects::_identity(sizeof(world_raws::T_effects), &allocator_fn<world_raws::T_effects>, &world_raws::_identity, "T_effects",NULL,world_raws_doT_Dot_T_effects_fields);
  #define CUR_STRUCT world_raws
  static const struct_field_info world_raws_fields[] = {
    { FLD(STL_VECTOR_PTR, material_templates), identity_traits<df::material_template >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, inorganics), identity_traits<df::inorganic_raw >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, inorganics_subset), identity_traits<df::inorganic_raw >::get(), 0, NULL },
    { FLD(SUBSTRUCT, plants), &world_raws::T_plants::_identity },
    { FLD(STL_VECTOR_PTR, tissue_templates), identity_traits<df::tissue_template >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, body_detail_plans), identity_traits<df::body_detail_plan >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, body_templates), identity_traits<df::body_template >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, bodyglosses), &world_raws::T_bodyglosses::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, creature_variations), identity_traits<df::creature_variation >::get(), 0, NULL },
    { FLD(SUBSTRUCT, creatures), &world_raws::T_creatures::_identity },
    { FLD(SUBSTRUCT, itemdefs), &world_raws::T_itemdefs::_identity },
    { FLD(STL_VECTOR_PTR, entities), identity_traits<df::entity_raw >::get(), 0, NULL },
    { FLD(SUBSTRUCT, language), &world_raws::T_language::_identity },
    { FLD(STL_VECTOR_PTR, reactions), identity_traits<df::reaction >::get(), 0, NULL },
    { FLD(SUBSTRUCT, buildings), &world_raws::T_buildings::_identity },
    { FLD(STL_VECTOR_PTR, interactions), identity_traits<df::interaction >::get(), 0, NULL },
    { FLD(SUBSTRUCT, mat_table), &special_mat_table::_identity },
    { FLD(SUBSTRUCT, syndromes), &world_raws::T_syndromes::_identity },
    { FLD(SUBSTRUCT, effects), &world_raws::T_effects::_identity },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_raws::_identity(sizeof(world_raws), &allocator_fn<world_raws>, NULL, "world_raws",NULL,world_raws_fields);
  #define CUR_STRUCT world_region
  static const struct_field_info world_region_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(PRIMITIVE, type), TID(world_region_type) },
    { FLD(SUBSTRUCT, region_coords), &coord2d_path::_identity },
    { FLD(PRIMITIVE, unk_94), TID(int32_t) },
    { FLD(PRIMITIVE, unk_98), TID(int32_t) },
    { FLD(PRIMITIVE, unk_9c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_a0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_a4), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, population), identity_traits<df::world_population >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, unk_118), identity_traits<int32_t >::get(), 51, NULL },
    { FLD(CONTAINER, unk_184), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_194), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_1a4), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_1b4), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_1c4), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_1d4), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_1e4), TID(int16_t) },
    { FLD(PRIMITIVE, unk_1e6), TID(int16_t) },
    { FLD(PRIMITIVE, unk_1e8), TID(int16_t) },
    { FLD(PRIMITIVE, lake_surface), TID(int16_t) },
    { FLD(CONTAINER, unk_1f0), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, mid_x), TID(int32_t) },
    { FLD(PRIMITIVE, mid_y), TID(int32_t) },
    { FLD(PRIMITIVE, min_x), TID(int32_t) },
    { FLD(PRIMITIVE, max_x), TID(int32_t) },
    { FLD(PRIMITIVE, min_y), TID(int32_t) },
    { FLD(PRIMITIVE, max_y), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_region::_identity(sizeof(world_region), &allocator_fn<world_region>, NULL, "world_region",NULL,world_region_fields);
  typedef df::coord2d T_world_region_details_doT_Dot_T_edges_fields[17];
  typedef df::coord2d T_world_region_details_doT_Dot_T_edges_fields_1[16];
  typedef int8_t T_world_region_details_doT_Dot_T_edges_fields_2[16];
  typedef int8_t T_world_region_details_doT_Dot_T_edges_fields_3[16];
  typedef int8_t T_world_region_details_doT_Dot_T_edges_fields_4[16];
  #define CUR_STRUCT world_region_details::T_edges
  static const struct_field_info world_region_details_doT_Dot_T_edges_fields[] = {
    { FLD(STATIC_ARRAY, split_x), identity_traits<T_world_region_details_doT_Dot_T_edges_fields >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, split_y), identity_traits<T_world_region_details_doT_Dot_T_edges_fields_1 >::get(), 17, NULL },
    { FLD(STATIC_ARRAY, biome_corner), identity_traits<T_world_region_details_doT_Dot_T_edges_fields_2 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, biome_x), identity_traits<T_world_region_details_doT_Dot_T_edges_fields_3 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, biome_y), identity_traits<T_world_region_details_doT_Dot_T_edges_fields_4 >::get(), 16, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_region_details::T_edges::_identity(sizeof(world_region_details::T_edges), &allocator_fn<world_region_details::T_edges>, &world_region_details::_identity, "T_edges",NULL,world_region_details_doT_Dot_T_edges_fields);
  typedef int16_t T_world_region_details_doT_Dot_T_rivers_vertical_fields[17];
  typedef int16_t T_world_region_details_doT_Dot_T_rivers_vertical_fields_1[17];
  typedef int8_t T_world_region_details_doT_Dot_T_rivers_vertical_fields_2[17];
  typedef int16_t T_world_region_details_doT_Dot_T_rivers_vertical_fields_3[17];
  #define CUR_STRUCT world_region_details::T_rivers_vertical
  static const struct_field_info world_region_details_doT_Dot_T_rivers_vertical_fields[] = {
    { FLD(STATIC_ARRAY, x_min), identity_traits<T_world_region_details_doT_Dot_T_rivers_vertical_fields >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, x_max), identity_traits<T_world_region_details_doT_Dot_T_rivers_vertical_fields_1 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, active), identity_traits<T_world_region_details_doT_Dot_T_rivers_vertical_fields_2 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, elevation), identity_traits<T_world_region_details_doT_Dot_T_rivers_vertical_fields_3 >::get(), 16, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_region_details::T_rivers_vertical::_identity(sizeof(world_region_details::T_rivers_vertical), &allocator_fn<world_region_details::T_rivers_vertical>, &world_region_details::_identity, "T_rivers_vertical",NULL,world_region_details_doT_Dot_T_rivers_vertical_fields);
  typedef int16_t T_world_region_details_doT_Dot_T_rivers_horizontal_fields[16];
  typedef int16_t T_world_region_details_doT_Dot_T_rivers_horizontal_fields_1[16];
  typedef int8_t T_world_region_details_doT_Dot_T_rivers_horizontal_fields_2[16];
  typedef int16_t T_world_region_details_doT_Dot_T_rivers_horizontal_fields_3[16];
  #define CUR_STRUCT world_region_details::T_rivers_horizontal
  static const struct_field_info world_region_details_doT_Dot_T_rivers_horizontal_fields[] = {
    { FLD(STATIC_ARRAY, y_min), identity_traits<T_world_region_details_doT_Dot_T_rivers_horizontal_fields >::get(), 17, NULL },
    { FLD(STATIC_ARRAY, y_max), identity_traits<T_world_region_details_doT_Dot_T_rivers_horizontal_fields_1 >::get(), 17, NULL },
    { FLD(STATIC_ARRAY, active), identity_traits<T_world_region_details_doT_Dot_T_rivers_horizontal_fields_2 >::get(), 17, NULL },
    { FLD(STATIC_ARRAY, elevation), identity_traits<T_world_region_details_doT_Dot_T_rivers_horizontal_fields_3 >::get(), 17, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_region_details::T_rivers_horizontal::_identity(sizeof(world_region_details::T_rivers_horizontal), &allocator_fn<world_region_details::T_rivers_horizontal>, &world_region_details::_identity, "T_rivers_horizontal",NULL,world_region_details_doT_Dot_T_rivers_horizontal_fields);
  typedef int8_t T_world_region_details_fields[17];
  typedef int16_t T_world_region_details_fields_1[17];
  typedef uint32_t T_world_region_details_fields_2[16];
  typedef int8_t T_world_region_details_fields_3[16];
  typedef std::vector<df::world_region_feature* > T_world_region_details_fields_4[16];
  typedef int16_t T_world_region_details_fields_5[16];
  #define CUR_STRUCT world_region_details
  static const struct_field_info world_region_details_fields[] = {
    { FLD(STATIC_ARRAY, biome), identity_traits<T_world_region_details_fields >::get(), 17, NULL },
    { FLD(STATIC_ARRAY, elevation), identity_traits<T_world_region_details_fields_1 >::get(), 17, NULL },
    { FLD(STATIC_ARRAY, seed), identity_traits<T_world_region_details_fields_2 >::get(), 16, NULL },
    { FLD(SUBSTRUCT, edges), &world_region_details::T_edges::_identity },
    { FLD(SUBSTRUCT, pos), &coord2d::_identity },
    { FLD(PRIMITIVE, unk12e8), TID(int16_t) },
    { FLD(PRIMITIVE, anon_1), TID(int16_t) },
    { FLD(PRIMITIVE, anon_2), TID(int16_t) },
    { FLD(PRIMITIVE, anon_3), TID(int16_t) },
    { FLD(PRIMITIVE, anon_4), TID(int16_t) },
    { FLD(SUBSTRUCT, rivers_vertical), &world_region_details::T_rivers_vertical::_identity },
    { FLD(SUBSTRUCT, rivers_horizontal), &world_region_details::T_rivers_horizontal::_identity },
    { FLD(STATIC_ARRAY, unk11), identity_traits<T_world_region_details_fields_3 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, features), identity_traits<T_world_region_details_fields_4 >::get(), 16, NULL },
    { FLD(PRIMITIVE, lava_stone), TID(int16_t) },
    { FLD(STATIC_ARRAY, unk_12), identity_traits<int16_t >::get(), 1152, NULL },
    { FLD(STATIC_ARRAY, elevation2), identity_traits<T_world_region_details_fields_5 >::get(), 16, NULL },
    { FLD(STATIC_ARRAY, undef13), identity_traits<int32_t >::get(), 256, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_region_details::_identity(sizeof(world_region_details), &allocator_fn<world_region_details>, NULL, "world_region_details",NULL,world_region_details_fields);
  #define CUR_STRUCT world_region_feature
  static const struct_field_info world_region_feature_fields[] = {
    { FLD(PRIMITIVE, feature_idx), TID(int16_t) },
    { FLD(PRIMITIVE, layer), TID(int32_t) },
    { FLD(PRIMITIVE, region_tile_idx), TID(int32_t) },
    { FLD(PRIMITIVE, min_z), TID(int16_t) },
    { FLD(PRIMITIVE, max_z), TID(int16_t) },
    { FLD(STATIC_ARRAY, unk_c), identity_traits<df::coord2d >::get(), 6, NULL },
    { FLD(PRIMITIVE, unk_28), TID(int32_t) },
    { FLD(PRIMITIVE, seed), TID(uint32_t) },
    { FLD(CONTAINER, unk_30), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD(STATIC_ARRAY, unk_38), identity_traits<int16_t >::get(), 15, NULL },
    { FLD(PRIMITIVE, top_layer_idx), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_region_feature::_identity(sizeof(world_region_feature), &allocator_fn<world_region_feature>, NULL, "world_region_feature",NULL,world_region_feature_fields);
  #define CUR_STRUCT world_river
  static const struct_field_info world_river_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(SUBSTRUCT, path), &coord2d_path::_identity },
    { FLD(CONTAINER, unk_8c), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_9c), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, elevation), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(SUBSTRUCT, end_pos), &coord2d::_identity },
    { FLD(CONTAINER, flags), identity_traits<BitArray<int> >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_river::_identity(sizeof(world_river), &allocator_fn<world_river>, NULL, "world_river",NULL,world_river_fields);
  #define CUR_STRUCT world_site::T_units
  static const struct_field_info world_site_doT_Dot_T_units_fields[] = {
    { FLD(PRIMITIVE, unit_id), TID(int32_t) },
    { FLD(PRIMITIVE, pos_x), TID(int32_t) },
    { FLD(PRIMITIVE, pos_y), TID(int32_t) },
    { FLD(PRIMITIVE, pos_z), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site::T_units::_identity(sizeof(world_site::T_units), &allocator_fn<world_site::T_units>, &world_site::_identity, "T_units",NULL,world_site_doT_Dot_T_units_fields);
  #define CUR_STRUCT world_site::T_unk_13c
  static const struct_field_info world_site_doT_Dot_T_unk_13c_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(CONTAINER, unk_10), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_20), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_30), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site::T_unk_13c::_identity(sizeof(world_site::T_unk_13c), &allocator_fn<world_site::T_unk_13c>, &world_site::_identity, "T_unk_13c",NULL,world_site_doT_Dot_T_unk_13c_fields);
  #define CUR_STRUCT world_site::T_unk_v40_2
  static const struct_field_info world_site_doT_Dot_T_unk_v40_2_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(CONTAINER, unk_10), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_20), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_30), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site::T_unk_v40_2::_identity(sizeof(world_site::T_unk_v40_2), &allocator_fn<world_site::T_unk_v40_2>, &world_site::_identity, "T_unk_v40_2",NULL,world_site_doT_Dot_T_unk_v40_2_fields);
  #define CUR_STRUCT world_site::T_subtype_info
  static const struct_field_info world_site_doT_Dot_T_subtype_info_fields[] = {
    { FLD(PRIMITIVE, is_tower), TID(int16_t) },
    { FLD(PRIMITIVE, is_monument), TID(int16_t) },
    { FLD(PRIMITIVE, lair_type), TID(int16_t) },
    { FLD(CONTAINER, unk_8), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD(PRIMITIVE, creator), TID(int32_t) },
    { FLD(PRIMITIVE, unk_28), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site::T_subtype_info::_identity(sizeof(world_site::T_subtype_info), &allocator_fn<world_site::T_subtype_info>, &world_site::_identity, "T_subtype_info",NULL,world_site_doT_Dot_T_subtype_info_fields);
  #define CUR_STRUCT world_site::T_unk_21c
  static const struct_field_info world_site_doT_Dot_T_unk_21c_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site::T_unk_21c::_identity(sizeof(world_site::T_unk_21c), &allocator_fn<world_site::T_unk_21c>, &world_site::_identity, "T_unk_21c",NULL,world_site_doT_Dot_T_unk_21c_fields);
  #define CUR_STRUCT world_site::T_unk_v40_4a
  static const struct_field_info world_site_doT_Dot_T_unk_v40_4a_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, entity_id), TID(int32_t) },
    { FLD(PRIMITIVE, year), TID(int32_t) },
    { FLD(PRIMITIVE, year_tick), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site::T_unk_v40_4a::_identity(sizeof(world_site::T_unk_v40_4a), &allocator_fn<world_site::T_unk_v40_4a>, &world_site::_identity, "T_unk_v40_4a",NULL,world_site_doT_Dot_T_unk_v40_4a_fields);
  #define CUR_STRUCT world_site
  static const struct_field_info world_site_fields[] = {
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, civ_id), TID(int32_t) },
    { FLD(PRIMITIVE, cur_owner_id), TID(int32_t) },
    { FLD(PRIMITIVE, type), TID(world_site_type) },
    { FLD(SUBSTRUCT, pos), &coord2d::_identity },
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(CONTAINER, nemesis), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, artifacts), identity_traits<df::artifact_record >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, animals), identity_traits<df::world_population >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, inhabitants), identity_traits<df::world_site_inhabitant >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, units), &world_site::T_units::_identity, 0, NULL },
    { FLD(CONTAINER, unk_d4), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_1a), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_1b), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_1c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_1d), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_1e), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_1f), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_1g), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_1h), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(PRIMITIVE, rgn_min_x), TID(int16_t) },
    { FLD(PRIMITIVE, rgn_max_x), TID(int16_t) },
    { FLD(PRIMITIVE, rgn_min_y), TID(int16_t) },
    { FLD(PRIMITIVE, rgn_max_y), TID(int16_t) },
    { FLD(PRIMITIVE, rgn_min_z), TID(int16_t) },
    { FLD(PRIMITIVE, rgn_max_z), TID(int16_t) },
    { FLD(PRIMITIVE, global_min_x), TID(int32_t) },
    { FLD(PRIMITIVE, global_min_y), TID(int32_t) },
    { FLD(PRIMITIVE, global_max_x), TID(int32_t) },
    { FLD(PRIMITIVE, global_max_y), TID(int32_t) },
    { FLD(PRIMITIVE, seed1), TID(uint32_t) },
    { FLD(PRIMITIVE, seed2), TID(uint32_t) },
    { FLD(PRIMITIVE, resident_count), TID(int32_t) },
    { FLD(PRIMITIVE, unk_110), TID(int32_t) },
    { FLD(PRIMITIVE, unk_114), TID(int32_t) },
    { FLD(PRIMITIVE, unk_118), TID(int32_t) },
    { FLD(PRIMITIVE, unk_11c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_120), TID(int32_t) },
    { FLD(PRIMITIVE, unk_124), TID(int32_t) },
    { FLD(PRIMITIVE, unk_128), TID(int32_t) },
    { FLD(PRIMITIVE, unk_12c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_130), TID(int32_t) },
    { FLD(PRIMITIVE, unk_134), TID(int32_t) },
    { FLD(PRIMITIVE, unk_138), TID(int32_t) },
    { FLD(PRIMITIVE, site_level), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_13c), &world_site::T_unk_13c::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_v40_2), &world_site::T_unk_v40_2::_identity, 0, NULL },
    { FLD(CONTAINER, flags), identity_traits<BitArray<df::world_site_flags> >::get(), 0, TID(world_site_flags) },
    { FLD(STL_VECTOR_PTR, buildings), identity_traits<df::abstract_building >::get(), 0, NULL },
    { FLD(PRIMITIVE, next_building_id), TID(int32_t) },
    { FLD(PRIMITIVE, created_tick), TID(int32_t) },
    { FLD(PRIMITIVE, created_year), TID(int32_t) },
    { FLD(PRIMITIVE, unk_170), TID(int32_t) },
    { FLD(PRIMITIVE, unk_174), TID(int32_t) },
    { FLD(SUBSTRUCT, unk_178), &coord::_identity },
    { FLD(POINTER, realization), identity_traits<df::world_site_realization >::get(), 0, NULL },
    { FLD(POINTER, subtype_info), &world_site::T_subtype_info::_identity, 0, NULL },
    { FLD(STL_VECTOR_PTR, unk_21c), &world_site::T_unk_21c::_identity, 0, NULL },
    { FLD(CONTAINER, unk_22c), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_v40_3a), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_3b), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_v40_4a), &world_site::T_unk_v40_4a::_identity, 0, NULL },
    { FLD(CONTAINER, unk_v40_4b), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_4c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_v40_4d), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_v40_5), TID(int32_t) },
    { FLD(POINTER, unk_188), identity_traits<df::world_site_unk130 >::get(), 0, NULL },
    { FLD(CONTAINER, unk_18c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_19c), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, entity_links), identity_traits<df::entity_site_link >::get(), 0, NULL },
    { FLD(STL_VECTOR_PTR, cultural_identities), identity_traits<df::cultural_identity >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site::_identity(sizeof(world_site), &allocator_fn<world_site>, NULL, "world_site",NULL,world_site_fields);
  #define CUR_STRUCT world_site_inhabitant
  static const struct_field_info world_site_inhabitant_fields[] = {
    { FLD(PRIMITIVE, count), TID(int32_t) },
    { FLD(PRIMITIVE, race), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, outcast_id), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_20), TID(int32_t) },
    { FLD(PRIMITIVE, unk_24), TID(int32_t) },
    { FLD(PRIMITIVE, unk_28), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site_inhabitant::_identity(sizeof(world_site_inhabitant), &allocator_fn<world_site_inhabitant>, NULL, "world_site_inhabitant",NULL,world_site_inhabitant_fields);
  #define CUR_STRUCT world_site_realization::T_unk_55e8::T_unk_v40_2
  static const struct_field_info world_site_realization_doT_Dot_T_unk_55e8_doT_Dot_T_unk_v40_2_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int16_t) },
    { FLD(PRIMITIVE, unk_a), TID(int16_t) },
    { FLD(PRIMITIVE, unk_c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_10), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int16_t) },
    { FLD(PRIMITIVE, unk_16), TID(int16_t) },
    { FLD(PRIMITIVE, unk_18), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site_realization::T_unk_55e8::T_unk_v40_2::_identity(sizeof(world_site_realization::T_unk_55e8::T_unk_v40_2), &allocator_fn<world_site_realization::T_unk_55e8::T_unk_v40_2>, &world_site_realization::T_unk_55e8::_identity, "T_unk_v40_2",NULL,world_site_realization_doT_Dot_T_unk_55e8_doT_Dot_T_unk_v40_2_fields);
  #define CUR_STRUCT world_site_realization::T_unk_55e8
  static const struct_field_info world_site_realization_doT_Dot_T_unk_55e8_fields[] = {
    { FLD(PRIMITIVE, unk_55e8), TID(int32_t) },
    { FLD(PRIMITIVE, unk_55ec), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1a), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1b), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_1d), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, unk_v40_2), &world_site_realization::T_unk_55e8::T_unk_v40_2::_identity, 0, NULL },
    { FLD(PRIMITIVE, unk_55f0), TID(int32_t) },
    { FLD(PRIMITIVE, unk_55f4), TID(int32_t) },
    { FLD(PRIMITIVE, unk_55f8), TID(int16_t) },
    { FLD(PRIMITIVE, unk_55fa), TID(int16_t) },
    { FLD(PRIMITIVE, unk_55fc), TID(int32_t) },
    { FLD(PRIMITIVE, unk_5600), TID(int32_t) },
    { FLD(PRIMITIVE, unk_5604), TID(int32_t) },
    { FLD(PRIMITIVE, unk_5608), TID(int32_t) },
    { FLD(PRIMITIVE, unk_560c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_5610), TID(int32_t) },
    { FLD(PRIMITIVE, unk_5614), TID(int32_t) },
    { FLD(CONTAINER, unk_5618), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk_5628), TID(int32_t) },
    { FLD(PRIMITIVE, unk_562c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_5630), TID(int32_t) },
    { FLD(PRIMITIVE, unk_5634), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_3a), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_3b), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_3c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_v40_3d), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site_realization::T_unk_55e8::_identity(sizeof(world_site_realization::T_unk_55e8), &allocator_fn<world_site_realization::T_unk_55e8>, &world_site_realization::_identity, "T_unk_55e8",NULL,world_site_realization_doT_Dot_T_unk_55e8_fields);
  #define CUR_STRUCT world_site_realization::T_building_map
  static const struct_field_info world_site_realization_doT_Dot_T_building_map_fields[] = {
    { FLD(STL_VECTOR_PTR, buildings), identity_traits<df::site_realization_building >::get(), 0, NULL },
    { FLD(PRIMITIVE, unk4), TID(int32_t) },
    { FLD(PRIMITIVE, unk5), TID(uint32_t) },
    { FLD(CONTAINER, unk6), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site_realization::T_building_map::_identity(sizeof(world_site_realization::T_building_map), &allocator_fn<world_site_realization::T_building_map>, &world_site_realization::_identity, "T_building_map",NULL,world_site_realization_doT_Dot_T_building_map_fields);
  #define CUR_STRUCT world_site_realization::T_areas
  static const struct_field_info world_site_realization_doT_Dot_T_areas_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(PRIMITIVE, min_x), TID(int32_t) },
    { FLD(PRIMITIVE, max_x), TID(int32_t) },
    { FLD(PRIMITIVE, min_y), TID(int32_t) },
    { FLD(PRIMITIVE, max_y), TID(int32_t) },
    { FLD(PRIMITIVE, unk_1c), TID(int32_t) },
    { FLD(PRIMITIVE, unk_20), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site_realization::T_areas::_identity(sizeof(world_site_realization::T_areas), &allocator_fn<world_site_realization::T_areas>, &world_site_realization::_identity, "T_areas",NULL,world_site_realization_doT_Dot_T_areas_fields);
  #define CUR_STRUCT world_site_realization::T_unk_193bc::T_unk_8
  static const struct_field_info world_site_realization_doT_Dot_T_unk_193bc_doT_Dot_T_unk_8_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD(PRIMITIVE, anon_9), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site_realization::T_unk_193bc::T_unk_8::_identity(sizeof(world_site_realization::T_unk_193bc::T_unk_8), &allocator_fn<world_site_realization::T_unk_193bc::T_unk_8>, &world_site_realization::T_unk_193bc::_identity, "T_unk_8",NULL,world_site_realization_doT_Dot_T_unk_193bc_doT_Dot_T_unk_8_fields);
  #define CUR_STRUCT world_site_realization::T_unk_193bc
  static const struct_field_info world_site_realization_doT_Dot_T_unk_193bc_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(SUBSTRUCT, unk_8), &world_site_realization::T_unk_193bc::T_unk_8::_identity },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int16_t) },
    { FLD(PRIMITIVE, anon_5), TID(int16_t) },
    { FLD(PRIMITIVE, anon_6), TID(int16_t) },
    { FLD(PRIMITIVE, anon_7), TID(int16_t) },
    { FLD(PRIMITIVE, anon_8), TID(int16_t) },
    { FLD(PRIMITIVE, anon_9), TID(int16_t) },
    { FLD(PRIMITIVE, anon_10), TID(int32_t) },
    { FLD(PRIMITIVE, anon_11), TID(int32_t) },
    { FLD(PRIMITIVE, anon_12), TID(int32_t) },
    { FLD(STATIC_ARRAY, anon_13), identity_traits<int32_t >::get(), 20, NULL },
    { FLD(STATIC_ARRAY, anon_14), identity_traits<int32_t >::get(), 20, NULL },
    { FLD(PRIMITIVE, anon_15), TID(int16_t) },
    { FLD(PRIMITIVE, anon_16), TID(int16_t) },
    { FLD(PRIMITIVE, anon_17), TID(int32_t) },
    { FLD(PRIMITIVE, anon_18), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site_realization::T_unk_193bc::_identity(sizeof(world_site_realization::T_unk_193bc), &allocator_fn<world_site_realization::T_unk_193bc>, &world_site_realization::_identity, "T_unk_193bc",NULL,world_site_realization_doT_Dot_T_unk_193bc_fields);
  typedef int8_t T_world_site_realization_fields[17];
  typedef uint8_t T_world_site_realization_fields_1[17];
  typedef int16_t T_world_site_realization_fields_2[17];
  typedef df::site_realization_crossroads* T_world_site_realization_fields_3[51];
  typedef void* T_world_site_realization_fields_4[51];
  typedef df::world_site_realization::T_unk_55e8 T_world_site_realization_fields_5[17];
  typedef df::world_site_realization::T_building_map T_world_site_realization_fields_6[17];
  typedef uint32_t T_world_site_realization_fields_7[51];
  typedef uint8_t T_world_site_realization_fields_8[51];
  typedef int16_t T_world_site_realization_fields_9[51];
  typedef int8_t T_world_site_realization_fields_10[51];
  typedef int32_t T_world_site_realization_fields_11[52];
  #define CUR_STRUCT world_site_realization
  static const struct_field_info world_site_realization_fields[] = {
    { FLD(STL_VECTOR_PTR, buildings), identity_traits<df::site_realization_building >::get(), 0, NULL },
    { FLD(PRIMITIVE, num_buildings), TID(int32_t) },
    { FLD(PRIMITIVE, unk_14), TID(int32_t) },
    { FLD(PRIMITIVE, num_areas), TID(int32_t) },
    { FLD(STATIC_ARRAY, mini_rivers), identity_traits<T_world_site_realization_fields >::get(), 17, NULL },
    { FLD(STATIC_ARRAY, mini_tiles), identity_traits<T_world_site_realization_fields_1 >::get(), 17, NULL },
    { FLD(STATIC_ARRAY, mini_colors), identity_traits<T_world_site_realization_fields_2 >::get(), 17, NULL },
    { FLD(STATIC_ARRAY, road_map), identity_traits<T_world_site_realization_fields_3 >::get(), 51, NULL },
    { FLD(STATIC_ARRAY, unk_2d44), identity_traits<T_world_site_realization_fields_4 >::get(), 51, NULL },
    { FLD(STATIC_ARRAY, unk_55e8), identity_traits<T_world_site_realization_fields_5 >::get(), 17, NULL },
    { FLD(STATIC_ARRAY, building_map), identity_traits<T_world_site_realization_fields_6 >::get(), 17, NULL },
    { FLD(STATIC_ARRAY, unk_v40_1), identity_traits<T_world_site_realization_fields_7 >::get(), 51, NULL },
    { FLD(STATIC_ARRAY, zoom_tiles), identity_traits<T_world_site_realization_fields_8 >::get(), 51, NULL },
    { FLD(STATIC_ARRAY, zoom_colors), identity_traits<T_world_site_realization_fields_9 >::get(), 51, NULL },
    { FLD(STATIC_ARRAY, zoom_movemask), identity_traits<T_world_site_realization_fields_10 >::get(), 51, NULL },
    { FLD(STATIC_ARRAY, area_map), identity_traits<T_world_site_realization_fields_11 >::get(), 52, NULL },
    { FLD(STL_VECTOR_PTR, areas), &world_site_realization::T_areas::_identity, 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(STATIC_ARRAY, unk_193bc), &world_site_realization::T_unk_193bc::_identity, 500, NULL },
    { FLD(PRIMITIVE, num_unk_193bc), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(STATIC_ARRAY, building_type13), identity_traits<df::site_realization_building* >::get(), 20, NULL },
    { FLD(PRIMITIVE, num_building_type13), TID(int32_t) },
    { FLD(STATIC_ARRAY, building_type5), identity_traits<df::site_realization_building* >::get(), 20, NULL },
    { FLD(PRIMITIVE, num_building_type5), TID(int32_t) },
    { FLD(STATIC_ARRAY, building_shop_house), identity_traits<df::site_realization_building* >::get(), 20, NULL },
    { FLD(PRIMITIVE, num_building_shop_house), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(PRIMITIVE, anon_7), TID(int32_t) },
    { FLD(PRIMITIVE, anon_8), TID(int32_t) },
    { FLD(PRIMITIVE, anon_9), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site_realization::_identity(sizeof(world_site_realization), &allocator_fn<world_site_realization>, NULL, "world_site_realization",NULL,world_site_realization_fields);
  #define CUR_STRUCT world_site_unk130::T_unk_4
  static const struct_field_info world_site_unk130_doT_Dot_T_unk_4_fields[] = {
    { FLD(PRIMITIVE, unk_0), TID(int32_t) },
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(PRIMITIVE, unk_8), TID(int32_t) },
    { FLD(CONTAINER, unk_c), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site_unk130::T_unk_4::_identity(sizeof(world_site_unk130::T_unk_4), &allocator_fn<world_site_unk130::T_unk_4>, &world_site_unk130::_identity, "T_unk_4",NULL,world_site_unk130_doT_Dot_T_unk_4_fields);
  #define CUR_STRUCT world_site_unk130
  static const struct_field_info world_site_unk130_fields[] = {
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(STATIC_ARRAY, unk_4), identity_traits<std::vector<df::world_site_unk130::T_unk_4* > >::get(), 4, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_site_unk130::_identity(sizeof(world_site_unk130), &allocator_fn<world_site_unk130>, NULL, "world_site_unk130",NULL,world_site_unk130_fields);
  #define CUR_STRUCT world_underground_region
  static const struct_field_info world_underground_region_fields[] = {
    { FLD(PRIMITIVE, type), TID(world_underground_region::T_type) },
    { FLD(SUBSTRUCT, name), &language_name::_identity },
    { FLD(PRIMITIVE, index), TID(int32_t) },
    { FLD(PRIMITIVE, layer_depth), TID(int16_t) },
    { FLD(PRIMITIVE, layer_depth_p1a), TID(int16_t) },
    { FLD(PRIMITIVE, layer_depth_p1b), TID(int16_t) },
    { FLD(PRIMITIVE, unk_7a), TID(int16_t) },
    { FLD(PRIMITIVE, unk_7c), TID(int16_t) },
    { FLD(PRIMITIVE, unk_7e), TID(int16_t) },
    { FLD(PRIMITIVE, unk_80), TID(int16_t) },
    { FLD(PRIMITIVE, unk_82), TID(int16_t) },
    { FLD(PRIMITIVE, passage_density), TID(int16_t) },
    { FLD(SUBSTRUCT, region_coords), &coord2d_path::_identity },
    { FLD(CONTAINER, region_min_z), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, region_max_z), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, unk_c8), identity_traits<std::vector<void* > >::get(), 0, NULL },
    { FLD(POINTER, feature_init), identity_traits<df::feature_init >::get(), 0, NULL },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_underground_region::_identity(sizeof(world_underground_region), &allocator_fn<world_underground_region>, NULL, "world_underground_region",NULL,world_underground_region_fields);
  #define CUR_STRUCT world_unk_20::T_anon_7
  static const struct_field_info world_unk_20_doT_Dot_T_anon_7_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_unk_20::T_anon_7::_identity(sizeof(world_unk_20::T_anon_7), &allocator_fn<world_unk_20::T_anon_7>, &world_unk_20::_identity, "T_anon_7",NULL,world_unk_20_doT_Dot_T_anon_7_fields);
  #define CUR_STRUCT world_unk_20
  static const struct_field_info world_unk_20_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, anon_7), &world_unk_20::T_anon_7::_identity, 0, NULL },
    { FLD(PRIMITIVE, anon_8), TID(int16_t) },
    { FLD(PRIMITIVE, anon_9), TID(int16_t) },
    { FLD(PRIMITIVE, anon_10), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_unk_20::_identity(sizeof(world_unk_20), &allocator_fn<world_unk_20>, NULL, "world_unk_20",NULL,world_unk_20_fields);
  #define CUR_STRUCT world_unk_6c
  static const struct_field_info world_unk_6c_fields[] = {
    { FLD(SUBSTRUCT, anon_1), &coord::_identity },
    { FLD(PRIMITIVE, anon_2), TID(int8_t) },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_6), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_unk_6c::_identity(sizeof(world_unk_6c), &allocator_fn<world_unk_6c>, NULL, "world_unk_6c",NULL,world_unk_6c_fields);
  #define CUR_STRUCT world_unk_90
  static const struct_field_info world_unk_90_fields[] = {
    { FLD(PRIMITIVE, x1), TID(int16_t) },
    { FLD(PRIMITIVE, y1), TID(int16_t) },
    { FLD(PRIMITIVE, x2), TID(int16_t) },
    { FLD(PRIMITIVE, y2), TID(int16_t) },
    { FLD(PRIMITIVE, z), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_unk_90::_identity(sizeof(world_unk_90), &allocator_fn<world_unk_90>, NULL, "world_unk_90",NULL,world_unk_90_fields);
  #define CUR_STRUCT world_unk_9c
  static const struct_field_info world_unk_9c_fields[] = {
    { FLD(SUBSTRUCT, region), &coord2d::_identity },
    { FLD(SUBSTRUCT, embark), &coord2d::_identity },
    { FLD(PRIMITIVE, local_feature_idx), TID(int16_t) },
    { FLD(PRIMITIVE, global_feature_idx), TID(int32_t) },
    { FLD(PRIMITIVE, unk10), TID(int32_t) },
    { FLD(PRIMITIVE, unk14), TID(int16_t) },
    { FLD(SUBSTRUCT, local), &coord2d::_identity },
    { FLD(PRIMITIVE, z_min), TID(int16_t) },
    { FLD(PRIMITIVE, z_max), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_unk_9c::_identity(sizeof(world_unk_9c), &allocator_fn<world_unk_9c>, NULL, "world_unk_9c",NULL,world_unk_9c_fields);
  #define CUR_STRUCT world_unk_a8
  static const struct_field_info world_unk_a8_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_4), TID(int16_t) },
    { FLD(PRIMITIVE, anon_5), TID(int16_t) },
    { FLD(PRIMITIVE, anon_6), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_unk_a8::_identity(sizeof(world_unk_a8), &allocator_fn<world_unk_a8>, NULL, "world_unk_a8",NULL,world_unk_a8_fields);
  #define CUR_STRUCT world_unk_b4
  static const struct_field_info world_unk_b4_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(CONTAINER, anon_3), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(CONTAINER, anon_5), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_6), TID(int16_t) },
    { FLD(PRIMITIVE, anon_7), TID(int16_t) },
    { FLD(PRIMITIVE, anon_8), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_unk_b4::_identity(sizeof(world_unk_b4), &allocator_fn<world_unk_b4>, NULL, "world_unk_b4",NULL,world_unk_b4_fields);
  #define CUR_STRUCT world_unk_c0::T_anon_7
  static const struct_field_info world_unk_c0_doT_Dot_T_anon_7_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(PRIMITIVE, anon_4), TID(int32_t) },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_unk_c0::T_anon_7::_identity(sizeof(world_unk_c0::T_anon_7), &allocator_fn<world_unk_c0::T_anon_7>, &world_unk_c0::_identity, "T_anon_7",NULL,world_unk_c0_doT_Dot_T_anon_7_fields);
  #define CUR_STRUCT world_unk_c0
  static const struct_field_info world_unk_c0_fields[] = {
    { FLD(PRIMITIVE, anon_1), TID(int8_t) },
    { FLD(CONTAINER, anon_2), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { FLD(CONTAINER, anon_4), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_5), TID(int32_t) },
    { FLD(PRIMITIVE, anon_6), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, anon_7), &world_unk_c0::T_anon_7::_identity, 0, NULL },
    { FLD(PRIMITIVE, anon_8), TID(int16_t) },
    { FLD(PRIMITIVE, anon_9), TID(int16_t) },
    { FLD(PRIMITIVE, anon_10), TID(int16_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity world_unk_c0::_identity(sizeof(world_unk_c0), &allocator_fn<world_unk_c0>, NULL, "world_unk_c0",NULL,world_unk_c0_fields);
  #define CUR_STRUCT wound_curse_info
  static const struct_field_info wound_curse_info_fields[] = {
    { FLD(PRIMITIVE, unk_v40_1), TID(int32_t) },
    { FLD(SUBSTRUCT, add_tags1), TID(cie_add_tag_mask1) },
    { FLD(SUBSTRUCT, rem_tags1), TID(cie_add_tag_mask1) },
    { FLD(SUBSTRUCT, add_tags2), TID(cie_add_tag_mask2) },
    { FLD(SUBSTRUCT, rem_tags2), TID(cie_add_tag_mask2) },
    { FLD(PRIMITIVE, name_visible), TID(bool) },
    { FLD(PRIMITIVE, name), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_plural), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, name_adjective), identity_traits<std::string >::get() },
    { FLD(PRIMITIVE, sym_and_color1), TID(uint32_t) },
    { FLD(PRIMITIVE, sym_and_color2), TID(uint32_t) },
    { FLD(PRIMITIVE, flash_period), TID(uint32_t) },
    { FLD(PRIMITIVE, flash_time2), TID(uint32_t) },
    { FLD(PRIMITIVE, speed_add), TID(uint32_t) },
    { FLD(PRIMITIVE, speed_mul_percent), TID(uint32_t) },
    { FLD(POINTER, attr_change), identity_traits<df::curse_attr_change >::get(), 0, NULL },
    { FLD(PRIMITIVE, luck_mul_percent), TID(uint32_t) },
    { FLD(CONTAINER, interaction_id), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, interaction_time), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, time_counter), TID(int32_t) },
    { FLD(PRIMITIVE, were_race), TID(int32_t) },
    { FLD(PRIMITIVE, were_caste), TID(int32_t) },
    { FLD(CONTAINER, body_appearance), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(CONTAINER, bp_appearance), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity wound_curse_info::_identity(sizeof(wound_curse_info), &allocator_fn<wound_curse_info>, NULL, "wound_curse_info",NULL,wound_curse_info_fields);
  #define CUR_STRUCT written_content
  static const struct_field_info written_content_fields[] = {
    { FLD(PRIMITIVE, id), TID(int32_t) },
    { FLD(PRIMITIVE, page_start), TID(int32_t) },
    { FLD(PRIMITIVE, page_end), TID(int32_t) },
    { FLD(STL_VECTOR_PTR, refs), identity_traits<df::general_ref >::get(), 0, NULL },
    { FLD(CONTAINER, ref_aux), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, anon_1), TID(int32_t) },
    { FLD(PRIMITIVE, anon_2), TID(int32_t) },
    { FLD(PRIMITIVE, type), TID(written_content_type) },
    { FLD(CONTAINER, styles), identity_traits<std::vector<df::written_content_style > >::get(), 0, NULL },
    { FLD(CONTAINER, style_strength), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { FLD(PRIMITIVE, author), TID(int32_t) },
    { FLD(PRIMITIVE, anon_3), TID(int32_t) },
    { METHOD(CLASS_METHOD, find) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity written_content::_identity(sizeof(written_content), &allocator_fn<written_content>, NULL, "written_content",NULL,written_content_fields);
  #define CUR_STRUCT global::T_cursor
  static const struct_field_info global_doT_Dot_T_cursor_fields[] = {
    { FLD(PRIMITIVE, x), TID(int32_t) },
    { FLD(PRIMITIVE, y), TID(int32_t) },
    { FLD(PRIMITIVE, z), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity global::T_cursor::_identity(sizeof(global::T_cursor), &allocator_fn<global::T_cursor>, &global::_identity, "T_cursor",NULL,global_doT_Dot_T_cursor_fields);
  #define CUR_STRUCT global::T_selection_rect
  static const struct_field_info global_doT_Dot_T_selection_rect_fields[] = {
    { FLD(PRIMITIVE, start_x), TID(int32_t) },
    { FLD(PRIMITIVE, start_y), TID(int32_t) },
    { FLD(PRIMITIVE, start_z), TID(int32_t) },
    { FLD(PRIMITIVE, end_x), TID(int32_t) },
    { FLD(PRIMITIVE, end_y), TID(int32_t) },
    { FLD(PRIMITIVE, end_z), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  struct_identity global::T_selection_rect::_identity(sizeof(global::T_selection_rect), &allocator_fn<global::T_selection_rect>, &global::_identity, "T_selection_rect",NULL,global_doT_Dot_T_selection_rect_fields);
  typedef df::weather_type T_global_fields[5];
  #define CUR_STRUCT global
  static const struct_field_info global_fields[] = {
    { GFLD(PRIMITIVE, activity_next_id), TID(int32_t) },
    { GFLD(SUBSTRUCT, announcements), &announcements::_identity },
    { GFLD(PRIMITIVE, art_image_chunk_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, artifact_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, building_next_id), TID(int32_t) },
    { GFLD(CONTAINER, created_item_count), identity_traits<std::vector<int32_t > >::get(), 0, NULL },
    { GFLD(CONTAINER, created_item_matindex), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { GFLD(CONTAINER, created_item_mattype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { GFLD(CONTAINER, created_item_subtype), identity_traits<std::vector<int16_t > >::get(), 0, NULL },
    { GFLD(CONTAINER, created_item_type), identity_traits<std::vector<df::item_type > >::get(), 0, NULL },
    { GFLD(PRIMITIVE, crime_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, cur_season), TID(int8_t) },
    { GFLD(PRIMITIVE, cur_season_tick), TID(int32_t) },
    { GFLD(PRIMITIVE, cur_year), TID(int32_t) },
    { GFLD(PRIMITIVE, cur_year_tick), TID(int32_t) },
    { GFLD(PRIMITIVE, cur_year_tick_advmode), TID(int32_t) },
    { GFLD(STATIC_ARRAY, current_weather), identity_traits<T_global_fields >::get(), 5, NULL },
    { GFLD(SUBSTRUCT, cursor), &global::T_cursor::_identity },
    { GFLD(SUBSTRUCT, d_init), &d_init::_identity },
    { GFLD(PRIMITIVE, debug_combat), TID(bool) },
    { GFLD(PRIMITIVE, debug_fastmining), TID(bool) },
    { GFLD(PRIMITIVE, debug_noberserk), TID(bool) },
    { GFLD(PRIMITIVE, debug_nodrink), TID(bool) },
    { GFLD(PRIMITIVE, debug_noeat), TID(bool) },
    { GFLD(PRIMITIVE, debug_nomoods), TID(bool) },
    { GFLD(PRIMITIVE, debug_nopause), TID(bool) },
    { GFLD(PRIMITIVE, debug_nosleep), TID(bool) },
    { GFLD(PRIMITIVE, debug_showambush), TID(bool) },
    { GFLD(PRIMITIVE, debug_turbospeed), TID(bool) },
    { GFLD(PRIMITIVE, debug_wildlife), TID(bool) },
    { GFLD(SUBSTRUCT, enabler), &enabler::_identity },
    { GFLD(PRIMITIVE, entity_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, flow_guide_next_id), TID(int32_t) },
    { GFLD(STL_VECTOR_PTR, flows), identity_traits<df::flow_info >::get(), 0, NULL },
    { GFLD(PRIMITIVE, formation_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, gamemode), TID(game_mode) },
    { GFLD(PRIMITIVE, gametype), TID(game_type) },
    { GFLD(SUBSTRUCT, gps), &graphic::_identity },
    { GFLD(SUBSTRUCT, gview), &interfacest::_identity },
    { GFLD(PRIMITIVE, hist_event_collection_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, hist_event_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, hist_figure_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, identity_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, incident_next_id), TID(int32_t) },
    { GFLD(SUBSTRUCT, init), &init::_identity },
    { GFLD(PRIMITIVE, interaction_instance_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, item_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, job_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, machine_next_id), TID(int32_t) },
    { GFLD(SUBSTRUCT, map_renderer), &map_renderer::_identity },
    { GFLD(PRIMITIVE, nemesis_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, pause_state), TID(bool) },
    { GFLD(PRIMITIVE, process_dig), TID(bool) },
    { GFLD(PRIMITIVE, process_jobs), TID(bool) },
    { GFLD(PRIMITIVE, proj_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, save_on_exit), TID(bool) },
    { GFLD(PRIMITIVE, schedule_next_id), TID(int32_t) },
    { GFLD(SUBSTRUCT, selection_rect), &global::T_selection_rect::_identity },
    { GFLD(PRIMITIVE, squad_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, standing_orders_auto_butcher), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_auto_collect_webs), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_auto_fishery), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_auto_kiln), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_auto_kitchen), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_auto_loom), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_auto_other), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_auto_slaughter), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_auto_smelter), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_auto_tan), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_dump_bones), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_dump_corpses), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_dump_hair), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_dump_other), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_dump_shells), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_dump_skins), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_dump_skulls), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_farmer_harvest), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_forbid_other_dead_items), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_forbid_other_nohunt), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_forbid_own_dead), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_forbid_own_dead_items), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_forbid_used_ammo), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_gather_animals), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_gather_bodies), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_gather_food), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_gather_furniture), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_gather_minerals), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_gather_refuse), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_gather_refuse_outside), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_gather_vermin_remains), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_gather_wood), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_job_cancel_announce), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_mix_food), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_use_dyed_cloth), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_zoneonly_drink), TID(uint8_t) },
    { GFLD(PRIMITIVE, standing_orders_zoneonly_fish), TID(uint8_t) },
    { GFLD(PRIMITIVE, task_next_id), TID(int32_t) },
    { GFLD(SUBSTRUCT, texture), &texture_handler::_identity },
    { GFLD(STL_VECTOR_PTR, timed_events), identity_traits<df::timed_event >::get(), 0, NULL },
    { GFLD(SUBSTRUCT, ui), &ui::_identity },
    { GFLD(SUBSTRUCT, ui_advmode), &ui_advmode::_identity },
    { GFLD(PRIMITIVE, ui_area_map_width), TID(int8_t) },
    { GFLD(SUBSTRUCT, ui_build_selector), &ui_build_selector::_identity },
    { GFLD(CONTAINER, ui_building_assign_is_marked), identity_traits<std::vector<char > >::get(), 0, NULL },
    { GFLD(STL_VECTOR_PTR, ui_building_assign_items), identity_traits<df::item >::get(), 0, NULL },
    { GFLD(CONTAINER, ui_building_assign_type), identity_traits<std::vector<int8_t > >::get(), 0, NULL },
    { GFLD(STL_VECTOR_PTR, ui_building_assign_units), identity_traits<df::unit >::get(), 0, NULL },
    { GFLD(PRIMITIVE, ui_building_in_assign), TID(bool) },
    { GFLD(PRIMITIVE, ui_building_in_resize), TID(bool) },
    { GFLD(PRIMITIVE, ui_building_item_cursor), TID(int32_t) },
    { GFLD(PRIMITIVE, ui_look_cursor), TID(int32_t) },
    { GFLD(SUBSTRUCT, ui_look_list), &ui_look_list::_identity },
    { GFLD(PRIMITIVE, ui_menu_width), TID(int8_t) },
    { GFLD(PRIMITIVE, ui_selected_unit), TID(int32_t) },
    { GFLD(SUBSTRUCT, ui_sidebar_menus), &ui_sidebar_menus::_identity },
    { GFLD(SUBSTRUCT, ui_unit_view_mode), &ui_unit_view_mode::_identity },
    { GFLD(PRIMITIVE, ui_workshop_in_add), TID(bool) },
    { GFLD(PRIMITIVE, ui_workshop_job_cursor), TID(int32_t) },
    { GFLD(PRIMITIVE, unit_chunk_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, unit_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, vehicle_next_id), TID(int32_t) },
    { GFLD(PRIMITIVE, window_x), TID(int32_t) },
    { GFLD(PRIMITIVE, window_y), TID(int32_t) },
    { GFLD(PRIMITIVE, window_z), TID(int32_t) },
    { GFLD(SUBSTRUCT, world), &world::_identity },
    { GFLD(PRIMITIVE, written_content_next_id), TID(int32_t) },
    { FLD_END }
  };
  #undef CUR_STRUCT
  global_identity global::_identity(global_fields);
}
